V3.0

# 序言
最有限的篇幅，解剖Linux内核，以理解基本功能和实际实现
选用Linux早期内核版本，因为精简，要素齐全
但不支持虚拟文件系统、网络系统、仅支持a.out执行文件，其他复杂系统可以在当前这些基础学好了之后再去学
RTFSC(Read The Fucking Source Code!)
需要注重实践，比如I/O的代码会比调度算法的代码多得多
作者选择了0.11版内核，不超过2万行代码
对应的文件系统是最简单的MINIX 1.0文件系统，而非Ext2/Ext3文件系统。

# 第1章 概述
## 1.1 诞生和发展
类UNIX系统
Linux的发展依赖五个要素：
1. UNIX操作系统（1969，美国贝尔实验室）
2. MINIX操作系统（教学用途，也是模仿UNIX的）
3. GNU计划（提供了bash shell等GNU软件环境）
4. POSIX标准
5. 因特网

### 1.1.3 GNU计划
自由软件项目，旨在开发一个自由软件类UNIX系统，现在的基于Linux内核的GNU操作系统准确来说应该被称为GNU/Linux系统）
GNU项目同时也开发出了：bash shell，gcc，gdb。它们为Linux操作系统的开发创造了一个合适的环境。

### 1.1.4 POSIX标准
由IEEE，ISO/IEC开发的标准，基于UNIX实践和经验，描述了操作系统的调用服务接口。保证应用的源代码在多种操作系统的移植和运行。
起源是一个UNIX用户组（user/group）的早期工作，它试图将AT&T的System V操作系统和Berkley CSRG的BSP操作系统的调用接口之间的区别重新组织集成。
内容包括：系统服务应用程序编程接口（API）（POSIX.1），命令与工具标准（POSIX.2），测试方法标准（POSIX.3），实时API（POSIX.4）。
该标准指导了Linux的开发。

### 1.1.5 Linux操作系统的诞生
80年代的操作系统都太贵
91年，GNU C编译器已开发，Linux研究MINUX、Intel 386体系结构，研究终端仿真程序和硬件驱动程序。
“理论毕竟是理论，省略的部分虽然没理论含量，但却是系统的必要组成部分”

### 1.1.6 Linux操作系统版本的变迁
V0.1版本，已经可以使用GNU gcc编译内核，支持加载/卸载文件系统。

## 1.2 内容综述
发布时包括以下文件：
1. bootimage.Z  具有美国键盘代码的压缩启动映像文件
2. rootimage.Z  根文件系统映像文件
3. 内核源代码文件（94KB）
4. 二进制执行文件，16位的汇编程序和装入程序
5. 更新安装信息文件

`bootimage.Z`是引导启动Image文件，包括：`磁盘引导扇区代码`、`操作系统加载程序` 和 `内核执行代码`。
PC启动时，ROM BIOS中的程序把默认启动驱动器上的`引导扇区代码`和`数据`读入内存，然后`引导扇区代码`负责把`操作系统加载程序`和`内核执行代码`读入内存中，然后控制权交给`操作系统加载程序`，它进一步准备内核的初始化操作，最终，加载程序把控制权交给内核代码。
`内核代码`如果要正常运行就要`文件系统`的支持。`rootimage`就是用于向内核提供最基本支持的`根文件系统`（包括操作系统最起码的一些配置文件和命令执行程序）。

0.11版本，尚不包括专门的进程等待队列，或者TCP/IP等内容
本书后续对代码的说明是以内核中源代码的组成结构来进行的，后续代码中会出现C语言内嵌汇编代码

## 第二章 微型计算机组成结构
计算机系统，简单来看，分为四部分：
能源、输入部分、处理中心、输出部分

## 2.1 微机组成原理
CPU通过`地址线`、`数据线`、`控制信号线`组成的内部总线和系统的其他部分进行数据通信。
`地址线`用于提供内存或I/O设备的地址，即指明需要读/写数据的具体位置。
`数据线`用于在CPU和内存或I/O设备之间提供数据传输的通道。
`控制线`则负责指挥执行的具体读/写操作。
对于80386 CPU的PC机，地址线和数据线都有32根，即都是32位。地址寻址空间就是2^32字节：0~4GB。
控制器和存储器接口通常都集成在计算机主板，这些控制器都是以一块大规模集成电路芯片为主组成的功能电路。
例如，`中断控制器`由 Intel 8259A 或其兼容芯片构成；
`DMA控制器`通常采用Intel 8237A芯片构成；
`定时计数器`的核心则是Intel 8253/8254定时芯片；
`键盘控制器`使用的是Intel 8042芯片来与键盘中的扫描电路进行通信。
各种控制卡（或者称为适配器，串行口控制卡、硬盘控制卡）则是通过`扩展插槽`与主板上系统总线连接。
`总线插槽`是系统地址总线、数据总线和控制线的与扩展设备控制器的`标准连接接口`。
这些总线皆苦标准通常有工业标准总线（ISA）等各种总线。随着计算机硬件的发展，传输速率更高、控制更灵活的总线接口在不断地推出，例如采用串行通信点对点技术的高速`PCIE`总线。

随着计算机技术的发展，很多原来使用控制卡来完成的功能（例如`硬盘控制器`功能）都已经`集成`在计算机主机板上少数几个超大规模集成电路芯片中，几个甚至是一个这样的芯片就确定了主机板的主要特性和功能，并且为了让系统的不同部分都能达到其最高传输速率，总线结构也发生了很大变化。
除了CPU以外，现代PC机主板主要使用2个**超大规模芯片**构成的芯片组或芯片集（Chipsets）组成：`北桥`（Northbridge）芯片和`南桥`（Southbridge）芯片。`北桥`芯片用于与`CPU、内存和AGP视频接口`，这些接口具有很高的传输速率。北桥芯片还起着存储器控制作用。
`南桥`芯片用来管理`低、中速的组件`，例如， `PCI总线、IDE硬盘接口、USB端口`等。
之所以用“南、 北”桥来分别统称这两个芯片，是由于在Intel公司公布的典型PC机主板上，它们分别位于主版的下端和上端（即地图上的南部和北部）位置，并起着与CPU进行通道桥接的作用。

## 2.2 I/O端口寻址和控制访问方式
### 2.2.1 I/O端口和寻址
CPU为了访问I/O接口控制器或控制卡上的数据和状态信息，需要首先指定它们的`地址`。
这种地址就称为I/O端口地址或者简称`端口`。
通常一个I/O控制器包含访问数据的`数据端口`、输出命令的`命令端`口和访问控制器执行状态的`状态端口`。
端口地址的设置方法一般有两种：`统一编址`和`独立编址`。（区别就是是否直接占用常规的内存地址空间，统一编址的好处是简化指令，可以直接使用常规的指令，而独立编址需要使用专门的I/O指令来访问端口）
**端口统一编址**的原理是把I/O控制器中的端口地址归入存储器寻址地址空间范围内。因此这种编址方式也成为`存储器映像编址`。
**CPU访问一个端口的操作与访问内存的操作一样，也使用访问内存的指令**。
**端口独立编址**的方法是把I/O控制器和控制卡的寻址空间单独作为一个独立的地址空间对待，称为I/O地址空间。
每个端口有一个I/O地址与之对应，并且使用专门的I/O指令来访问端口。
`IBM PC 及其兼容微机`主要使用`独立编址`方式，采用了一个独立的I/O地址空间对控制设备中的寄存器进行寻址和访问。使用ISA总线结构的传统PC机其I/O地址空间范围是0x000——0x3FF，有1024个I/O端口地址可供使用。各个控制器和控制卡所默认分配使用的端口地址范围见表2—1所示。关于这些端口的使用和编程方法将在后面具体涉及相关硬件时再详细进行说明。
另外，IBMPC机也部分地使用了`统一编址`方式。例如，CGA显示卡上显示内存的地址就直接占用了存储器地址空间0xB800——0xBC00范围。因此若要让一个字符显示在屏幕上，可以直接使用内存操作指令往这个内存区域执行写操作。

### 2.2.2 接口访问控制
I/O接口数据传输控制方式一般有`程序循环查询方式`、`中断处理方式`、`DMA传输方式`。
`轮询`一般用于多任务操作系统中，等待时间极短或者是必须使用的场景。
`中断`，需要中断控制器的支持：只有当I/O设备通过中断向CPU提出处理请求时，CPU才会暂时中断当前执行的程序转而去执行相应的I/O中断处理服务程序。
CPU使用中断向量表来寻址和中断类型相应的中断服务程序的入口地址。
`DMA(Direct Memory Access)`用于I/O设备与系统内存之间进行**批量数据传送**，无需CPU进行。

## 2.3 主存、BIOS和CMOS存储器
### 2.3.1 主存
为了兼容，系统1MB以下的物理内存分配与原来的老的架构一致，而BIOS处于ROM中CPU能寻址的内存最高的位置。
当计算机上电初始化时，`物理内存`被设置成从地址0开始的连续区域。除了地址从`0xA0000`到`0xFFFFF`（640K到1M共384K）和`0XFFFE0000`到`0XFFFFFFFF`(4G处的最后一64K)范围以外的所有内存都可以用作系统内存。
这两个特定范围被用于`I/O设备`和`BIOS程序`。
假如我们的计算机中有`16MB`的物理内存，那么在Linux 0.1x系统中，`0-640K`将被用作存放`内核代码`和`数据`。
Linux内核不使用BIOS功能，也不使用BIOS设置的中断向量表。`640K-1M`之间的384K仍然保留用作BIOS数据区和中断向量表。其中地址 `0xA0000`开始的128K用作`显示内存缓冲区`，随后部分用于`其他控制卡的ROM BIOS`或`其映射区域`，而`0xF0000`到`1M`范围用于高端系统`ROM BIOS`的映射区。`1M ~ 16M`将被内核用于作为可分配的主内存区。另外高速缓冲区和内存虚拟盘也会占用内核代码和数据后面的一部分内存区域，该区域通常会跨越640K——1M的区域。

### 2.3.2 基本输入输出程序 BIOS
存放在ROM中的系统`BIOS程序`主要用于计算机开机时执行系统各部分的`自检`，建立起操作系统需要使用的`各种配置表`，例如`中断向量表`、`硬盘参数表`。
并且把处理器和系统其余部分`初始化`到一个已知状态，而且还为DOS等操作系统提供硬件设备接口服务。
但是由于BIOS提供的这些服务不具备可重入性（即其中程序不可并发运行），并且从访问效率方面考虑，因此**除了在初始化时会利用BIOS提供一些系统参数以外，Linux操作系统在运行时并不使用BIOS中的功能**。
当计算机系统上电开机或者按了机箱上的复位按钮时，CPU会自动把`代码段寄存器CS`设置为`0xF000`，其`段基地址`则被设置为`0xFFFF0000`，`段长度`设置为`64KB`（是实模式的限制，程序/数据不能超过64KB，只能访问段基址开始的64KB）。
而`IP`（偏移）被设置为`0xFFF0`，因此此时CPU代码指针指向`0xFFFFFFF0`处，即4G空间最后一个64K的最后16字节处，这里正是`系统ROM BIOS`存放的位置。并且BIOS会在这里存放一条`跳转指令JMP`跳转到BIOS代码中64KB范围内的某一条指令开始执行。
（！！！传统的16位实模式只能访问第一个1MB地址空间，因为地址总线20位，对应只支持1M范围的寻址，对于64KB以外的代码或者数据是通过切换段基址来访问的）
由于目前PC/AT微机中BIOS容量大多有1MB到2MB，并存储在闪存（Flash Memory，断电不丢失）ROM中，因此为了能够执行或访问BIOS中超过64KB范围并且又远远不在0~1M地址空间中的其他BIOS代码或数据，BIOS程序会首先使用一种称为`32位大模式（Big Mode）`技术把`数据段寄存器`的访问范围设置成4G（而非原来的64K），这样就可以在0到4G范围内执行和操作数据。
此后，BIOS在执行了一些列硬件检测和初始化操作之后，就会把与原来PC机兼容的`64KB BIOS代码和数据`复制到内存低端1M末端的64K处，然后跳转到这个地方并且让CPU进入真正的`实地址模式`工作（临时进行保护模式，最后再回到实地址模式）。最后BIOS就会从硬盘或其他块设备把操作系统引导程序加载到`内存0x7c00`处（留出前面的空间给BIOS使用），并跳转到这个地方继续执行引导程序。

### 2.3.3 CMOS存储器
在PC/AT机中，除需要使用内存和ROM BIOS以外，还使用只有`很少存储容量`的（只有64或128字节）CMOS（Complementary Metal Oxide Semiconductor，互补金属氧化物半导体）存储器来存放计算机的 `实时时钟信息`和`系统硬件配置信息`。
这部分内存通常和`实时时钟芯片（Real Time Chip）`做在一块集成块中。
CMOS内存的地址空间在基本内存地址空间之外，需要使用`I/O指令`来访问。

## 2.4 控制器和控制卡
### 2.4.1 中断控制器
IBM PC/AT 80X86兼容微机使用`两片级联`的`8259A可编程中断控制芯片`组成一个`中断控制器`，用于实现I/O设备的中断控制数据存取方式，并且能为15个设备提供独立的中断控制功能，见图2—6所示。

在计算机刚开机初始化期间，ROM BIOS会分别对两片8259A芯片进行初始化，并分别把`15级中断优先级`分配给`时钟定时器`、`键盘`、`串行口`、`打印口`、`软盘控制`、`协处理器`和`硬盘`等设备或控制器使用。
同时在内存开始`处0x000~0xFFF`区域内建立一个`中断向量表`。
但是由于这些设置违背了Intel公司的要求（后面章节将会详细说明），因此Linux操作系统在内核初始化期间又重新对8259A进行了设置。
有关中断控制器工作原理和编程方法的详细说明请参见后续章节。

PC上电开机后，ROM BIOS会设置硬件中断请求号，但是Linux系统不直接使用它们，而是在系统初始化时重新设置：`<中断请求号, 中断向量号>`。

### 2.4.2 DMA控制器
主要功能：让`外设`直接与`内存`传输数据。
对DMA控制器进行编程，可以让外设和内存的数据传输不受CPU控制，因此CPU可以在数据传输的时候，做其他事情。

### 2.4.3 定时/计数器
Intel 8253/8254，可编程定时/计数器芯片，处理计算机中的精确时间延迟。
程序员可以配置8253使用其中的一个计数器通道达到所期望的延时，当延时到达后，该芯片会向CPU发送一个中断信号。
3个通道分别用作：
1. 日时钟计时中断信号
2. 动态内存DRAM刷新定时电路
3. 主机扬声器
Linux 0.11只使用了通道0：工作在方式3，每隔10ms，发送一个信号，产生中断请求信号（IRQ0），用于内核工作的脉搏：定时切换当前执行的任务和统计每隔任务使用的系统资源量（时间）

### 2.4.4 键盘控制器
扫描、案件状态信息：扫描码

### 2.4.5 串行控制卡
1. 异步串行通信原理
帧：为了传送一个有效数据长度单位的格式
为了通信双方`确定收发顺序`和`进行一些错误检测操作`，需要基于`协议`设计一些其他信息：同步和错误检测信息。
结构如下：
起始同步信息 + payload + 校验等信息

`串行通信`：以比特位数据流一次一个比特进行传输
分为`异步`和`同步`
区别在于传输时`同步的通信单位`或`帧长度`不同
`异步串行通信`以一个字符作为一帧    相当于说话的时候，一个字一个字地蹦，每个字说完停顿任意长时间
`同步串行通信`以多个字符或字节组成的序列，作为一帧  相当于一次说一句话
这其实是一种习惯上的划分，因为当传输单位缩小到一个位，那么以一个字符进行传输的异步通信，也可以看作同步传输通信

2. 异步串行传输格式
一个字符帧包含：
起始位（0）、数据位、奇偶校验位、停止位（1）
数据位用于表示一个字符，5~8 bit

3. 串行控制器
PC机通常有2个符合RS-232C标准的串行接口，使用UART（通用异步接收/发送器控制芯片）组成的串行控制器来处理串行数据的收发

软盘驱动器被U盘存储器取代


# 第三章 内核编程语言和环境
## 3.1 as86汇编器
0.1x系统有两种汇编器：
1. 产生16位代码的`as86汇编器`，使用配套的`ld86链接器`
    linux只用它来创建16位的启动引导扇区程序boot/bootsect.s，以及 实模式下初始设置程序boot/setup.s的二进制执行代码
    快速小巧，比GNU gas多了宏定义，和更多的错误检测
    语法不兼容GNU gas，类似微软的MASM等语法，基于Intel
2. GNU的汇编器`gas`，使用`GNU ld链接器`来链接产生的目标文件

### 3.1.1 as86汇编语言语法
输入 低级汇编语言程序，输出含机器码的二进制程序 / 目标文件
```sh
as [选项] -o objfile srcfile
```
汇编器编译出的目标文件，通常包含三个段：`.text`（正文段，代码和只读数据） `.data`（数据段，已初始化过的可读可写数据） `bss`（未初始化数据段） 
对于`bss`，目标文件不会保留空间，在链接成可执行文件，并被操作系统加载时，将该段的内容全初始化为0

### 3.1.2 as86汇编语言程序
bootsect.s的框架程序，是引导扇区启动程序
编译链接产生的执行程序可以放入软盘中的第1个扇区，用来引导计算机启动
业务逻辑：在屏幕17行，第5列显示红色字符串：“Loading system...”，光标下移1行，然后程序在27行死循环

```sh
! boot.s    ! 表示注释
.globl begtext, begdata, begbss, endtext, enddata, endbss   ! 全局标识符，供ld86链接使用
.text       ! 正文段
begtext:
.data       ! 数据段
begdata:
.bss        ! 未初始化数据段
begbss:
.text       ! 正文段
BOOTSEG  = 0x07c0			! BIOS加载bootsect代码的原始段地址

entry _start
_start:
    ! 设置字符显示在屏幕，是基于中断来实现的，一顿MOV，然后 INT 0x10
# ......
.org 510    ! 以后语句从地址510处开始存放

# ......
```


### 3.1.3 编译和链接
```sh
# 编译，生成目标文件

# 链接，并去掉符号信息，链接一些库？

# 将可执行文件写入软盘或者镜像盘文件,需要手动去掉前32个字节(可执行文件头)   这是基于dd命令来做的，dd命令专门用于数据转储/复制文件

```

### 3.1.4 as86和ld86使用方法和选项



## 3.2 GNU as汇编
内核中的汇编是使用gas来编译的，和C产生的模块进行链接

出于执行效率的考虑，关键部分会使用汇编（整个系统里大约包含10%）

编译C程序时，`GNU gcc编译器`会首先输出一个作为`中间结果`的as汇编语言文件，然后gcc调用`as汇编器`临时汇编程序编译成目标文件
as汇编器最初是专门用于汇编gcc产生的中间汇编程序

as输出由汇编语言程序编译（确实是编译，因为除了把助记符号改成机器码，还要处理如标签符号-->地址的解析，甚至处理重定位信息）而成的`二进制目标文件`，名为a.out，后续作为`链接器ld`的输入

### 3.2.2 as汇编语法
```sh
标号：指令助记符 操作符1, 操作符2

```

### 3.2.4 section（区）与重定位
section表示一个地址范围，用于表示 `目标文件/可执行文件` 中不同的信息区域：`正文区` / `数据区` / `bss区`（实际上也是按照这个顺序）（另外还有绝对地址区域）
目标文件中的区的长度和字节序是固定的
`为 区 分配运行时地址`的操作就是`重定位`，汇编器会写入必要的重定位信息

## 3.3 C语言程序
预处理、编译（生成汇编代码）、汇编（转成机器指令）、链接

### 3.3.2 嵌入汇编
```cpp
// 一般嵌入在宏定义内
asm(
    "汇编语句"
    : 输出寄存器
    : 输入寄存器
    : 会被修改的寄存器);

// 实际示例
```

### 3.3.4 寄存器变量
允许把一些变量放到CPU寄存器，即`寄存器变量`，从而避免访存
有两种：`全局寄存器变量`（程序运行中，一直存储全局变量），`局部寄存器变量`（存储内嵌asm汇编语句中操作数）

### 3.3.5 内联函数
避免函数调用栈的开销

## 3.4 C与汇编 相互调用
### 3.4.1 C函数调用机制
linux内核程序`boot/head.s`执行完基本初始化操作后，跳转去执行`init/main.c`   执行控制如何转交？

`函数调用`的本质：代码块1 到 代码块2 的双向数据传递，执行控制转移
数据传递是基于`函数参数`，`返回值`
进入函数时，为局部变量分配存储空间，退出时回收（基于栈操作）

#### 3.4.1.1 栈帧结构 控制转移权方式
大多CPU上的程序基于`栈`来支持`函数调用`
`栈帧`是指单个函数调用操作使用的内存结构（栈帧的两端由两个指针指定：`ebp`用作`帧指针`，`esp`用作`栈指针`（随着出入栈移动））
（栈是往低地址延伸，栈顶在低地址）
基于程序的栈内存空间，以及 一些寄存器

`CALL`：把返回地址(程序中，CALL的吓一跳指令的地址)，压入栈中，并且跳转被调用函数
`RET`：弹出栈顶处的地址，并跳转到该地址

```c
void swap(int* a, int *b) {
    int c;
    // ...
}

int main() {
    int a, b;
    a = 16, b = 32;
    swap(&a, &b);
    return (a - b);
}
```

```sh
# 从上到下，地址减小，调用者的栈帧之后，才是当前栈帧
保存的ebp   # main函数的栈帧（栈底）
a
b
&b
&a
返回地址    # main函数的栈顶（是调用swap最开始，先压入栈中的，算作是main函数栈帧的结束位置）
保存的ebp   # swap 栈帧（栈底） ———— ebp寄存器
c          # swap 栈顶        ———— esp寄存器
```
从汇编层面看，函数代码中，必然先保存EBP的值（`pushl %ebp`）
通过操作栈顶指针，来增加栈空间（或者说给实参分配空间）
然后函数实参压栈（从右往左，先压入第二个）
执行业务逻辑
然后恢复寄存器
返回

总结：
1. 设置
    初始化栈帧结构
2. 主体
    函数业务逻辑
3. 结束
    恢复栈状态，从函数返回
```sh
movl %ebp, %esp # esp = ebp
popl %ebp       # 恢复基址指针
```

#### 3.4.1.3 main()也是一个函数
main()在编译链接时，会作为`ctr0.s`（c run-time）汇编程序的函数被调用，该程序是一个stub程序
```sh
.text
.global _environ            # 声明全局变量

_entry:                     # 代码入口标号
    movl 8(%ebp), %eax      # 取程序的环境变量指针envp并保存在_environ
    movl %eax, _environ     # execve()调用时，设置envp
    call _main              # 调用主程序，返回值状态在eax中
    pushl %eax              # 压入返回值作为exit()函数的参数
    call _exit
    jmp lb                  # 正常不会调到这里

.data
_environ:                   # 定义变量，分配长字空间
    .long 0
```

编译程序的时候，stub模块也会一并参与链接
PS：
##### `ELF格式`：
ELF header（类型：是exe / .o / .so，体系结构，入口点地址）
Program header table（说明每个段由什么组成）
section header table（包含所有section的信息，一个节可能用作.text，.data，.bss）
sections（如.text .rodata .data .bss）
symbol tables（动态 / 静态符号表，记录函数/变量名及其在文件中的位置）
relocation tables（用于链接器处理.so）
dynamic section（提供动态加载的必要信息）

在C++中，gcc编译器会提供main()之前的`启动模块`，执行全局构造/全局析构，并且调main之前还会调.init的代码

### 3.4.2 在汇编程序中调用C函数

### 3.4.3 在C程序中调用汇编函数

## 3.5 Linux 0.11目标文件格式
linux 0.11使用`2种编译器`来生成内核代码文件
1. 汇编器as86、ld86
2. GNU 汇编器gas，C语言编译器gcc，链接器gld

### 3.5.1 目标文件格式
GNU gas, gcc输出的目标文件, 可执行文件都是基于传统UNIX的a.out格式（对于具有内存分页机制的系统，它简单有效，因为文件里包含一些绝对地址，对于分页系统而言，进程的独立地址空间是虚拟的，进程A和虚拟地址和进程B的相同虚拟地址永远不会冲突）。
PS：分页机制的意思就是：针对`虚拟地址`和`物理地址`，以固定大小（页）进行划分，通过页表建立映射关系
```
a.out文件头
text section    正文段
data section    已初始化数据区
text relocation
data relocation
symbol table    符号表
string table    字符串表
```
**可执行文件 和 进程逻辑地址空间 存在映射关系**
可执行文件-text --> 进程地址空间-text
可执行文件-data --> 进程地址空间-data
可执行文件中的header用于确定进程地址空间中的bss(未初始化数据区，可执行文件中也有类似的bss，但是相关的元数据在data中。这样的话，有的数据可以在可执行文件中精简表示，而在运行时的进程内存空间中再恢复出来，一般是全局变量和静态变量), data, text中的长度

linux 0.11的进程逻辑大小空间是64MB
**需求页**技术
在一页代码实际要用时，才加载到物理内存
`fs/execve()`函数，只是设置`分页机制的页目录项和页表项`，没有真正加载所有代码

### 3.5.3 链接程序输出
链接程序在链接若干二进制文件时，首要任务是：
给二进制文件分配存储空间，从而才可以执行`符号绑定、代码修正（填写真实地址）`，因为那些模块文件中的符号和文件中的存储位置有关，所以符号对应位置不确定，则无法解析符号

链接程序会把每个模块文件中**相同类型的段**进行组合（至少代码段显然要组合）

可执行文件的内部中，代码块的空间会按照页边界对齐，对于不足一页的会进行填充，然后才是数据段

#### 加载可执行文件的过程
（可能就是`execve`系统调用的内部流程）
根据头部信息MAGIC NUM判断是否合格
然后系统在`用户态堆栈顶部`，设置环境变量、命令行参数，并构建相应的任务数据结构（是`task_struct`吗？）。
接着，设置相关寄存器值，利用堆栈返回技术（中断返回指令？iret？实现内核态 -> 用户态）去执行程序。
执行程序映像文件中的代码和数据将会在实际需要时动态加载到内存。
（进程的内存空间有一段高地址是留给内核空间）

其实编译出的内核镜像，是不需要ELF执行头的，因为内核是由引导启动程序利用ROM BIOS中断调用加载到内存的。
实际上，现代系统镜像还是会有个给引导程序读取的头，而且也不只是BIOS中断就够了。

### 3.5.5 System.map文件
链接时，加`-M`选项，或者`nm`命令，则会在屏幕打印链接映像（link map）信息：由链接程序产生的目标程序内存地址映像信息，用于表明：
1. 目标文件-符号信息 映射到内存中的位置
2. 公共符号如何放置
3. 链接中包含所有的文件成员以及引用的符号

通过符号表，可以得知地址值对应的变量名



# 第四章 80X86 保护模式及其编程
80X86

### 4.1.1 标志寄存器

### 4.1.2 内存管理寄存器

### 4.2.2 地址变换

## 4.3 分段机制

## 4.4 分页机制



# 第五章 Linux内核体系结构
本章用于对内核源代码的总结概述
需要注意下80X86保护模式运行方式

一个完整的操作系统主要由4部分：硬件、**操作系统内核**（对硬件资源的抽象和访问调度）、操作系统服务（向用户提供服务，这些服务被看作是操作系统部分功能，如shell解释系统，内核编程接口等系统程序）、用户应用程序

linux内核，主要是为了**与计算机硬件进行交互，为应用提供高级执行环境、对硬件的虚拟接口**

## 5.1 Linux内核模式
操作系统内核一般有`宏内核`（操作系统的核心功能都在内核空间） / `微内核`（内核只保留基本功能）
linux 0.11是宏内核（内核代码结构紧凑，执行快，但是层次结构性不强）
宏内核操作系统提供服务的流程：
应用程序基于指定参数执行`系统调用`（`int x80`）
    CPU从`用户态`切换到`内核态`
    OS调用特定的`系统调用服务程序`，会涉及到更底层的支持函数
    完成调用后，OS使CPU从`内核态`切换为`用户态`（回到应用继续执行后面的指令）

## 5.2 Linux内核系统体系结构
五大模块:
1. 进程调度模块（被其他模块依赖，比如写磁盘时，进程被挂起）
2. 内存管理模块
3. 文件系统模块（并非虚拟文件系统，虚拟机文件系统要到0.95才实现）
4. 进程间通信模块
5. 网络接口模块（要到0.96才实现）

## 5.3 Linux内核对内存的管理和使用
### 5.3.1 物理内存
系统初始化时对物理内存进行划分。
低地址到高地址分别是：
内核模块、高速缓存区{ 显存、BIOS ROM }、虚拟盘、主内存区。
进程读取块设备中的数据时，系统先把数据读到高速缓存区，进程要写数据也是先写到高速缓存区，后续由块设备驱动程序再写到相应的设备上。

80X86 CPU，对地址管理同时有`分段`和`分页`的策略

### 5.3.2 内存地址空间概念
有3种地址来回变换
1. 进程的虚拟和逻辑地址
2. CPU的线性地址
3. 实际物理内存地址

虚拟地址：
    `段选择符:段内偏移地址`
    由`段选择符`（查 GDT, Global Discriptor Table，每个CPU一个 / LDT, Local Discriptor Table） + `段内偏移地址`组成，经过映射变成物理地址
逻辑地址：
    程序产生的、与段有关的`偏移地址部分`（只管偏移部分即可）
    在intel保护模式下，就是程序执行代码段限长内的偏移地址（假定代码段、数据段完全一样）
    应用程序开发者，只和逻辑地址打交道，感知不到分段、分页
线性地址：
    虚拟地址到物理地址的中间层，是处理器可寻址的内存空间中的地址
    如果启用分页机制，线性地址 变换为 物理地址（这里的变换，具体是指线性地址再一步拆解：页目录索引、页表索引、页内偏移，通过多级页表映射到实际的物理地址）
      不启用分页机制，线性地址 就是 物理地址

虚拟存储：
    呈现出比实际内存大的多的内存量
    linux 0.11，每个进程划分了`64MB`的虚拟存储空间

### 5.3.3 内存分段机制
`虚拟地址（段选择符：偏移值/逻辑地址）` 通过`分段机制` 映射到中间层的4GB（2^32）`线性地址空间`中。
当程序引用一个内存地址时，`相应的段基址` + 程序员可见的`逻辑地址` = `线性地址`
CPU进行地址变换的**缺页加载机制**：（mm/memory.c）
    要先通过缺页中断，把引起中断的线性地址放到`CR2寄存器`
    后续把进程要求的页面，从磁盘加载到物理内存
    如果物理内存占满，则把磁盘的一部分作为`swapper`缓冲区，把内存中暂时不用的页面搁置。

Intel CPU使用`段`的概念，来对程序进行寻址。
每个`段`，定义了内存中的某个区域以及访问的优先级。
CPU在`实模式`和`保护模式`下寻址方式不同。

**实模式**（实模式没有虚拟内存的设定）
内存寻址是基于`段`，`偏移值`。`段`放在`段寄存器`，段长固定64KB，段内偏移地址存放在任意一个可用于寻址的寄存器中。

**保护模式**（可通过开启分页机制，开启虚拟内存）
`段寄存器`存放的是`一个 段描述符表 中，某一描述符项在表中的索引值`
由于保护模式访存需要的信息比较多，因此需要使用段描述符表。

### 5.3.4 内存分页管理
线性地址，通过`分页机制`，映射到`物理内存地址`
`分页机制`是在`分段机制`之上实现的

线性地址，具体可按位划分为：
页目录项 / 页表项 / 页内偏移值

### 5.3.7 用户申请内存的动态分配
用户调`malloc`，动态申请的内存的`容量`、`大小`由`高层次的C库函数malloc`进行管理，不需要内核插手，因为内核早就为进程分为了CPU的4G线性地址空间分配了64MB空间，只要进程执行寻址时的范围在64MB范围内，内核也同样通过`内存缺页管理机制`分配物理内存并进行映射。
但是内核会为进程使用的代码和数据空间维护一个`当前位置值brk`，这个值存在于每个进程的数据结构中，它指示**进程代码数据在进程地址空间的末端位置**。
当`malloc`为程序分配内存时，触发系统调用`brk()`把程序要求新增长的空间长度通知内核，内核代码根据malloc的信息更新brk的值，但并不立即对新空间映射物理内存页面，而是寻址不到的时候（缺页异常的时候，`触发异常处理程序为指定的页面分配并映射物理内存`）才映射。

当`free()`调用时，C库中的内存管理函数就把释放的内存块标记为空闲，以备程序再次申请内存时使用。
内核为该进程所分配的这个物理页面不会释放，进程退出时内核才回收物理内存。



## 5.4 Linux系统的中断机制
### 5.4.1 中断操作原理
CPU向I/O设备（输入输出设备）提供服务的方式，有一种是轮询方式，CPU轮询系统中的每个设备，但是显然耗费CPU资源，影响系统性能。
另一种是设备向CPU提出`中断请求`，CPU执行完当前一条指令后立刻应答设备的请求，转而执行`中断处理程序/中断服务过程`。
`可编程中断控制器PIC`是微机系统中管理设备中断请求的管理者，它连接到设备的中断请求引脚，检测/接收设备发出的中断服务请求信号。
PIC会对同时收到的中断服务请求进行优先级比较。
PIC向CPU的INT引脚发送`中断信号`时，CPU会停下当前事情，询问PIC需要执行哪个中断服务过程。
CPU根据读取的`中断号`，查询`中断向量表`，取得`中断服务程序的地址`，开始执行它。
执行完了，CPU回到之前的任务。
当然也可以通过`int`指令触发软件中断，只要通过操作数指明中断号。

### 5.4.3 中断向量表
CPU通过`中断号`得到`中断向量值`/`中断服务程序入口地址`
内存中需要有中断向量表（32位保护模式称之为中断描述符表，实模式下，每个中断向量4 Byte，一共256个中断，则向量表长度为1024 Byte）
80X86微机启动时，ROM BIOS中的程序在物理内存0x0000:0x0000初始化（可以通过计算偏移得出某个中断号对应的中断向量）并设置中断向量表，各个中断的默认中断服务程序在BIOS中给出
linux系统除了加载内核时用到BIOS提供的`显示和磁盘读操作`中断功能，在内核正常运行前，在setup.s程序中，重新初始化8259A芯片，并在head.s程序中重新设置中断向量表，抛弃BIOS提供的中断服务功能。

在保护模式下，中断描述符表的信息更多：特权级、描述符类别（linux系统就是运行在80X86下）

### 5.4.4 Linux内核的中断处理
对于内核有两类中断信号（0 ~ 255的一个数字）：
1. 硬件中断
2. 软件中断（异常），是0 ~ 31，intel称之为`异常`，还可以分为`故障fault`、`陷阱traps`
32 ~ 255用户自定义
linux把32~47对应到8259A中断请求号
**把程序发起的`system call`中断设置为`0x80`，系统调用中断是用户程序使用操作系统资源的唯一接口**

### 5.4.5 标志寄存器的中断标志
为了避免 `竞争条件、中断` 对临界代码区（包含临界资源，同一时间只能一个线程执行的代码）的干扰，linux 0.11内核代码使用了`cli`，`sti`
#### `cli`
    复位CPU标志寄存器的中断标志
    系统执行该指令后，不再响应外部中断

#### `sti`
    设置标志寄存器的中断标志
    允许CPU识别并响应外部设备发出的中断

当进入可能引起竞争条件的代码区时，内核中就会使用 cli 指令来关闭对外部中断的响应，
而在执行完竞争代码区时内核就会执行 sti 指令以重新允许 CPU 响应外部中断。

例如，在修改文件超级块的锁定标志和任务进入/退出等待队列操作时都需要首先使用 cli 指令关闭 CPU 对外部中断的响应，在操作完成之后再使用 sti 指令开启对外部中断的响应。
如果不使用 cli、sti 指令对，即在需要修改一个文件超级块时不使用 cli 来关闭对外部中断的响应，那么在修改之前判断出该超级块锁定标志没有置位而想设置这个标志时，若此时正好发生系统时钟中断而切换到其他任务去运行，并且碰巧其他任务也需要修改这个超级块，那么此时这个其他任务会先设置超级块的锁定标志并且对超级块进行修改操作。当系统又切换回原来的任务时，此时该任务不会再去判断锁定标志就会继续执行设置超级块的锁定标志，从而造成两个任务对临界代码区的同时多重操作，引起超级块数据的不一致性，严重时会导致内核系统崩溃。

## 5.5 Linux的系统调用
### 5.5.1 系统调用接口
**syscall是linux内核与上层应用程序交互的唯一接口**
用户直接/间接（库函数）调用`int 0x80`，在EAX寄存器指定系统调用功能号，就可使用内核资源、系统硬件资源
通常应用程序使用标准接口定义的C函数库的函数，间接使用内核的系统调用
```c
printf()                        // 应用程序
// -------
    库函数printf()              // C函数库
        库函数write()
// -------
            系统调用write()     // 内核

```
系统调用通常用函数形式调用，有一个或多个入参，出参为执行结果
错误码会放在全局变量errno中
linux内核中，每个系统调用功能号定义在`include/unistd.h`
`write`系统调用的功能号是4，符号为`_NR_write`
功能号实际上对应`include/linux/sys.h`中定义的 系统调用处理程序指针数组表`sys_call_table[]`中项的索引值
write对应的处理程序指针位于该数组的`项4`
内核中所有系统调用处理函数的名称都是`sys`开头的

### 5.5.2 系统调用处理过程
应用程序通过库函数，向内核发出一个中断`int 0x80`，就开始执行系统调用
其中eax寄存器存放着系统调用号，携带参数可依次存放在`ebx, ecx, edx`（最多三个）
处理系统调用中断`int 0x80`的过程是`kernel/system_call.s`中的`system_call`
内核源码`include/unistd.h`中定义了`宏函数_syscalln()`
如果要传递大块数据给内核，可以传递这块数据的指针值
```c
// read系统调用的定义
int read(int fd, char* buf, int n);

// 用户程序中，对应的系统调用的宏的形式，可以直接执行以下函数，而不通过C函数库作为中介
_syscall3(int, read, int, fd, char* buf, int n);
```
`include/unistd.h`中的每个系统调用宏，都有2 + 2*n 个参数
这个宏会被扩展成`包含内嵌汇编语句`（目的是进入内核中的中断调用处理程序，该程序：先检查eax中的系统调用功能号是否合法，然后根据`sys_call_table[]函数指针表执行相应的系统调用处理程序`）的C函数

### 5.5.3 Linux系统调用的参数传递方式
基于`通用寄存器传递方法`（ebx, ecx, edx）
优点：**当进入系统中断服务程序，保存寄存器值（系统调用触发中断时，CPU切换到内核态，自动将寄存器压入当前进程的内核态堆栈中，CPU硬件自动完成）时，这些传递参数的寄存器也自动放在内核态堆栈上，因此不必专门对传递参数的寄存器进行特殊处理（不必另外通过指令，拷贝寄存器的值）**，是最简单、最快的传参方法

## 5.6 系统时间和定时
### 5.6.1 系统时间
微机系统中有用电池供电的实时钟RT电路，通常，它与保存系统信息的CMOS RAM集成在一个芯片
linux初始化时会读取这块芯片的`当前时间和日期`，并通过函数转换成`UNIX日历时间（从70.1.1 0时到当前的以秒为单位的时间）`，保存在全局变量`startup_time`，可供用户程序调用

`jiffies`，系统启动开始计数的`系统滴答值`（可通过宏来访问），通常是毫秒级别
在修改文件被访问时间，或者i节点被修改时间时，均使用了这个宏

### 5.6.2 系统定时
linux 0.11内核初始化过程中，PC的Intel 8253(4)定时芯片的计数器通道0被设置成运行在方波发生器方式下，`初始计数值LATCH`被设置成：每10ms在通道0输出端OUT发出一个方波上升沿。由于8254芯片的时钟输入频率为1.193180MHz，因此`初始计数值为LATCH = 1193180/100`，意思就是每10ms，这个计数值从11931减到0，每个时钟周期-1。
OUT引脚连接中断控制芯片0级上，所以系统每10ms发送一个时钟中断请求（IRQ0），这个节拍就是操作系统的运行脉搏（`1个系统时钟周期`）。
时钟中断处理程序通过`jiffies`来累计系统启动后的时钟滴答数，后续调C语言的`do_timer`进一步处理，入参为当前代码特权级CPL，该函数实现如下：
1. 如果CPL = 0，表示进程运行在内核态被中断
    内核把进程内核态运行时间统计值 + 1
2. CPL ! = 0
    把进程用户态运行时间统计值 + 1

如果软盘处理程序添加过定时器，那么对定时器链表进行处理，对每个定时器减去1个滴答值：
* 当某个定时器减为0，调该定时器的处理函数，然后对当前进程运行时间的时间片 - 1；
* 如果时间片没用完就退出`do_timer`继续运行当前进程，如果减为0，则程序根据被中断程序的级别确定进一步处理方法：
1. 如果被中断的进程工作在用户态
    `do_timer`调用调度`schedule()`函数，切换到其他进程运行

2. 如果在内核态
    `do_timer`立即退出，因而linux系统的进程在内核态运行时不会被调度程序切换（linux 2.4起，内核空间的进程也会被抢占），是`不可抢占的`

上述定时器专用软盘，类似于现代linux中的动态定时器，仅供内核使用，可以在需要时动态创建，到期时动态撤销
代码见`sched.c 264~336`


## 5.7 Linux进程控制
`分时技术`：时间片轮转（几十ms一个时间片），当前进程时间片耗完，调度程序切换另一个进程执行
`进程`：执行中的程序实例

linux 0.11，最多64个进程，第一个进程是“手工”创建，其他都是基于`fork`系统调用。
内核通过`pid(process ID)`来标识每个进程。
进程之间，代码段、数据区、堆栈区是彼此隔离的。
进程间通信要通过系统调用。
对于单CPU的系统，某一时刻只能有一个进程运行。
一个进程可以在`内核态kernel mode`/`用户态user mode`下执行，分别使用各自独立的内核态堆栈（内核执行函数调用时的信息）和用户态堆栈（进程在用户态临时保存调用函数的参数、局部变量）。
linux内核中的进程通常称为`task`，用户空间的叫`进程`。

### 5.7.1 任务数据结构
内核有进程表，每个进程占据一项。linux中，进程表项是一个`task_struct`任务结构指针（`include/linux/sched.h`），又被称作`进程控制块PCB（Process Control Block）`/`进程描述符OD（Processor Descriptor）`。
其中保存着用于控制和管理进程的所有信息：当前运行状态、信号、进程号、父进程号、累计运行时间、正在使用的文件、本任务的局部描述符、任务状态段信息。
```c
struct task_struct {
/* these are hardcoded - don't touch */
	long state;	                                /* -1 unrunnable, 0 runnable, >0 stopped */
	long counter;                               // 任务运行时间计数，是动态的
	long priority;                              // 优先级，值越大，运行得越久   是counter的初值，为15个滴答
	long signal;                                // 信号，每个比特位表示一种信号
	struct sigaction sigaction[32];             // 保存处理各信号所使用的操作和属性，每一项对应一个信号
	long blocked;	                            // 进程当前不想处理的信号的阻塞位图
/* various fields */
	int exit_code;                              // 退出码，父进程会取得它
    /* 代码段地址，代码长度（byte），代码长度+数据长度， 总长度，堆栈段地址*/
    unsigned long start_code, end_code, end_data, brk, start_stack;
	long pid, father, pgrp, session, leader;    // 进程标识号，父进程号，进程组号，会话号，会话首领
	unsigned short uid, euid, suid;             // 用户标识id，有效用户id，保存的用户id
	unsigned short gid, egid, sgid;             // 组id，有效组id，保存的组id
	long alarm;                                 // 报警定时值   当系统滴答值超过该字段，内核向该进程发送 SIGALRM 信号，默认会终止进程运行
	/* 用户态运行时间，系统态运行时间，子进程用户态运行时间，进程开始运行时刻 */
    long utime, stime, cutime, cstime, start_time;
	unsigned short used_math;                   // 是否使用协处理器
/* file system info */ 
	int tty;		                    /* -1 if no tty, so it must be signed */ // 进程使用tty终端的子设备号，-1表示没有使用
	unsigned short umask;                       // 文件创建 属性屏蔽位
	struct m_inode * pwd;                       // 进程的 当前工作目录i节点结构指针
	struct m_inode * root;                      // （进程自己指定的）根目录 i节点结构指针
	struct m_inode * executable;                // 可执行文件i节点结构指针（系统根据它判断是否还有另一个进程在执行同一个可执行文件）
	unsigned long close_on_exec;                // 执行时关闭文件句柄位图标志（include/fcntl.h）
	struct file * filp[NR_OPEN];                // 文件结构指针表，最多32项，表项就是文件描述符值
/* ldt for this task 0 - zero 1 - cs 2 - ds&ss */
	struct desc_struct ldt[3];                  // 局部描述符表，0：空，1：代码段cs，2：数据段和堆栈段ds&ss
/* tss for this task */
	struct tss_struct tss;                      // 进程的任务状态段信息结构（Task State Segment），保存当前处理器的所有寄存器值
};
```
其中的`unsigned long brk`，是指针值，用于为进程添加和释放动态分配的内存
`malloc`，调用`brk系统调用`，内核去操作`brk指针（program break）`
```
高地址
        kernel（映射到进程虚拟地址空间，但是进程不可直接访问）
        栈区
brk ->
        堆区（向高地址延伸）
        BSS，未初始化数据
        初始化数据区
        TEXT
低地址  
```
进程的上下文：**CPU所有寄存器的值、进程的状态、堆栈中的内容**，切换进程的时候，需要进行保存
发生中断时，内核在被中断进程的上下文中，在内核态下，执行中断服务例程，当然会保存需要的资源，以便中断服务结束时能恢复被中断进程的执行



### 5.7.2 进程运行状态
`state`
* TASK_RUNNING
    正在被CPU执行，或者已就绪、但尚未被调度
    具体分为`用户运行态`、`内核运行态`、`就绪态`（进程刚创建的状态）
* TASK_INTERRUPTIBLE        `可中断`睡眠状态
    可被信号唤醒
    系统不会直接就调度该类型的进程，而是当系统产生中断（中断处理程序可能会通知该进程等待的资源到了），或者释放了进程正在等待的资源，或者进程收到一个信号（外部信号打断它的睡眠），都可以唤醒它，切换到`就绪态`
* TASK_UNINTERRUPTIBLE      `不可中断`睡眠状态
    不会因为收到信号而被唤醒
    只有使用`wake_up()`明确地唤醒时，才会转换到可运行的就绪状态
    通常用于进程需要不受干扰地等待或者所等待的事件很快发生时使用
* TASK_STOPPED
    进程收到以下信号时，进入暂停状态
    `SIGSTOP`, `SIGTSTP`, `SIGTTIN`, `SIGTTOU`
    当发送`SIGCONT`信号时，进程转换到可运行状态
    linux0.11中将该状态的进程视作终止来处理

* TASK_ZOMBIE
    进程已停止运行，但是父进程还没调`wait()`获取其状态（因此相关的任务数据结构需要保留），则该进程处理ZOMBIE状态
    当父进程通过`wait()`获取子进程信息后，任务数据结构会被释放

如果进程在`内核态`执行时，需要等待系统的某个资源，该进程会调用`sleep_on()`/`interruptible_sleep_on()`自愿放弃CPU使用权，让调度程序去执行其他的进程，进程进入上述睡眠状态（两种都有）
只有当进程从`内核运行态`转换到`睡眠状态`，内核才进行`进程切换操作`
在内核态下进程的进程不能被其他进程抢占，而且一个进程无法改变另一个进程的状态
内核在`执行临界区代码`时，会`禁止一切中断`，为了避免进程切换时，造成内核数据错误

### 5.7.3 进程初始化



## 5.8 Linux系统中堆栈的使用方法


## 5.9 Linux 0.11采用的文件系统


## 5.10 Linux内核源代码的目录结构



## 5.11 内核系统与应用程序的关系





# 第6章 引导启动程序
























