V3.0

# 序言
最有限的篇幅，解剖Linux内核，以理解基本功能和实际实现
选用Linux早期内核版本，因为精简，要素齐全
但不支持虚拟文件系统、网络系统、仅支持a.out执行文件，其他复杂系统可以在当前这些基础学好了之后再去学
RTFSC(Read The Fucking Source Code!)
需要注重实践，比如I/O的代码会比调度算法的代码多得多
作者选择了0.11版内核，不超过2万行代码
对应的文件系统是最简单的MINIX 1.0文件系统，而非Ext2/Ext3文件系统。

# 第1章 概述
## 1.1 诞生和发展
类UNIX系统
Linux的发展依赖五个要素：
1. UNIX操作系统（1969，美国贝尔实验室）
2. MINIX操作系统（教学用途，也是模仿UNIX的）
3. GNU计划（提供了bash shell等GNU软件环境）
4. POSIX标准
5. 因特网

### 1.1.3 GNU计划
自由软件项目，旨在开发一个自由软件类UNIX系统，现在的基于Linux内核的GNU操作系统准确来说应该被称为GNU/Linux系统）
GNU项目同时也开发出了：bash shell，gcc，gdb。它们为Linux操作系统的开发创造了一个合适的环境。

### 1.1.4 POSIX标准
由IEEE，ISO/IEC开发的标准，基于UNIX实践和经验，描述了操作系统的调用服务接口。保证应用的源代码在多种操作系统的移植和运行。
起源是一个UNIX用户组（user/group）的早期工作，它试图将AT&T的System V操作系统和Berkley CSRG的BSP操作系统的调用接口之间的区别重新组织集成。
内容包括：系统服务应用程序编程接口（API）（POSIX.1），命令与工具标准（POSIX.2），测试方法标准（POSIX.3），实时API（POSIX.4）。
该标准指导了Linux的开发。

### 1.1.5 Linux操作系统的诞生
80年代的操作系统都太贵
91年，GNU C编译器已开发，Linux研究MINUX、Intel 386体系结构，研究终端仿真程序和硬件驱动程序。
“理论毕竟是理论，省略的部分虽然没理论含量，但却是系统的必要组成部分”

### 1.1.6 Linux操作系统版本的变迁
V0.1版本，已经可以使用GNU gcc编译内核，支持加载/卸载文件系统。

## 1.2 内容综述
发布时包括以下文件：
1. bootimage.Z  具有美国键盘代码的压缩启动映像文件
2. rootimage.Z  根文件系统映像文件
3. 内核源代码文件（94KB）
4. 二进制执行文件，16位的汇编程序和装入程序
5. 更新安装信息文件

`bootimage.Z`是引导启动Image文件，包括：`磁盘引导扇区代码`、`操作系统加载程序` 和 `内核执行代码`。
PC启动时，ROM BIOS中的程序把默认启动驱动器上的`引导扇区代码`和`数据`读入内存，然后`引导扇区代码`负责把`操作系统加载程序`和`内核执行代码`读入内存中，然后控制权交给`操作系统加载程序`，它进一步准备内核的初始化操作，最终，加载程序把控制权交给内核代码。
`内核代码`如果要正常运行就要`文件系统`的支持。`rootimage`就是用于向内核提供最基本支持的`根文件系统`（包括操作系统最起码的一些配置文件和命令执行程序）。

0.11版本，尚不包括专门的进程等待队列，或者TCP/IP等内容
本书后续对代码的说明是以内核中源代码的组成结构来进行的，后续代码中会出现C语言内嵌汇编代码

## 第二章 微型计算机组成结构
计算机系统，简单来看，分为四部分：
能源、输入部分、处理中心、输出部分

## 2.1 微机组成原理
CPU通过`地址线`、`数据线`、`控制信号线`组成的内部总线和系统的其他部分进行数据通信。
`地址线`用于提供内存或I/O设备的地址，即指明需要读/写数据的具体位置。
`数据线`用于在CPU和内存或I/O设备之间提供数据传输的通道。
`控制线`则负责指挥执行的具体读/写操作。
对于80386 CPU的PC机，地址线和数据线都有32根，即都是32位。地址寻址空间就是2^32字节：0~4GB。
控制器和存储器接口通常都集成在计算机主板，这些控制器都是以一块大规模集成电路芯片为主组成的功能电路。
例如，`中断控制器`由 Intel 8259A 或其兼容芯片构成；
`DMA控制器`通常采用Intel 8237A芯片构成；
`定时计数器`的核心则是Intel 8253/8254定时芯片；
`键盘控制器`使用的是Intel 8042芯片来与键盘中的扫描电路进行通信。
各种控制卡（或者称为适配器，串行口控制卡、硬盘控制卡）则是通过`扩展插槽`与主板上系统总线连接。
`总线插槽`是系统地址总线、数据总线和控制线的与扩展设备控制器的`标准连接接口`。
这些总线皆苦标准通常有工业标准总线（ISA）等各种总线。随着计算机硬件的发展，传输速率更高、控制更灵活的总线接口在不断地推出，例如采用串行通信点对点技术的高速`PCIE`总线。

随着计算机技术的发展，很多原来使用控制卡来完成的功能（例如`硬盘控制器`功能）都已经`集成`在计算机主机板上少数几个超大规模集成电路芯片中，几个甚至是一个这样的芯片就确定了主机板的主要特性和功能，并且为了让系统的不同部分都能达到其最高传输速率，总线结构也发生了很大变化。
除了CPU以外，现代PC机主板主要使用2个**超大规模芯片**构成的芯片组或芯片集（Chipsets）组成：`北桥`（Northbridge）芯片和`南桥`（Southbridge）芯片。`北桥`芯片用于与`CPU、内存和AGP视频接口`，这些接口具有很高的传输速率。北桥芯片还起着存储器控制作用。
`南桥`芯片用来管理`低、中速的组件`，例如， `PCI总线、IDE硬盘接口、USB端口`等。
之所以用“南、 北”桥来分别统称这两个芯片，是由于在Intel公司公布的典型PC机主板上，它们分别位于主版的下端和上端（即地图上的南部和北部）位置，并起着与CPU进行通道桥接的作用。

## 2.2 I/O端口寻址和控制访问方式
### 2.2.1 I/O端口和寻址
CPU为了访问I/O接口控制器或控制卡上的数据和状态信息，需要首先指定它们的`地址`。
这种地址就称为I/O端口地址或者简称`端口`。
通常一个I/O控制器包含访问数据的`数据端口`、输出命令的`命令端`口和访问控制器执行状态的`状态端口`。
端口地址的设置方法一般有两种：`统一编址`和`独立编址`。（区别就是是否直接占用常规的内存地址空间，统一编址的好处是简化指令，可以直接使用常规的指令，而独立编址需要使用专门的I/O指令来访问端口）
**端口统一编址**的原理是把I/O控制器中的端口地址归入存储器寻址地址空间范围内。因此这种编址方式也成为`存储器映像编址`。
**CPU访问一个端口的操作与访问内存的操作一样，也使用访问内存的指令**。
**端口独立编址**的方法是把I/O控制器和控制卡的寻址空间单独作为一个独立的地址空间对待，称为I/O地址空间。
每个端口有一个I/O地址与之对应，并且使用专门的I/O指令来访问端口。
`IBM PC 及其兼容微机`主要使用`独立编址`方式，采用了一个独立的I/O地址空间对控制设备中的寄存器进行寻址和访问。使用ISA总线结构的传统PC机其I/O地址空间范围是0x000——0x3FF，有1024个I/O端口地址可供使用。各个控制器和控制卡所默认分配使用的端口地址范围见表2—1所示。关于这些端口的使用和编程方法将在后面具体涉及相关硬件时再详细进行说明。
另外，IBMPC机也部分地使用了`统一编址`方式。例如，CGA显示卡上显示内存的地址就直接占用了存储器地址空间0xB800——0xBC00范围。因此若要让一个字符显示在屏幕上，可以直接使用内存操作指令往这个内存区域执行写操作。

### 2.2.2 接口访问控制
I/O接口数据传输控制方式一般有`程序循环查询方式`、`中断处理方式`、`DMA传输方式`。
`轮询`一般用于多任务操作系统中，等待时间极短或者是必须使用的场景。
`中断`，需要中断控制器的支持：只有当I/O设备通过中断向CPU提出处理请求时，CPU才会暂时中断当前执行的程序转而去执行相应的I/O中断处理服务程序。
CPU使用中断向量表来寻址和中断类型相应的中断服务程序的入口地址。
`DMA(Direct Memory Access)`用于I/O设备与系统内存之间进行**批量数据传送**，无需CPU进行。

## 2.3 主存、BIOS和CMOS存储器
### 2.3.1 主存
为了兼容，系统1MB以下的物理内存分配与原来的老的架构一致，而BIOS处于ROM中CPU能寻址的内存最高的位置。
当计算机上电初始化时，`物理内存`被设置成从地址0开始的连续区域。除了地址从`0xA0000`到`0xFFFFF`（640K到1M共384K）和`0XFFFE0000`到`0XFFFFFFFF`(4G处的最后一64K)范围以外的所有内存都可以用作系统内存。
这两个特定范围被用于`I/O设备`和`BIOS程序`。
假如我们的计算机中有`16MB`的物理内存，那么在Linux 0.1x系统中，`0-640K`将被用作存放`内核代码`和`数据`。
Linux内核不使用BIOS功能，也不使用BIOS设置的中断向量表。`640K-1M`之间的384K仍然保留用作BIOS数据区和中断向量表。其中地址 `0xA0000`开始的128K用作`显示内存缓冲区`，随后部分用于`其他控制卡的ROM BIOS`或`其映射区域`，而`0xF0000`到`1M`范围用于高端系统`ROM BIOS`的映射区。`1M ~ 16M`将被内核用于作为可分配的主内存区。另外高速缓冲区和内存虚拟盘也会占用内核代码和数据后面的一部分内存区域，该区域通常会跨越640K——1M的区域。

### 2.3.2 基本输入输出程序 BIOS
存放在ROM中的系统`BIOS程序`主要用于计算机开机时执行系统各部分的`自检`，建立起操作系统需要使用的`各种配置表`，例如`中断向量表`、`硬盘参数表`。
并且把处理器和系统其余部分`初始化`到一个已知状态，而且还为DOS等操作系统提供硬件设备接口服务。
但是由于BIOS提供的这些服务不具备可重入性（即其中程序不可并发运行），并且从访问效率方面考虑，因此**除了在初始化时会利用BIOS提供一些系统参数以外，Linux操作系统在运行时并不使用BIOS中的功能**。
当计算机系统上电开机或者按了机箱上的复位按钮时，CPU会自动把`代码段寄存器CS`设置为`0xF000`，其`段基地址`则被设置为`0xFFFF0000`，`段长度`设置为`64KB`（是实模式的限制，程序/数据不能超过64KB，只能访问段基址开始的64KB）。
而`IP`（偏移）被设置为`0xFFF0`，因此此时CPU代码指针指向`0xFFFFFFF0`处，即4G空间最后一个64K的最后16字节处，这里正是`系统ROM BIOS`存放的位置。并且BIOS会在这里存放一条`跳转指令JMP`跳转到BIOS代码中64KB范围内的某一条指令开始执行。
（！！！传统的16位实模式只能访问第一个1MB地址空间，因为地址总线20位，对应只支持1M范围的寻址，对于64KB以外的代码或者数据是通过切换段基址来访问的）
由于目前PC/AT微机中BIOS容量大多有1MB到2MB，并存储在闪存（Flash Memory，断电不丢失）ROM中，因此为了能够执行或访问BIOS中超过64KB范围并且又远远不在0~1M地址空间中的其他BIOS代码或数据，BIOS程序会首先使用一种称为`32位大模式（Big Mode）`技术把`数据段寄存器`的访问范围设置成4G（而非原来的64K），这样就可以在0到4G范围内执行和操作数据。
此后，BIOS在执行了一些列硬件检测和初始化操作之后，就会把与原来PC机兼容的`64KB BIOS代码和数据`复制到内存低端1M末端的64K处，然后跳转到这个地方并且让CPU进入真正的`实地址模式`工作（临时进行保护模式，最后再回到实地址模式）。最后BIOS就会从硬盘或其他块设备把操作系统引导程序加载到`内存0x7c00`处（留出前面的空间给BIOS使用），并跳转到这个地方继续执行引导程序。

### 2.3.3 CMOS存储器
在PC/AT机中，除需要使用内存和ROM BIOS以外，还使用只有`很少存储容量`的（只有64或128字节）CMOS（Complementary Metal Oxide Semiconductor，互补金属氧化物半导体）存储器来存放计算机的 `实时时钟信息`和`系统硬件配置信息`。
这部分内存通常和`实时时钟芯片（Real Time Chip）`做在一块集成块中。
CMOS内存的地址空间在基本内存地址空间之外，需要使用`I/O指令`来访问。

## 2.4 控制器和控制卡
### 2.4.1 中断控制器
IBM PC/AT 80X86兼容微机使用`两片级联`的`8259A可编程中断控制芯片`组成一个`中断控制器`，用于实现I/O设备的中断控制数据存取方式，并且能为15个设备提供独立的中断控制功能，见图2—6所示。

在计算机刚开机初始化期间，ROM BIOS会分别对两片8259A芯片进行初始化，并分别把`15级中断优先级`分配给`时钟定时器`、`键盘`、`串行口`、`打印口`、`软盘控制`、`协处理器`和`硬盘`等设备或控制器使用。
同时在内存开始`处0x000~0xFFF`区域内建立一个`中断向量表`。
但是由于这些设置违背了Intel公司的要求（后面章节将会详细说明），因此Linux操作系统在内核初始化期间又重新对8259A进行了设置。
有关中断控制器工作原理和编程方法的详细说明请参见后续章节。

PC上电开机后，ROM BIOS会设置硬件中断请求号，但是Linux系统不直接使用它们，而是在系统初始化时重新设置：`<中断请求号, 中断向量号>`。

### 2.4.2 DMA控制器
主要功能：让`外设`直接与`内存`传输数据。
对DMA控制器进行编程，可以让外设和内存的数据传输不受CPU控制，因此CPU可以在数据传输的时候，做其他事情。

### 2.4.3 定时/计数器
Intel 8253/8254，可编程定时/计数器芯片，处理计算机中的精确时间延迟。
程序员可以配置8253使用其中的一个计数器通道达到所期望的延时，当延时到达后，该芯片会向CPU发送一个中断信号。
3个通道分别用作：
1. 日时钟计时中断信号
2. 动态内存DRAM刷新定时电路
3. 主机扬声器
Linux 0.11只使用了通道0：工作在方式3，每隔10ms，发送一个信号，产生中断请求信号（IRQ0），用于内核工作的脉搏：定时切换当前执行的任务和统计每隔任务使用的系统资源量（时间）

### 2.4.4 键盘控制器
扫描、案件状态信息：扫描码

### 2.4.5 串行控制卡
1. 异步串行通信原理
帧：为了传送一个有效数据长度单位的格式
为了通信双方`确定收发顺序`和`进行一些错误检测操作`，需要基于`协议`设计一些其他信息：同步和错误检测信息。
结构如下：
起始同步信息 + payload + 校验等信息

`串行通信`：以比特位数据流一次一个比特进行传输
分为`异步`和`同步`
区别在于传输时`同步的通信单位`或`帧长度`不同
`异步串行通信`以一个字符作为一帧    相当于说话的时候，一个字一个字地蹦，每个字说完停顿任意长时间
`同步串行通信`以多个字符或字节组成的序列，作为一帧  相当于一次说一句话
这其实是一种习惯上的划分，因为当传输单位缩小到一个位，那么以一个字符进行传输的异步通信，也可以看作同步传输通信

2. 异步串行传输格式
一个字符帧包含：
起始位（0）、数据位、奇偶校验位、停止位（1）
数据位用于表示一个字符，5~8 bit

3. 串行控制器
PC机通常有2个符合RS-232C标准的串行接口，使用UART（通用异步接收/发送器控制芯片）组成的串行控制器来处理串行数据的收发

软盘驱动器被U盘存储器取代


# 第三章 内核编程语言和环境
## 3.1 as86汇编器
0.1x系统有两种汇编器：
1. 产生16位代码的`as86汇编器`，使用配套的`ld86链接器`
    linux只用它来创建16位的启动引导扇区程序boot/bootsect.s，以及 实模式下初始设置程序boot/setup.s的二进制执行代码
    快速小巧，比GNU gas多了宏定义，和更多的错误检测
    语法不兼容GNU gas，类似微软的MASM等语法，基于Intel
2. GNU的汇编器`gas`，使用`GNU ld链接器`来链接产生的目标文件

### 3.1.1 as86汇编语言语法
输入 低级汇编语言程序，输出含机器码的二进制程序 / 目标文件
```sh
as [选项] -o objfile srcfile
```
汇编器编译出的目标文件，通常包含三个段：`.text`（正文段，代码和只读数据） `.data`（数据段，已初始化过的可读可写数据） `bss`（未初始化数据段） 
对于`bss`，目标文件不会保留空间，在链接成可执行文件，并被操作系统加载时，将该段的内容全初始化为0

### 3.1.2 as86汇编语言程序
bootsect.s的框架程序，是引导扇区启动程序
编译链接产生的执行程序可以放入软盘中的第1个扇区，用来引导计算机启动
业务逻辑：在屏幕17行，第5列显示红色字符串：“Loading system...”，光标下移1行，然后程序在27行死循环

```sh
! boot.s    ! 表示注释
.globl begtext, begdata, begbss, endtext, enddata, endbss   ! 全局标识符，供ld86链接使用
.text       ! 正文段
begtext:
.data       ! 数据段
begdata:
.bss        ! 未初始化数据段
begbss:
.text       ! 正文段
BOOTSEG  = 0x07c0			! BIOS加载bootsect代码的原始段地址

entry _start
_start:
    ! 设置字符显示在屏幕，是基于中断来实现的，一顿MOV，然后 INT 0x10
# ......
.org 510    ! 以后语句从地址510处开始存放

# ......
```


### 3.1.3 编译和链接
```sh
# 编译，生成目标文件

# 链接，并去掉符号信息，链接一些库？

# 将可执行文件写入软盘或者镜像盘文件,需要手动去掉前32个字节(可执行文件头)   这是基于dd命令来做的，dd命令专门用于数据转储/复制文件

```

### 3.1.4 as86和ld86使用方法和选项



## 3.2 GNU as汇编
内核中的汇编是使用gas来编译的，和C产生的模块进行链接

出于执行效率的考虑，关键部分会使用汇编（整个系统里大约包含10%）

编译C程序时，`GNU gcc编译器`会首先输出一个作为`中间结果`的as汇编语言文件，然后gcc调用`as汇编器`临时汇编程序编译成目标文件
as汇编器最初是专门用于汇编gcc产生的中间汇编程序

as输出由汇编语言程序编译（确实是编译，因为除了把助记符号改成机器码，还要处理如标签符号-->地址的解析，甚至处理重定位信息）而成的`二进制目标文件`，名为a.out，后续作为`链接器ld`的输入

### 3.2.2 as汇编语法
```sh
标号：指令助记符 操作符1, 操作符2

```

### 3.2.4 section（区）与重定位
section表示一个地址范围，用于表示 `目标文件/可执行文件` 中不同的信息区域：`正文区` / `数据区` / `bss区`（实际上也是按照这个顺序）（另外还有绝对地址区域）
目标文件中的区的长度和字节序是固定的
`为 区 分配运行时地址`的操作就是`重定位`，汇编器会写入必要的重定位信息

## 3.3 C语言程序
预处理、编译（生成汇编代码）、汇编（转成机器指令）、链接

### 3.3.2 嵌入汇编
```cpp
// 一般嵌入在宏定义内
asm(
    "汇编语句"
    : 输出寄存器
    : 输入寄存器
    : 会被修改的寄存器);

// 实际示例
```

### 3.3.4 寄存器变量
允许把一些变量放到CPU寄存器，即`寄存器变量`，从而避免访存
有两种：`全局寄存器变量`（程序运行中，一直存储全局变量），`局部寄存器变量`（存储内嵌asm汇编语句中操作数）

### 3.3.5 内联函数
避免函数调用栈的开销

## 3.4 C与汇编 相互调用
### 3.4.1 C函数调用机制
linux内核程序`boot/head.s`执行完基本初始化操作后，跳转去执行`init/main.c`   执行控制如何转交？

`函数调用`的本质：代码块1 到 代码块2 的双向数据传递，执行控制转移
数据传递是基于`函数参数`，`返回值`
进入函数时，为局部变量分配存储空间，退出时回收（基于栈操作）

#### 3.4.1.1 栈帧结构 控制转移权方式
大多CPU上的程序基于`栈`来支持`函数调用`
`栈帧`是指单个函数调用操作使用的内存结构（栈帧的两端由两个指针指定：`ebp`用作`帧指针`，`esp`用作`栈指针`（随着出入栈移动））
（栈是往低地址延伸，栈顶在低地址）
基于程序的栈内存空间，以及 一些寄存器

`CALL`：把返回地址(程序中，CALL的吓一跳指令的地址)，压入栈中，并且跳转被调用函数
`RET`：弹出栈顶处的地址，并跳转到该地址

```c
void swap(int* a, int *b) {
    int c;
    // ...
}

int main() {
    int a, b;
    a = 16, b = 32;
    swap(&a, &b);
    return (a - b);
}
```

```sh
# 从上到下，地址减小，调用者的栈帧之后，才是当前栈帧
保存的ebp   # main函数的栈帧（栈底）
a
b
&b
&a
返回地址    # main函数的栈顶（是调用swap最开始，先压入栈中的，算作是main函数栈帧的结束位置）
保存的ebp   # swap 栈帧（栈底） ———— ebp寄存器
c          # swap 栈顶        ———— esp寄存器
```
从汇编层面看，函数代码中，必然先保存EBP的值（`pushl %ebp`）
通过操作栈顶指针，来增加栈空间（或者说给实参分配空间）
然后函数实参压栈（从右往左，先压入第二个）
执行业务逻辑
然后恢复寄存器
返回

总结：
1. 设置
    初始化栈帧结构
2. 主体
    函数业务逻辑
3. 结束
    恢复栈状态，从函数返回
```sh
movl %ebp, %esp # esp = ebp
popl %ebp       # 恢复基址指针
```

#### 3.4.1.3 main()也是一个函数
main()在编译链接时，会作为`ctr0.s`（c run-time）汇编程序的函数被调用，该程序是一个stub程序
```sh
.text
.global _environ            # 声明全局变量

_entry:                     # 代码入口标号
    movl 8(%ebp), %eax      # 取程序的环境变量指针envp并保存在_environ
    movl %eax, _environ     # execve()调用时，设置envp
    call _main              # 调用主程序，返回值状态在eax中
    pushl %eax              # 压入返回值作为exit()函数的参数
    call _exit
    jmp lb                  # 正常不会调到这里

.data
_environ:                   # 定义变量，分配长字空间
    .long 0
```

编译程序的时候，stub模块也会一并参与链接
PS：
##### `ELF格式`：
ELF header（类型：是exe / .o / .so，体系结构，入口点地址）
Program header table（说明每个段由什么组成）
section header table（包含所有section的信息，一个节可能用作.text，.data，.bss）
sections（如.text .rodata .data .bss）
symbol tables（动态 / 静态符号表，记录函数/变量名及其在文件中的位置）
relocation tables（用于链接器处理.so）
dynamic section（提供动态加载的必要信息）

在C++中，gcc编译器会提供main()之前的`启动模块`，执行全局构造/全局析构，并且调main之前还会调.init的代码

### 3.4.2 在汇编程序中调用C函数

### 3.4.3 在C程序中调用汇编函数

## 3.5 Linux 0.11目标文件格式
linux 0.11使用`2种编译器`来生成内核代码文件
1. 汇编器as86、ld86
2. GNU 汇编器gas，C语言编译器gcc，链接器gld

### 3.5.1 目标文件格式
GNU gas, gcc输出的目标文件, 可执行文件都是基于传统UNIX的a.out格式（对于具有内存分页机制的系统，它简单有效，因为文件里包含一些绝对地址，对于分页系统而言，进程的独立地址空间是虚拟的，进程A和虚拟地址和进程B的相同虚拟地址永远不会冲突）。
PS：分页机制的意思就是：针对`虚拟地址`和`物理地址`，以固定大小（页）进行划分，通过页表建立映射关系
```
a.out文件头
text section    正文段
data section    已初始化数据区
text relocation
data relocation
symbol table    符号表
string table    字符串表
```
**可执行文件 和 进程逻辑地址空间 存在映射关系**
可执行文件-text --> 进程地址空间-text
可执行文件-data --> 进程地址空间-data
可执行文件中的header用于确定进程地址空间中的bss(未初始化数据区，可执行文件中也有类似的bss，但是相关的元数据在data中。这样的话，有的数据可以在可执行文件中精简表示，而在运行时的进程内存空间中再恢复出来，一般是全局变量和静态变量), data, text中的长度

linux 0.11的进程逻辑大小空间是64MB
**需求页**技术
在一页代码实际要用时，才加载到物理内存
`fs/execve()`函数，只是设置`分页机制的页目录项和页表项`，没有真正加载所有代码

### 3.5.3 链接程序输出
链接程序在链接若干二进制文件时，首要任务是：
给二进制文件分配存储空间，从而才可以执行`符号绑定、代码修正（填写真实地址）`，因为那些模块文件中的符号和文件中的存储位置有关，所以符号对应位置不确定，则无法解析符号

链接程序会把每个模块文件中**相同类型的段**进行组合（至少代码段显然要组合）

可执行文件的内部中，代码块的空间会按照页边界对齐，对于不足一页的会进行填充，然后才是数据段

#### 加载可执行文件的过程
（可能就是`execve`系统调用的内部流程）
根据头部信息MAGIC NUM判断是否合格
然后系统在`用户态堆栈顶部`，设置环境变量、命令行参数，并构建相应的任务数据结构（是`task_struct`吗？）。
接着，设置相关寄存器值，利用堆栈返回技术（中断返回指令？iret？实现内核态 -> 用户态）去执行程序。
执行程序映像文件中的代码和数据将会在实际需要时动态加载到内存。
（进程的内存空间有一段高地址是留给内核空间）

其实编译出的内核镜像，是不需要ELF执行头的，因为内核是由引导启动程序利用ROM BIOS中断调用加载到内存的。
实际上，现代系统镜像还是会有个给引导程序读取的头，而且也不只是BIOS中断就够了。

### 3.5.5 System.map文件
链接时，加`-M`选项，或者`nm`命令，则会在屏幕打印链接映像（link map）信息：由链接程序产生的目标程序内存地址映像信息，用于表明：
1. 目标文件-符号信息 映射到内存中的位置
2. 公共符号如何放置
3. 链接中包含所有的文件成员以及引用的符号

通过符号表，可以得知地址值对应的变量名



# 第四章 80X86 保护模式及其编程
80X86

### 4.1.1 标志寄存器

### 4.1.2 内存管理寄存器

### 4.2.2 地址变换

## 4.3 分段机制

## 4.4 分页机制



# 第五章 Linux内核体系结构
本章用于对内核源代码的总结概述
需要注意下80X86保护模式运行方式

一个完整的操作系统主要由4部分：硬件、**操作系统内核**（对硬件资源的抽象和访问调度）、操作系统服务（向用户提供服务，这些服务被看作是操作系统部分功能，如shell解释系统，内核编程接口等系统程序）、用户应用程序

linux内核，主要是为了**与计算机硬件进行交互，为应用提供高级执行环境、对硬件的虚拟接口**

## 5.1 Linux内核模式
操作系统内核一般有`宏内核`（操作系统的核心功能都在内核空间） / `微内核`（内核只保留基本功能）
linux 0.11是宏内核（内核代码结构紧凑，执行快，但是层次结构性不强）
宏内核操作系统提供服务的流程：
应用程序基于指定参数执行`系统调用`（`int x80`）
    CPU从`用户态`切换到`内核态`
    OS调用特定的`系统调用服务程序`，会涉及到更底层的支持函数
    完成调用后，OS使CPU从`内核态`切换为`用户态`（回到应用继续执行后面的指令）

## 5.2 Linux内核系统体系结构
五大模块:
1. 进程调度模块（被其他模块依赖，比如写磁盘时，进程被挂起）
2. 内存管理模块
3. 文件系统模块（并非虚拟文件系统，虚拟机文件系统要到0.95才实现）
4. 进程间通信模块
5. 网络接口模块（要到0.96才实现）

## 5.3 Linux内核对内存的管理和使用
### 5.3.1 物理内存
系统初始化时对物理内存进行划分。
低地址到高地址分别是：
内核模块、高速缓存区{ 显存、BIOS ROM }、虚拟盘、主内存区。
进程读取块设备中的数据时，系统先把数据读到高速缓存区，进程要写数据也是先写到高速缓存区，后续由块设备驱动程序再写到相应的设备上。

80X86 CPU，对地址管理同时有`分段`和`分页`的策略

### 5.3.2 内存地址空间概念
有3种地址来回变换
1. 进程的虚拟和逻辑地址
2. CPU的线性地址
3. 实际物理内存地址

虚拟地址：
    `段选择符:段内偏移地址`
    由`段选择符`（查 GDT, Global Discriptor Table，每个CPU一个 / LDT, Local Discriptor Table） + `段内偏移地址`组成，经过映射变成物理地址
逻辑地址：
    程序产生的、与段有关的`偏移地址部分`（只管偏移部分即可）
    在intel保护模式下，就是程序执行代码段限长内的偏移地址（假定代码段、数据段完全一样）
    应用程序开发者，只和逻辑地址打交道，感知不到分段、分页
线性地址：
    虚拟地址到物理地址的中间层，是处理器可寻址的内存空间中的地址
    如果启用分页机制，线性地址 变换为 物理地址（这里的变换，具体是指线性地址再一步拆解：页目录索引、页表索引、页内偏移，通过多级页表映射到实际的物理地址）
      不启用分页机制，线性地址 就是 物理地址

虚拟存储：
    呈现出比实际内存大的多的内存量
    linux 0.11，每个进程划分了`64MB`的虚拟存储空间

### 5.3.3 内存分段机制
`虚拟地址（段选择符：偏移值/逻辑地址）` 通过`分段机制` 映射到中间层的4GB（2^32）`线性地址空间`中。
当程序引用一个内存地址时，`相应的段基址` + 程序员可见的`逻辑地址` = `线性地址`
CPU进行地址变换的**缺页加载机制**：（mm/memory.c）
    要先通过缺页中断，把引起中断的线性地址放到`CR2寄存器`
    后续把进程要求的页面，从磁盘加载到物理内存
    如果物理内存占满，则把磁盘的一部分作为`swapper`缓冲区，把内存中暂时不用的页面搁置。

Intel CPU使用`段`的概念，来对程序进行寻址。
每个`段`，定义了内存中的某个区域以及访问的优先级。
CPU在`实模式`和`保护模式`下寻址方式不同。

**实模式**（实模式没有虚拟内存的设定）
内存寻址是基于`段`，`偏移值`。`段`放在`段寄存器`，段长固定64KB，段内偏移地址存放在任意一个可用于寻址的寄存器中。

**保护模式**（可通过开启分页机制，开启虚拟内存）
`段寄存器`存放的是`一个 段描述符表 中，某一描述符项在表中的索引值`
由于保护模式访存需要的信息比较多，因此需要使用段描述符表。

### 5.3.4 内存分页管理
线性地址，通过`分页机制`，映射到`物理内存地址`
`分页机制`是在`分段机制`之上实现的

线性地址，具体可按位划分为：
页目录项 / 页表项 / 页内偏移值

### 5.3.7 用户申请内存的动态分配
用户调`malloc`，动态申请的内存的`容量`、`大小`由`高层次的C库函数malloc`进行管理，不需要内核插手，因为内核早就为进程分为了CPU的4G线性地址空间分配了64MB空间，只要进程执行寻址时的范围在64MB范围内，内核也同样通过`内存缺页管理机制`分配物理内存并进行映射。
但是内核会为进程使用的代码和数据空间维护一个`当前位置值brk`，这个值存在于每个进程的数据结构中，它指示**进程代码数据在进程地址空间的末端位置**。
当`malloc`为程序分配内存时，触发系统调用`brk()`把程序要求新增长的空间长度通知内核，内核代码根据malloc的信息更新brk的值，但并不立即对新空间映射物理内存页面，而是寻址不到的时候（缺页异常的时候，`触发异常处理程序为指定的页面分配并映射物理内存`）才映射。

当`free()`调用时，C库中的内存管理函数就把释放的内存块标记为空闲，以备程序再次申请内存时使用。
内核为该进程所分配的这个物理页面不会释放，进程退出时内核才回收物理内存。



## 5.4 Linux系统的中断机制
### 5.4.1 中断操作原理
CPU向I/O设备（输入输出设备）提供服务的方式，有一种是轮询方式，CPU轮询系统中的每个设备，但是显然耗费CPU资源，影响系统性能。
另一种是设备向CPU提出`中断请求`，CPU执行完当前一条指令后立刻应答设备的请求，转而执行`中断处理程序/中断服务过程`。
`可编程中断控制器PIC`是微机系统中管理设备中断请求的管理者，它连接到设备的中断请求引脚，检测/接收设备发出的中断服务请求信号。
PIC会对同时收到的中断服务请求进行优先级比较。
PIC向CPU的INT引脚发送`中断信号`时，CPU会停下当前事情，询问PIC需要执行哪个中断服务过程。
CPU根据读取的`中断号`，查询`中断向量表`，取得`中断服务程序的地址`，开始执行它。
执行完了，CPU回到之前的任务。
当然也可以通过`int`指令触发软件中断，只要通过操作数指明中断号。

### 5.4.3 中断向量表
CPU通过`中断号`得到`中断向量值`/`中断服务程序入口地址`
内存中需要有中断向量表（32位保护模式称之为中断描述符表，实模式下，每个中断向量4 Byte，一共256个中断，则向量表长度为1024 Byte）
80X86微机启动时，ROM BIOS中的程序在物理内存0x0000:0x0000初始化（可以通过计算偏移得出某个中断号对应的中断向量）并设置中断向量表，各个中断的默认中断服务程序在BIOS中给出
linux系统除了加载内核时用到BIOS提供的`显示和磁盘读操作`中断功能，在内核正常运行前，在setup.s程序中，重新初始化8259A芯片，并在head.s程序中重新设置中断向量表，抛弃BIOS提供的中断服务功能。

在保护模式下，中断描述符表的信息更多：特权级、描述符类别（linux系统就是运行在80X86下）

### 5.4.4 Linux内核的中断处理
对于内核有两类中断信号（0 ~ 255的一个数字）：
1. 硬件中断
2. 软件中断（异常），是0 ~ 31，intel称之为`异常`，还可以分为`故障fault`、`陷阱traps`
32 ~ 255用户自定义
linux把32~47对应到8259A中断请求号
**把程序发起的`system call`中断设置为`0x80`，系统调用中断是用户程序使用操作系统资源的唯一接口**

### 5.4.5 标志寄存器的中断标志
为了避免 `竞争条件、中断` 对临界代码区（包含临界资源，同一时间只能一个线程执行的代码）的干扰，linux 0.11内核代码使用了`cli`，`sti`
#### `cli`
    复位CPU标志寄存器的中断标志
    系统执行该指令后，不再响应外部中断

#### `sti`
    设置标志寄存器的中断标志
    允许CPU识别并响应外部设备发出的中断

当进入可能引起竞争条件的代码区时，内核中就会使用 cli 指令来关闭对外部中断的响应，
而在执行完竞争代码区时内核就会执行 sti 指令以重新允许 CPU 响应外部中断。

例如，在修改文件超级块的锁定标志和任务进入/退出等待队列操作时都需要首先使用 cli 指令关闭 CPU 对外部中断的响应，在操作完成之后再使用 sti 指令开启对外部中断的响应。
如果不使用 cli、sti 指令对，即在需要修改一个文件超级块时不使用 cli 来关闭对外部中断的响应，那么在修改之前判断出该超级块锁定标志没有置位而想设置这个标志时，若此时正好发生系统时钟中断而切换到其他任务去运行，并且碰巧其他任务也需要修改这个超级块，那么此时这个其他任务会先设置超级块的锁定标志并且对超级块进行修改操作。当系统又切换回原来的任务时，此时该任务不会再去判断锁定标志就会继续执行设置超级块的锁定标志，从而造成两个任务对临界代码区的同时多重操作，引起超级块数据的不一致性，严重时会导致内核系统崩溃。

## 5.5 Linux的系统调用
### 5.5.1 系统调用接口
**syscall是linux内核与上层应用程序交互的唯一接口**
用户直接/间接（库函数）调用`int 0x80`，在EAX寄存器指定系统调用功能号，就可使用内核资源、系统硬件资源
通常应用程序使用标准接口定义的C函数库的函数，间接使用内核的系统调用
```c
printf()                        // 应用程序
// -------
    库函数printf()              // C函数库
        库函数write()
// -------
            系统调用write()     // 内核

```
系统调用通常用函数形式调用，有一个或多个入参，出参为执行结果
错误码会放在全局变量errno中
linux内核中，每个系统调用功能号定义在`include/unistd.h`
`write`系统调用的功能号是4，符号为`_NR_write`
功能号实际上对应`include/linux/sys.h`中定义的 系统调用处理程序指针数组表`sys_call_table[]`中项的索引值
write对应的处理程序指针位于该数组的`项4`
内核中所有系统调用处理函数的名称都是`sys`开头的

### 5.5.2 系统调用处理过程
应用程序通过库函数，向内核发出一个中断`int 0x80`，就开始执行系统调用
其中eax寄存器存放着系统调用号，携带参数可依次存放在`ebx, ecx, edx`（最多三个）
处理系统调用中断`int 0x80`的过程是`kernel/system_call.s`中的`system_call`
内核源码`include/unistd.h`中定义了`宏函数_syscalln()`
如果要传递大块数据给内核，可以传递这块数据的指针值
```c
// read系统调用的定义
int read(int fd, char* buf, int n);

// 用户程序中，对应的系统调用的宏的形式，可以直接执行以下函数，而不通过C函数库作为中介
_syscall3(int, read, int, fd, char* buf, int n);
```
`include/unistd.h`中的每个系统调用宏，都有2 + 2*n 个参数
这个宏会被扩展成`包含内嵌汇编语句`（目的是进入内核中的中断调用处理程序，该程序：先检查eax中的系统调用功能号是否合法，然后根据`sys_call_table[]函数指针表执行相应的系统调用处理程序`）的C函数

### 5.5.3 Linux系统调用的参数传递方式
基于`通用寄存器传递方法`（ebx, ecx, edx）
优点：**当进入系统中断服务程序，保存寄存器值（系统调用触发中断时，CPU切换到内核态，自动将寄存器压入当前进程的内核态堆栈中，CPU硬件自动完成）时，这些传递参数的寄存器也自动放在内核态堆栈上，因此不必专门对传递参数的寄存器进行特殊处理（不必另外通过指令，拷贝寄存器的值）**，是最简单、最快的传参方法

## 5.6 系统时间和定时
### 5.6.1 系统时间
微机系统中有用电池供电的实时钟RT电路，通常，它与保存系统信息的CMOS RAM集成在一个芯片
linux初始化时会读取这块芯片的`当前时间和日期`，并通过函数转换成`UNIX日历时间（从70.1.1 0时到当前的以秒为单位的时间）`，保存在全局变量`startup_time`，可供用户程序调用

`jiffies`，系统启动开始计数的`系统滴答值`（可通过宏来访问），通常是毫秒级别
在修改文件被访问时间，或者i节点被修改时间时，均使用了这个宏

### 5.6.2 系统定时
linux 0.11内核初始化过程中，PC的Intel 8253(4)定时芯片的计数器通道0被设置成运行在方波发生器方式下，`初始计数值LATCH`被设置成：每10ms在通道0输出端OUT发出一个方波上升沿。由于8254芯片的时钟输入频率为1.193180MHz，因此`初始计数值为LATCH = 1193180/100`，意思就是每10ms，这个计数值从11931减到0，每个时钟周期-1。
OUT引脚连接中断控制芯片0级上，所以系统每10ms发送一个时钟中断请求（IRQ0），这个节拍就是操作系统的运行脉搏（`1个系统时钟周期`）。
时钟中断处理程序通过`jiffies`来累计系统启动后的时钟滴答数，后续调C语言的`do_timer`进一步处理，入参为当前代码特权级CPL，该函数实现如下：
1. 如果CPL = 0，表示进程运行在内核态被中断
    内核把进程内核态运行时间统计值 + 1
2. CPL ! = 0
    把进程用户态运行时间统计值 + 1

如果软盘处理程序添加过定时器，那么对定时器链表进行处理，对每个定时器减去1个滴答值：
* 当某个定时器减为0，调该定时器的处理函数，然后对当前进程运行时间的时间片 - 1；
* 如果时间片没用完就退出`do_timer`继续运行当前进程，如果减为0，则程序根据被中断程序的级别确定进一步处理方法：
1. 如果被中断的进程工作在用户态
    `do_timer`调用调度`schedule()`函数，切换到其他进程运行

2. 如果在内核态
    `do_timer`立即退出，因而linux系统的进程在内核态运行时不会被调度程序切换（linux 2.4起，内核空间的进程也会被抢占），是`不可抢占的`

上述定时器专用软盘，类似于现代linux中的动态定时器，仅供内核使用，可以在需要时动态创建，到期时动态撤销
代码见`sched.c 264~336`


## 5.7 Linux进程控制
`分时技术`：时间片轮转（几十ms一个时间片），当前进程时间片耗完，调度程序切换另一个进程执行
`进程`：执行中的程序实例

linux 0.11，最多64个进程，第一个进程是“手工”创建，其他都是基于`fork`系统调用。
内核通过`pid(process ID)`来标识每个进程。
进程之间，代码段、数据区、堆栈区是彼此隔离的。
进程间通信要通过系统调用。
对于单CPU的系统，某一时刻只能有一个进程运行。
一个进程可以在`内核态kernel mode`/`用户态user mode`下执行，分别使用各自独立的内核态堆栈（内核执行函数调用时的信息）和用户态堆栈（进程在用户态临时保存调用函数的参数、局部变量）。
linux内核中的进程通常称为`task`，用户空间的叫`进程`。

### 5.7.1 任务数据结构
内核有进程表，每个进程占据一项。linux中，进程表项是一个`task_struct`任务结构指针（`include/linux/sched.h`），又被称作`进程控制块PCB（Process Control Block）`/`进程描述符OD（Processor Descriptor）`。
其中保存着用于控制和管理进程的所有信息：当前运行状态、信号、进程号、父进程号、累计运行时间、正在使用的文件、本任务的局部描述符、任务状态段信息。
```c
struct task_struct {
/* these are hardcoded - don't touch */
	long state;	                                /* -1 unrunnable, 0 runnable, >0 stopped */
	long counter;                               // 任务运行时间计数，是动态的
	long priority;                              // 优先级，值越大，运行得越久   是counter的初值，为15个滴答
	long signal;                                // 信号，每个比特位表示一种信号
	struct sigaction sigaction[32];             // 保存处理各信号所使用的操作和属性，每一项对应一个信号
	long blocked;	                            // 进程当前不想处理的信号的阻塞位图
/* various fields */
	int exit_code;                              // 退出码，父进程会取得它
    /* 代码段地址，代码长度（byte），代码长度+数据长度， 总长度，堆栈段地址*/
    unsigned long start_code, end_code, end_data, brk, start_stack;
	long pid, father, pgrp, session, leader;    // 进程标识号，父进程号，进程组号，会话号，会话首领
	unsigned short uid, euid, suid;             // 用户标识id，有效用户id，保存的用户id
	unsigned short gid, egid, sgid;             // 组id，有效组id，保存的组id
	long alarm;                                 // 报警定时值   当系统滴答值超过该字段，内核向该进程发送 SIGALRM 信号，默认会终止进程运行
	/* 用户态运行时间，系统态运行时间，子进程用户态运行时间，进程开始运行时刻 */
    long utime, stime, cutime, cstime, start_time;
	unsigned short used_math;                   // 是否使用协处理器
/* file system info */ 
	int tty;		                    /* -1 if no tty, so it must be signed */ // 进程使用tty终端的子设备号，-1表示没有使用
	unsigned short umask;                       // 文件创建 属性屏蔽位
	struct m_inode * pwd;                       // 进程的 当前工作目录i节点结构指针
	struct m_inode * root;                      // （进程自己指定的）根目录 i节点结构指针
	struct m_inode * executable;                // 可执行文件i节点结构指针（系统根据它判断是否还有另一个进程在执行同一个可执行文件）
	unsigned long close_on_exec;                // 执行时关闭文件句柄位图标志（include/fcntl.h）
	struct file * filp[NR_OPEN];                // 文件结构指针表，最多32项，表项就是文件描述符值
/* ldt for this task 0 - zero 1 - cs 2 - ds&ss */
	struct desc_struct ldt[3];                  // 局部描述符表，0：空，1：代码段cs，2：数据段和堆栈段ds&ss
/* tss for this task */
	struct tss_struct tss;                      // 进程的任务状态段信息结构（Task State Segment），保存当前处理器的所有寄存器值
};
```
其中的`unsigned long brk`，是指针值，用于为进程添加和释放动态分配的内存
`malloc`，调用`brk系统调用`，内核去操作`brk指针（program break）`
```
高地址
        kernel（映射到进程虚拟地址空间，但是进程不可直接访问）
        栈区
brk ->
        堆区（向高地址延伸）
        BSS，未初始化数据
        初始化数据区
        TEXT
低地址  
```
进程的上下文：**CPU所有寄存器的值、进程的状态、堆栈中的内容**，切换进程的时候，需要进行保存
发生中断时，内核在被中断进程的上下文中，在内核态下，执行中断服务例程，当然会保存需要的资源，以便中断服务结束时能恢复被中断进程的执行



### 5.7.2 进程运行状态
`state`
* TASK_RUNNING
    正在被CPU执行，或者已就绪、但尚未被调度
    具体分为`用户运行态`、`内核运行态`、`就绪态`（进程刚创建的状态）
* TASK_INTERRUPTIBLE        `可中断`睡眠状态
    可被信号唤醒
    系统不会直接就调度该类型的进程，而是当系统产生中断（中断处理程序可能会通知该进程等待的资源到了），或者释放了进程正在等待的资源，或者进程收到一个信号（外部信号打断它的睡眠），都可以唤醒它，切换到`就绪态`
* TASK_UNINTERRUPTIBLE      `不可中断`睡眠状态
    不会因为收到信号而被唤醒
    只有使用`wake_up()`明确地唤醒时，才会转换到可运行的就绪状态
    通常用于进程需要不受干扰地等待或者所等待的事件很快发生时使用
* TASK_STOPPED
    进程收到以下信号时，进入暂停状态
    `SIGSTOP`, `SIGTSTP`, `SIGTTIN`, `SIGTTOU`
    当发送`SIGCONT`信号时，进程转换到可运行状态
    linux0.11中将该状态的进程视作终止来处理

* TASK_ZOMBIE
    进程已停止运行，但是父进程还没调`wait()`获取其状态（因此相关的任务数据结构需要保留），则该进程处理ZOMBIE状态
    当父进程通过`wait()`获取子进程信息后，任务数据结构会被释放

如果进程在`内核态`执行时，需要等待系统的某个资源，该进程会调用`sleep_on()`/`interruptible_sleep_on()`自愿放弃CPU使用权，让调度程序去执行其他的进程，进程进入上述睡眠状态（两种都有）
只有当进程从`内核运行态`转换到`睡眠状态`，内核才进行`进程切换操作`
在内核态下进程的进程不能被其他进程抢占，而且一个进程无法改变另一个进程的状态
内核在`执行临界区代码`时，会`禁止一切中断`，为了避免进程切换时，造成内核数据错误（如果操作到一半，就被切换走了，那这个操作的结果显然是未完成的，而不是完成/未完成两种状态中的一种）

### 5.7.3 进程初始化
boot/目录中，引导程序把内核从磁盘上加载到内存，让系统进入`保护模式`运行后，开始执行系统初始化程序`init/main.c`：
该程序的任务：
1. 确定如何分配使用系统物理内存
2. 调用内核各部分的初始化函数 分别对：内存管理、中断处理、块设备、字符设备、进程管理、硬盘和软盘硬件进行初始化处理

然后该程序把自己“手工”（此时系统里还没有进程的概念）移动到进程0中运行（`move_to_user_mode, include/asm/system.h`，把程序执行流从内核态移动到用户态的任务0中继续运行，核心思想是`中断返回指令来实现特权级的改变，基于CPU保护机制`），调`fork()`，首次创建出进程1
在`进程1`，程序继续进行`应用环境的初始化`并执行`shell登录程序`
进程0，会在系统空闲时被调度，只执行`pause()`系统调用（休眠当前进程，成为空闲进程），其中又会去执行调度函数（放弃CPU，让调度器选择其他进程执行）

move_to_user_mode对中断返回指令的利用：在栈上伪造一个“中断发生时保存的现场”，然后执行 iret，让 CPU “以为”自己是从一个系统调用或中断中返回到用户态。

### 5.7.4 创建新进程
`fork()`，所有进程都是0进程的子进程
创建流程：
1. 从任务数组（64个元素）中找一个空slot
2. 在主内存区，申请一页内存，存放任务数据结构信息，并复制当前进程任务数据结构到新任务数据结构，新进程是`TASK_UN INTERRUPTIBLE`（因为还没准备好）
3. 对复制来的任务数据结构进行修改，把当前进程设置为新进程的`父进程`，清楚信号位图，设置初始时间片为15个系统滴答（150ms），设置TSS寄存器
    各种设置：设置新任务的代码段和数据段基址，**新进程没有实际的物理页面，共享父进程的内存页面，当父进程或者新进程任意一个，有写操作时，才为执行写操作的进程分配相关的独自使用的内存页面（包含代码段、数据段、堆栈区、内存映射区域等），即Copy-On-Write技术**
当`execve()`调用前，子进程完全复制父进程的代码和数据区，调用后，子进程原来的代码和数据区被清理，开始运行后，由于缺页中断，从块设备上加载相应的代码页面，CPU重新执行引起异常的指令。

### 5.7.5 进程调度
主要逻辑：为所有运行态的进程分配CPU运行时间
LINUX进程是可抢占的，被抢占的进程仍然处于`TASK_RUNNING`，也就是就绪态，抢占是在进程处于用户态，进程处于内核态是不可抢占的
为了让进程高效地使用系统资源，又让进程有较快的响应时间，需要合理的进程切换调度策略（linux 0.11采用了基于优先级排队的调度策略）

#### 调度程序
1. 先扫描任务数组，比较就绪态任务的`运行事件递减滴答计数值`，其值大的，说明运行不长，就使用`任务切换宏`，切换该进程执行
2. 如果所有`TASK_RUNNING`（就绪态，等待调度）状态进程的时间片都用完，系统根据每个进程的优先权值prority，对系统中所有进程（包括睡眠中的进程），重新计算每个任务需要运行的时间片值counter。
`counter = counter/2 + priority`
对于正在睡眠（因为等待I/O，信号量而进入睡眠，还保留一些时间片）的进程，被唤醒时就有较高的时间片counter值。
（假如有个CPU密集型任务，就不会占着CPU不撒手）
`schedule()`继续扫描`TASK_RUNNING`状态的进程，并重复上述过程，直到选择出一个进程
如果实在没有进程可运行，系统选择进程0运行：调`pause()`把自己设置为`可中断睡眠状态`，再次调`schedule()`
进程0即便是睡眠状态，只要没有其他进程，`schedule()`依然会选择它
（CPU必须执行一些代码？？？保证CPU必然是正在执行某进程，这样可以执行中断并从中断返回，并且维持内核的CPU控制权，进程0的业务是让CPU进入等待，这段时间内核可以唤醒其他进程，并且还可以保证调度器总有进程可以选择）

#### 进程切换
每当`schedule()`选择出一个进程可运行时，调`switch_to()`宏执行实际切换操作
（上下文切换）该宏把CPU的当前进程状态替换成新进程的状态：
* 设置`内核全局变量current（指向当前CPU运行的进程的task_struct，内核的其他部分如中断处理、系统调用必须知道当前是谁在运行）`为新任务的指针
* 长跳转到新任务的任务状态段TSS（Task State Segment）组成的地址，造成CPU 执行 任务切换操作（可能是X86的硬件任务切换机制，通过这条机器指令，TR寄存器就会更新，CPU自动到新任务的代码开始执行（当然是在保存旧进程的上下文之后））
* CPU把当前任务所有寄存器的状态保存到当前任务寄存器TR中TSS段选择符所指向的`当前进程任务数据结构tss结构中`（把旧进程的状态保存在tss结构中
），然后把段选择符所指向的新任务数据结构中的tss结构中的寄存器信息恢复到CPU中（把新进程的数据恢复到CPU寄存器中），系统就正式开始运行新切换的任务了
（CPU的TR(task register)寄存器指向当前正在运行的任务的TSS）

### 5.7.6 终止进程
进程终止时，内核必须释放该进程占用的系统资源（如：打开的文件、申请的内存）
用户程序`exit()`系统调用：
执行内核函数`do_exit()`：
1. 释放代码段和数据段的页面
2. 关闭所有打开文件
3. 对进程使用的当前工作目录，根目录，运行程序的i节点进行同步操作。
    如果进程有子进程，则让init进程作为其所有子进程的父进程。

如果进程是一个`会话头进程`（会话，对应一次用户登录，是一个或多个进程组的集合，会话头进程就是创建会话的进程，每个会话最多一个控制终端）并且有`控制终端`，则释放控制终端（比如用户退出登录shell），并向属于该会话的所有进程（从该shell派生出来的）发送挂断信号`SIGHUP`,这通常会终止该会话中的所有进程。
然后把进程状态置为`僵死状态TASK_ZOMBIE`（因为这个状态正表示退出了但没完全退出，因为还保留了task_struct的信息）。并向其原父进程发送`SIGCHILD`信号，通知其某个子进程已经终止。（涉及到作业控制）
最后`do_exit()`调用`调度函数`去执行其他进程。

由此可见在进程终止时，它的`task_struct`任务数据结构仍然保留着。因为其父进程还需要使用其中的信息。
在子进程在执行期间，父进程通常使用`wait()`或`waitpid()`函数（等待子进程的`SIGCHILD信号`）等待其某个子进程终止（子进程才真正退出）。
当子进程被终止并处于僵死状态时，父进程就会把子进程运行所使用的时间累加到自己进程中(因为父进程是子进程的创建者和资源申请者)。最终释放已终止子进程任务数据结构所占用的内存页面，并置空子进程在任务数组中占用的指针项。

（一个 make 编译大型项目（启动数百个 gcc 子进程），其中，make 自身只花 0.1s，但系统实际消耗了 10 分钟 CPU 时间）


## 5.8 Linux系统中堆栈的使用方法
四种堆栈

## 5.9 Linux 0.11采用的文件系统
内核代码的正常运行必须依赖文件系统
`根文件系统`负责向内核提供最基本信息和支持
Linux系统引导启动时，默认使用的文件系统是根文件系统，包括：操作系统`最基本的配置文件`和`命令执行程序`
`UNIX类文件系统`主要包括：规定的目录、配置文件、设备驱动程序、开发程序以及用户数据、文本文件
一般有如下子目录和文件：
```sh
etc/        # 系统配置文件
dev/        # 设备文件，以供通过文件操作语句操作设备
bin/        # 系统执行程序：sh, mkfs, fdisk
usr/        # 库函数、手册等
usr/bin     # 用户常用的普通命令
var/        # 系统运行时可变的数据或者日志
```
`存放文件系统的 设备`就是`文件系统设备`
比如WIN的C盘就是文件系统设备，硬盘上`按照一定规则存放的文件`组成`文件系统`
WIN2000有`NTFS` / `FAT32`文件系统
linux 0.11内核支持的文件系统是`MINX 1.0文件系统`，当前的linux系统使用最广泛的是`ex2/ex3`

## 5.10 Linux内核源代码的目录结构
`linux内核`是`单内核`的（宏内核，区别于微内核。所有核心组件都在 内核地址空间 运行，组件之间通过函数调用而非消息传递）
内核中的程序都有紧密联系，依赖和调用关系密切
```sh
├─boot          # 系统引导程序  汇编
├─fs            # 文件系统
├─include       # 头文件
│  ├─asm        # 与CPU体系结构相关的部分
│  ├─linux      # Linux内核专用部分
│  └─sys        # 系统数据结构部分
├─init          # 内核初始化程序
├─kernel        # 内核进程调度、信号处理、系统调用等程序
│  ├─blk_drv    # 块设备 驱动程序
│  ├─chr_drv    # 字符设备 驱动程序
│  └─math       # 数学仿真处理程序
├─lib           # 内核库函数
├─mm            # 内存管理程序
└─tools         # 生成内核Image文件的工具程序
```

### 5.10.1 内核主目录linux
目录下有个makefile。

### 5.10.2 引导启动程序目录boot
* bootsect.s, setup.s（as86编译，as86汇编语言）
* head.s（使用GNU as编译，AT&T汇编语言）
功能：当计算机加电时，引导内核启动，将内核代码加载到内存，以及进入32位保护运行方式前的系统初始化工作

### 5.10.3 文件系统目录fs
1.0版本的MINUX文件系统
Linux是在MINUX系统上开发的，采用MINIX文件系统便于交叉编译，可以从MUNIX中加载Linux分区
Linux文件系统是`多线程`的，复杂，为了避免竞态条件，linux系统严格检查资源分配，并且内核模式中（进程运行在内核态），如果任务没有主动睡眠，就不让内核切换任务

分为四个部分：
1. 高速缓冲区管理
2. 低层文件操作
3. 文件数据访问
4. 文件高层函数

文件系统可以看作：`内存高速缓冲区的扩展部分`，读写操作都现在高速缓冲区

### 5.10.4 头文件主目录include
简单分类：体系结构相关、Linux内核专用、系统专用数据结构

### 5.10.5 内核初始化程序目录 init
`main.c`：执行内核所有初始化，然后移到`用户模式`创建新进程，并在控制台设备上运行shell程序
程序业务逻辑：
1. 根据机器的内存，分配缓冲区内存容量
2. 硬件初始化
3. 人工创建第一个任务：task 0，并设置中断允许标志
4. 执行核心态 -> 用户态，调`fork()`创建进程：执行`init()`：控制台环境设置，生成一个子进程用来运行`shell`

### 5.10.6 内核程序主目录kernel
fork、exit、调度程序、系统调用程序

### 5.10.7 内核库函数目录lib
内核代码不能直接使用标准C函数库，因为完整的C函数库很庞大
lib/是专门存放内核需要的一些函数的，给`内核初始化程序init/main.c运行在用户态的进程（0, 1）`提供支持

### 5.10.8 内存管理程序目录mm
管理地址映射、页面机制

## 5.11 内核系统与应用程序的关系
内核为用户程序提供2类支持：
1. 系统调用接口，即中断调用`int 0x80`
2. `开发环境库函数` `内核库函数`（仅供内核创建的任务0，任务1使用，它们最终还是调系统调用） 用于与内核进行信息交流
所以本质上，内核对所有用户只提供`系统调用`这种统一的接口
当然，一般用户调libc等库函数（API，比系统调用功能多，性能没这么好，但是更具检错能力），库函数再调系统调用
类UNIX系统，普遍使用基于`POSIX`标准的API接口（具有可移植性）

一般应用不允许直接调系统调用，因为可移植性不好
Linux标准库LSB（Linux Standard Base），不允许应用直接访问系统调用宏

## 5.12 linux/Makefile文件
这节开始，提供内核源码注释

最外部的makefile的功能：
让make程序，使用tools/中的build程序（不是内核的一部分，只是用来编译程序用的），将所有内核代码（分别使用8086汇编器、GNU编译器gcc/gas） 编译成 一个可运行的`内核映像文件image`



# 第6章 引导启动程序
`boot/`
使用两种汇编编译器：
`bootsect.s`, `setup.s`     实模式      Intel汇编语法   Intel8086汇编器、链接器
`head.s`                    保护模式    GNU汇编语法     GNU as(gas)
原因是：当时的GNU编译器只能支持i386及以后的CPU代码指令，难以生成运行在实模式下的16位代码程序

## 6.1 总体功能
**Linux操作系统启动 主要执行流程**
PC电源打开，80x86 CPU自动进入`实模式`
从地址`0xFFFF0`自动执行程序代码（`ROM-BIOS`中的地址）
PC机的BIOS：执行某些系统的检测，在`物理地址0`处，开始`初始化中断向量`
将`可启动设备（硬盘）`的第一个扇区（磁盘引导扇区，512字节）读入`内存绝对地址0x7C00（即31KB）`处，并跳转到`0x7C00`
Linux的最最前面部分 是 用8086汇编语言编写的(`boot/bootsect.s`)
它被BIOS读入到`内存绝对地址0x7C00(31KB)`处,当它被执行时就会把自己移动到`内存绝对地址0x90000(576KB)处`,并把启动设备中后`2KB字节代码(boot/setup.s)`读入到`内存0x90200`处，而内核的其他部分(system模块，其中包含head.s程序)则被读入到从`内存地址0x10000(64KB)`开始处
由于当时的`system模块`长度不会超过512KB，所以`bootsect`把system模块读入`物理地址0x10000开始处`，不会覆盖到`0x90000（576KB）`处开始的`bootsect`和`setup模块`。
**后续，`setup`会把`system模块`移动到`物理内存起始位置`**。

因此从机器加电开始顺序执行的程序：
`ROM BIOS -> bootsect.s -> setup.s -> [ head.s -> main.c ]`

bootsect代码为什么不直接把system模块加载到`物理内存0x0000`，而是在setup中再移动？
--> 因为`setup`还需要利用`ROM BIOS`中的中断，来获取机器参数，当`BIOS`初始化时，在物理内存开始处放置一个大小为`1KB`的`中断向量表`，因此在（确保setup使用完BIOS的中断向量表）使用完BIOS的中断调用后才能覆盖该区域。

为什么`boot/bootsect.s`先被加载到`内存绝对地址0x7C00(31KB)`，它运行时再把自己移动到`内存绝对地址0x90000(576KB)处`？
--> 因为后续system模块会占据物理内存0的位置

另外，光是加载上述内核模块，还不足以让Linux系统运行起来。还需要：**根文件系统**。它一般位于一个硬盘分区中。`bootsect.s`中会有根文件系统所在的默认块设备号，用于通知内核，所需要的根文件系统在什么地方。



## 6.2 bootsect.s程序
### 6.2.1 功能描述
`磁盘引导块程序`，必然存储于磁盘的第一个扇区（引导扇区，0磁道，0磁头，第一个扇区）

## 6.3 setup.s程序
### 6.3.1 功能描述

## 6.4 head.s程序


# 第7章 初始化程序
系统执行完`boot/`中的`head.s`，执行权就到了`main.c`
包括了内核初始化的所有工作

## 7.1 main.c程序
### 7.1.1 功能描述
`main.c`利用`setup.s`拿到的`系统参数`，设置`系统的根文件设备号`、一些`内存全局变量`。
内存映像示意：
`[内核程序 / 高速缓冲 / 虚拟盘 / 主内存区]`

`高速缓冲区`
还要扣除被`显存`、`ROM BIOS`占用的部分。它用于`磁盘等块设备`临时存放数据，以`1KB`为一个`数据块`。

`主内存区域`
由`内存管理模块mm`通过`分页机制`进行管理分配，以`4KB`为一个内存页单位。

内核程序自由访问高速缓冲，但通过`mm`才能使用分配到的内存页面。

然后内核进行所有硬件初始化工作：trap, 块设备，字符设备，tty（终端设备）。以及人工设置第一个任务`task 0`。

整个内核完成初始化后，内核将执行权切换到用户模式（任务0）。CPU从`0特权级`切换到`第3特权级`，此时，main.c的主程序就工作在`任务0`中。然后系统第一次调用`fork()`，创建出一个用于运行`init()`的子进程（即`init进程`）。

流程细节：
1. main.c程序首先确定如何分配使用系统物理内存，然后调用内核各部分的初始化函数分别对`内存管理、中断处理、块设备和字符设备、进程管理以及硬盘和软盘硬件`进行初始化处理。
在完成了这些操作之后，系统各部分已经处于可运行状态。
此后程序把自己“手工”移动到`任务0(进程0)`中运行，并使用`fork()调用`首次创建出`进程1(init进程)`，并在其中调用`init()函数`。在该函数中程序将继续进行`应用环境的初始化`并`执行shell登录程序`。
而原`进程0`则会在系统空闲时被调度执行，因此`进程0`通常也被称为`idle进程`。
此时`进程0`仅执行`pause()系统调用`，并又会调用`调度函数`。

2. `init函数`的功能可分为4个部分：
* 安装根文件系统
* 显示系统信息
* 运行系统初始资源配置文件re中的命令
* 执行用户登录shell程序

具体来说：
* 代码首先调用`系统调用setup()`，用来收集`硬盘设备分区表信息`并`安装根文件系统`。
在安装根文件系统之前，系统会先判断是否需要先建立`（内存）虚拟盘`。
若编译内核时设置了虚拟盘的大小，并在前面内核初始化过程中已经开辟了一块内存用作虚拟盘，则内核就会首先尝试把根文件系统加载到内存的虚拟盘区中。

* 然后init打开一个`终端设备tty0`,并复制其`文件描述符`以产生`标准输入stdin`.`标准输出stdout`和`错误输出water`设备。内核随后利用这些描述符在终端上显示一些系统信息，例如：高速缓冲区中缓冲块总数、主内存区空闲内存总字节数等。

* 接着init又新建了一个`进程2`，并在其中为建立用户交互使用环境而执行一些初始配置操作，即在用户可以使用shell命令行环境之前，内核调用`/bin/sh`程序运行了配置文件`etc/rc`中设置的命令。
文件的作用与DOS系统根目录上的AUTOEXEC.BAT文件类似。这段代码首先通过`关闭文件描述符0`，并立刻打开文件`/etc/rc`，从而把标准输入stdin定向到`etc/rc`文件上。
这样，所有的标准输入数据都将从该文件中读取。
然后内核以非交互形式执行`/bin/sh`，从而实现执行`/etc/rc`文件中的命令。
当该文件中的命令执行完毕后，`/bin/sh`就会立刻退出。因此进程2也就随之结束。

* `init`函数的最后一部分：用于在新建进程中为用户建立一个新的会话，并运行用户登录shell程序，`/bin/sh`。
在系统执行`进程2`中的程序时，父进程(init进程)一直等待着它的结束。
随着进程2的退出，父进程就进入到一个无限循环中。
在该循环中，父进程会再次生成一个`新进程`，然后在该进程中创建一个新的会话，并以登录shell方式再次执行程序`/bin/sh`，以创建用户交互shell环境。
然后父进程继续等待该子进程。
登录shell虽然与前面的非交互式shell是同一个程序`/bin/sh`，但是所使用的`命令行参数(argv[])`不同。
登录shell第0个命令行参数的第1个字符一定是一个减号`-`。
这个特定的标志会在`/bin/sh`执行时通知它这不是一次普通的运行，而是作为登录shell运行`/bin/sh`的。
从这时开始，用户就可以正常使用Linux命令行环境了，而父进程随之又进入等待状态。此后若用户在命令行上执行了`exit`或`logout`命令，那么在显示一条当前登录shell退出的信息后，`系统就会在这个无限循环中，再次重复以上创建登录shell进程的过程`。

任务1中运行的`init()函数`的后两部分（创建子进程，执行shell），实际上应该是`独立的 环境初始化程序 init`等的功能。

**首次调`fork()`创建新进程`init`时，为了确保 新进程的用户态栈中 没有进程0的多余信息，要求进程0在创建进程1之前，不要使用`用户态栈`（要求任务0不要调用函数）**

因此，在`main.c`移动到`任务0`执行后，任务0的`fork()`不能以函数形式进行调用。
程序中通过`inline`方式执行这个系统调用。
`_syscall0`宏代码，用于嵌入汇编（0表示无参数的系统调用）
```c
static inline _syscall0(int, fork);

#define _syscall0(type,name) \
type name(void) \
{ \
long __res; \
__asm__ volatile ("int $0x80" \
	: "=a" (__res) \
	: "0" (__NR_##name)); \
if (__res >= 0) \
	return (type) __res; \
errno = -__res; \
return -1; \
}
```
`fork`系统调用的具体业务逻辑（把宏定义展开了）
```c
int fork(void)
{
    long __res; // 局部变量，存储系统调用的返回值
    /*
        触发 软中断，CPU从用户态切到内核态，跳转到内核预先定义的中断处理程序
        "0" (__NR_fork)  表示：使用与第0个输出操作数相同的寄存器eax，也就是说，__NR_fork会放到eax
        "=a"             表示：eax在系统调用后会存放返回值，把eax的值写入到变量_res
    */
    __asm__ volatile ("int $0x80": "=a" (__res) : "0" (__NR_fork)); 
    if (__res >= 0)
        return (type) __res;
    errno = -__res;
    return -1;
}
```
这个fork在调用处，是必然被`内联展开`的
执行`中断指令INT`也还是使用了堆栈，但是使用的是`内核态栈`，每个task都有

创建init进程（进程1）时，系统进行了特殊处理！！！：
**`copy-on-write`技术**
`进程0`和 `进程init` 实际上 （调`fork()`后）同时使用`内核代码区内（小于1MB）`相同的代码 和 `数据物理内存页面（640KB）`，只是执行的业务函数不一样
在为进程1复制进程0的`页目录和页表项`时，进程0的640KB仍然可读写，但是进程1的640KB对应的页表项是`只读`的（使得触发`page fault异常`）。
进程0和进程1，同时使用相同的用户堆栈区，直到发生缺页中断：当进程1开始执行，执行过`出入栈操作`后，触发页面写保护异常，使得内核的内存管理程序为进程1在主内存区中分配一内存页面，并把任务0栈中的相应页面复制到该新页面上，进程0和进程1的用户栈才变成相互独立。
为了防止冲突，进程0在进程1执行栈操作之前禁止使用用户堆栈区，而让进程1能单独使用堆栈。
因为在内核调度进程运行时，进程0创建进程1后，仍然有可能先运行任务0，因此进程0调`fork()`后，随后的`pause()`也必须内联，避免进程0在进程1之前使用用户栈。

当进程2调`execve()`，它的代码和数据区会位于系统的主内存区，因此系统此后可以随时利用`copy-on-write`来处理其他新进程的创建和执行。
（进程1会复制进程0的页表， 但是页表项指向的物理内存页面和进程0是相同的）
对于linux来说，所有任务都是在用户模式下运行：系统应用如：shell，网络子系统程序。
内核源码lib/目录下的库文件就是为它们这些新建的进程提供函数支持的，内核代码本身不会使用这些库函数。



### 7.1.2 代码注释
```c
/*
 *  linux/init/main.c
 *
 *  (C) 1991  Linus Torvalds
 */

#define __LIBRARY__		// 把unistd.h中的内嵌汇编代码引入
/* 这些头文件都在include/下面，属于UNIX标准头文件 */
#include <unistd.h>	// 标准 符号常数 与 类型
#include <time.h>

/*
 * we need this inline - forking from kernel space will result
 * in NO COPY ON WRITE (!!!), until an execve is executed. This
 * is no problem, but for the stack. This is handled by not letting
 * main() use the stack at all after fork(). Thus, no function
 * calls - which means inline code for fork too, as otherwise we
 * would use the stack upon exit from 'fork()'.
 *
 * Actually only pause and fork are needed inline, so that there
 * won't be any messing with the stack from main(), but we define
 * some others too.
 注意inline
 因为内核空间 fork 是没有COW机制的（除非调execve()）， fork() 之后，父子进程 完全地 共享栈（内核刚启动的时候，尚无内存管理机制）
 fork() 之后，main() 函数不能再调函数、或者函数返回，只能内联执行系统调用，如pause()
 */
static inline _syscall0(int,fork)
static inline _syscall0(int,pause)				// 暂停进程，直到收到一个信号
static inline _syscall1(int,setup,void *,BIOS)	// 仅用于linux初始化
static inline _syscall0(int,sync)				// 更新文件系统

#include <linux/tty.h>							// 关于 tty_io，串行通信
#include <linux/sched.h>						// 调度、task_struct、task1
#include <linux/head.h>							// 段描述符
#include <asm/system.h>							// 系统头文件
#include <asm/io.h>								// io头文件

#include <stddef.h>								// 标准定义：NULL, offsetof(...)
#include <stdarg.h>								// va_list, vsprintf
#include <unistd.h>
#include <fcntl.h>								// 文件、fd 控制
#include <sys/types.h>							// 基本 系统数据类型

#include <linux/fs.h>							// 文件系统 头文件

static char printbuf[1024];						// 用于缓存内核显示信息

extern int vsprintf();							// 格式化输出字符串
extern void init(void);
extern void blk_dev_init(void);					// 块设备
extern void chr_dev_init(void);					// 字符设备
extern void hd_init(void);						// 硬盘
extern void floppy_init(void);					// 软驱
extern void mem_init(long start, long end);		// 内存管理
extern long rd_init(long mem_start, int length);// 虚拟盘
extern long kernel_mktime(struct tm * tm);		// 计算开机启动时间
extern long startup_time;						// 内核启动时间

/*
 * This is set up by the setup-routine at boot-time
 以下三个值，在内核引导期间，由setup.s设置
 */
#define EXT_MEM_K (*(unsigned short *)0x90002)			// 扩展内存大小 KB
#define DRIVE_INFO (*(struct drive_info *)0x90080)		// 硬盘参数表 32字节内容
#define ORIG_ROOT_DEV (*(unsigned short *)0x901FC)		// 根文件系统 所在的 设备号

/*
 * Yeah, yeah, it's ugly, but I cannot find how to do this correctly
 * and this seems to work. I anybody has more info on the real-time
 * clock I'd be interested. Most of this was trial and error, and some
 * bios-listing reading. Urghh.

 读取CMOS实时时钟信息
 */

#define CMOS_READ(addr) ({ \
outb_p(0x80|addr,0x70); \
inb_p(0x71); \
})

// BCD码 -> 二进制
#define BCD_TO_BIN(val) ((val)=((val)&15) + ((val)>>4)*10)

// 取CMOS实时钟 为 开机时间，并保存到全局变量
static void time_init(void)
{
	struct tm time;

	do {
		time.tm_sec = CMOS_READ(0);
		time.tm_min = CMOS_READ(2);
		time.tm_hour = CMOS_READ(4);
		time.tm_mday = CMOS_READ(7);
		time.tm_mon = CMOS_READ(8);
		time.tm_year = CMOS_READ(9);
	} while (time.tm_sec != CMOS_READ(0));
	BCD_TO_BIN(time.tm_sec);
	BCD_TO_BIN(time.tm_min);
	BCD_TO_BIN(time.tm_hour);
	BCD_TO_BIN(time.tm_mday);
	BCD_TO_BIN(time.tm_mon);
	BCD_TO_BIN(time.tm_year);
	time.tm_mon--;
	startup_time = kernel_mktime(&time);	// 从1970.1.1 0 到 开机时刻 的 秒数
}

static long memory_end = 0;					// 物理内存 字节
static long buffer_memory_end = 0;			// 高速缓冲区 end 地址
static long main_memory_start = 0;			// 主内存（用于分页）开始的位置

struct drive_info { char dummy[32]; } drive_info;	// 硬盘 参数表

// 内核初始化主程序，完成后以 task0 / idle task的身份运行
void main(void)		/* This really IS void, no error here. */
{			/* The startup routine assumes (well, ...) this */
/*
 * Interrupts are still disabled. Do necessary setups, then
 * enable them
 	先禁止中断，后续开启
 */
 	ROOT_DEV = ORIG_ROOT_DEV;					// 根设备号
 	drive_info = DRIVE_INFO;					// 硬盘参数表
	memory_end = (1<<20) + (EXT_MEM_K<<10);		// 高速缓存（for 文件系统/swap/设备访问） 末端地址 = 1 MB + 扩展内存(k) * 1024 B
	memory_end &= 0xfffff000;					// 忽略不到 4KB（一页）的内存数
	if (memory_end > 16*1024*1024)
		memory_end = 16*1024*1024;				// 只要16 MB
	if (memory_end > 12*1024*1024) 				// 若内存 > 12 MB, 缓冲区末端 = 4MB
		buffer_memory_end = 4*1024*1024;
	else if (memory_end > 6*1024*1024)			// 6 ~ 12 MB，缓冲区设置得小一点 2MB
		buffer_memory_end = 2*1024*1024;
	else
		buffer_memory_end = 1*1024*1024;		// 0 ~ 6 MB，1MB
	main_memory_start = buffer_memory_end;
#ifdef RAMDISK
	main_memory_start += rd_init(main_memory_start, RAMDISK*1024);	// 主存中的一部分 用作 虚拟盘
#endif
	// 内核 各方面的初始化
	mem_init(main_memory_start,memory_end);		// 主存
	trap_init();								// 硬件中断向量 初始化
	blk_dev_init();								// 块设备
	chr_dev_init();								// 字符设备
	tty_init();									// tty
	time_init();								// 设置开机启动时间
	sched_init();								// 调度程序初始化（加载任务0的tr, ldtr）
	buffer_init(buffer_memory_end);				// 缓冲管理 初始化：建内存链表...
	hd_init();									// 硬件初始化
	floppy_init();								// 软驱初始化
	sti();										// （所有初始化完毕）开启中断
	move_to_user_mode();						// 移到用户模式下执行
	if (!fork()) {		/* we count on this going ok */
		init();									// 在子进程（任务1）中执行init()
	}
/*
 *   NOTE!!   For any other task 'pause()' would mean we have to get a
 * signal to awaken, but task0 is the sole exception (see 'schedule()')
 * as task 0 gets activated at every idle moment (when no other tasks
 * can run). For task0 'pause()' just means we go check if some other
 * task can run, and if not we return here.
 	对于常规的task，执行pause()后必须收到一个信号才会返回就绪态（因为进入了不可中断睡眠）
	但是task0是例外，task0在没有其他任务在运行时会被激活，因此task0的pause()会先检查有没有别的进程运行，如果没有的话，还会回来执行pause()
 */
	for(;;) pause();	// pause 在kernel/sched.c	task0会设置可中断等待状态，再执行schedule()函数
}

// 产生格式化信息到标准输出设备：stdout(1)，基于vsprintf()将格式化字符串放入printbuf缓冲区，然后通过write()将缓冲区数据输出到标准设备
static int printf(const char *fmt, ...)
{
	va_list args;
	int i;

	va_start(args, fmt);
	write(1,printbuf,i=vsprintf(printbuf, fmt, args));
	va_end(args);
	return i;
}

// 执行etc/rc文件时，所使用的命令行参数、环境参数
static char * argv_rc[] = { "/bin/sh", NULL };
static char * envp_rc[] = { "HOME=/", NULL };

// 登录shell时，使用的命令行参数、环境参数	注意：-，sh程序会作为登录shell执行
static char * argv[] = { "-/bin/sh",NULL };
static char * envp[] = { "HOME=/usr/root", NULL };

/*
	main函数里已经进行了系统初始化，以下是task1的业务：
	1. 初始化shell环境
	2. 以登录shell方式加载该程序执行
*/
void init(void)
{
	int pid,i;

	setup((void *) &drive_info);								// 读取硬盘参数：分区表信息、加载虚拟盘、安装根文件系统设备
	(void) open("/dev/tty0",O_RDWR,0);							// 以 读写方式 打开设备“/dev/tty0”，对应终端控制台，PS：这里的fd肯定是0
	(void) dup(0);												// 复制句柄，产生1号：stdout标准输出设备	和fd 0指向同一个设备，同一个读写位置
	(void) dup(0);												// 复制句柄，产生2号：stderr标准出错设备	每次open会产生一套读写指针
	printf("%d buffers = %d bytes buffer space\n\r",NR_BUFFERS,
		NR_BUFFERS*BLOCK_SIZE);									// 打印 缓冲区块数、总字节数
	printf("Free mem: %d bytes\n\r",memory_end-main_memory_start);
	if (!(pid=fork())) {										//	fork返回0，创建 并 执行task2：打开文件、以 上述命令行参数 加载可执行文件
		close(0);
		if (open("/etc/rc",O_RDONLY,0))
			_exit(1);		//	错误码1：操作未许可
		execve("/bin/sh",argv_rc,envp_rc);
		_exit(2);			//	错误码2：文件/目录不存在
	}
	if (pid>0)													// 父进程task1 （pid返回>0，表示子进程的PID） 继续完成下列业务：
		while (pid != wait(&i))									// 父进程 等待 子进程结束
			/* nothing */;
	while (1) {													// 此时，子进程task2 执行完毕
		if ((pid=fork())<0) {									// fork 返回-1表示失败
			printf("Fork failed in init\r\n");
			continue;
		}
		if (!pid) {												// 父进程task1又创建新进程
			close(0);close(1);close(2);
			setsid();											// 创建新的会话期（？？？）
			(void) open("/dev/tty0",O_RDWR,0);
			(void) dup(0);
			(void) dup(0);
			_exit(execve("/bin/sh",argv,envp));					// 子进程，使用 另一套 命令行参数
		}
		while (1)
			if (pid == wait(&i))
				break;
		printf("\n\rchild %d died with code %04x\n\r",pid,i);
		sync();													// 刷新缓冲区
	}
	_exit(0);	/* NOTE! _exit, not exit() */					// exit()是普通函数库里的，先会执行清楚操作，才调用系统调用。而_exit()直接对应sys_exit系统调用
}
```

### 7.1.3 其他信息
#### 7.1.3.1 CMOS信息
CMOS内存（64B，时间信息只占14B，剩余空间按可存放系统配置数据），是系统实时钟芯片的一部分，保存`时钟和日期`信息

#### 7.1.3.2 调用`fork()`创建新进程
fork()的返回值：
1. （在父进程中）正整数	子进程的PID
2. （在子进程中）0
3. 调用失败		< 0

#### 7.1.3.3 关于会话期(session)的概念
进程通过`fork`创建子进程，形成进程组
```sh
# 管道命令（前一个命令的 标准输出，作为后一个命令的 标准输入）
cat main.c | grep for | more	# 三个 兄弟 进程，属于一个进程组
```
每个进程组，有一个唯一的 进程组`gid`(Group ID)
每个进程组 有一个 `组长` 进程，其`pid` = `gid`（一般是第一个创建的进程）

进程可以调`setpgid()`，来参加现有的进程组 / 创建新的进程组

进程组的用途：
在终端上 向 前台执行程序（这里应该是指整个前台进程组） 发出终止信号（Ctrl + C），直接终止整个进程组的所有进程
（不需要是组长进程？？？）

`会话（Session）`是`一个 或 多个 进程组 的集合`
用户登录后执行的所有程序，都属于同一个`Session`
登录shell是`会话期 首进程`/`控制进程`，它使用的终端是 会话期的 `控制终端`
退出时，所有属于这个会话的进程都被终止
`setsid`，可用于建立一个新的`session`，由环境初始化程序调用

`一个session`，包含 `一个前台进程组`（拥有`控制终端`的一个进程组），`一个或几个后台进程组`
`一个终端`，只能作为 `一个session`的 `控制终端`（对应`/dev/tty`设备文件）

## 7.2 环境初始化工作
内核 初始化 完毕，还需要：环境 初始化
流程：
`init(task 1)` -fork()-> `agetty` -exec()-> `login` -exec()-> `shell`

init根据`/etc/rc`中的信息，执行其命令，然后 根据`/etc/inittab`，为每一个 允许登录的 终端设备，使用`fork()`创建一个`子进程`，其中执行`agetty`，init会`wait()`这些子进程结束，每当一个子进程结束，通过返回的pid得知是哪个对应终端的子进程结束了，为它再创建一个`agetty`程序（为了保证每个终端 都有一个进程为其等待处理）

在正常的操作下，`init`确定`agetty`正在工作着以允许用户登录，并且收取`孤立进程`。
`孤立进程`是指那些其父辈进程已结束的进程；
在Linux中所有的进程必须属于单棵进程树，所以孤立进程必须被收取。
当系统关闭时，`init`负责`杀死所有其它的进程`，卸载所有的文件系统以及停止CPU的工作，以及任何它被配置成要做的工作。

**`getty`程序**
主要任务是：`设置终端类型、属性、速度和线路规程`。
它打开并初始化一个tty端口，显示提示信息，并等待用户键入用户名。
该程序只能由超级用户执行。
通常，若`/etc/issue`文本文件存在，则getty会首先显示其中的文本信息，然后显示登录提示信息（例如：plinux login: ），读取用户键入的登录名，并执行`login程序`。

**`login`程序**
主要用于要求登录用户输入密码
把用户键入密码和passwd文件中的对应字段比较

* 错误次数多了，则login以1错误码退出，父进程init进程的wait()返回，重新创建子进程
* 密码正确，则login把`CWD`修改成passwd中指定的 用户起始工作目录
	并把对该终端设备的访问权限修改成`用户读/写 和 组写`，设置进程的`组ID`。
	然后利用所得到的信息初始化环境变量信息，例如起始目录（`HOME=`）、使用的shell程序（`SHELL=`）、用户名（`USER=`和`LOGNAME=`）和系统执行程序的默认路径序列（`PATH=`）。
	接着显示/etc/motd文件（message-of-the-day）中的文本信息，并检查并显示该用户是否有邮件的信息。
	最后login程序改变成登录用户的用户ID并执行口令文件中该用户项中指定的shell程序，如bash或csh等。

**`shell`程序**
是 复杂的 `命令行解释程序`

是当用户登录系统进行交互操作时执行的程序。它是用户与计算机进行交互操作的地方。
它获取用户输入的信息，然后执行命令。用户可以在终端上向shell直接进行交互输入，也可以使用shell脚本文件向shell解释程序输入。
在Linux系统中，目前常用的shell有：
```
Bourne Again Shell,/bin/bash
C shell,/bin/csh（或tcsh）
BSD shell/bin/ash（或bsh）
```

在登录过程中login开始执行shell时，所带参数`argv[0]`的第一个字符是`-`，表示该shell是作为一个`登录shell`被执行。
此时该shell程序会根据该字符，执行某些与登录过程相应的操作。
`登录shell`会首先从`/etc/profile`文件以及`.profile文件`（若存在的话）读取命令并执行。
如果在进入shell时设置了`ENV环境变量`，或者在登录shell的`.profile`文件中设置了该变量，则shell下一步会从该变量命名的文件中读去命令并执行。
因此用户应该把`每次登录时都要执行的命令`放在`.profile`文件中，而把`每次运行shell都要执行的命令`放在`ENV变量指定的文件中`。
设置ENV环境变量的方法是把下列语句放在你起始目录的.profile文件中。
```sh
ENV=$HOME/.anyfilename; export ENV
```
在执行shell时，除了一些指定的可选项以外，如果还指定了命令行参数，则shell会把第一个参数看作是一个脚本文件名并执行其中的命令，而其余的参数则被看作是shell的位置参数（$1、$2等）。
否则shell程序将从其标准输入中读取命令。



# 第8章 内核代码
`linux/kernel/`

## 8.1 总体功能
以上目录的代码，总体分为三类：
1. 硬件（异常）中断处理程序 文件
2. 系统调用服务处理程序 文件
3. 进程调度等 通用功能 文件

### 8.1.1 中断处理程序
主要包括：`asm.s`，`traps.c`

进程将`控制权`交给中断处理程序 前，CPU首先将至少`12字节（EFLAGS, CS, EIP）`的信息，压入 `中断处理程序的堆栈（进程的内核态栈）`中

### 8.1.2 系统调用处理相关程序
Linux 进程调 `内核` 的功能是通过中断调用`init 0x80`进行的，eax放调用号，ebx, ecx, edx存`调用参数`

注意函数名前缀：
举例：`do_signal`，基本上是所有系统调用都要执行的函数，`sys_execve()`是 某个系统调用专用的C处理函数

### 8.1.3 其他通用程序
`schedule.c()`,`sleep_on()`,`wakeup()`

### 8.3 asm.s程序

### 8.4 traps.C

### 8.5 system_call.s

### mktime.c


## 8.7 sched.c程序
### `schedule()`	选择系统中下一个要运行的进程
```c
#define FIRST_TASK task[0]
#define LAST_TASK task[NR_TASKS-1]
// ...

/*
 *  'schedule()' is the scheduler function. This is GOOD CODE! There
 * probably won't be any reason to change this, as it should work well
 * in all circumstances (ie gives IO-bound processes good response etc).
 * The one thing you might take a look at is the signal-handler code here.
 *
 *   NOTE!!  Task 0 is the 'idle' task, which gets called when no other
 * tasks can run. It can not be killed, and it cannot sleep. The 'state'
 * information in task[0] is never used.

 	选择系统下一个要运行的进程
 */
void schedule(void)
{
	int i,next,c;
	struct task_struct ** p;

/* check alarm, wake up any interruptible tasks that have got a signal
	遍历所有任务
	判断是否已经收到信号（没有选择屏蔽的）
	（jiffies是“系统启动以来的时钟滴答数”，是当前时刻，alarm也是时刻）
*/

	for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
		if (*p) {
			if ((*p)->alarm && (*p)->alarm < jiffies) {
					(*p)->signal |= (1<<(SIGALRM-1));				//	时间片到了，设置SIGALRM信号
					(*p)->alarm = 0;
				}
			if (((*p)->signal & ~(_BLOCKABLE & (*p)->blocked)) &&	//	信号位图的判断：SIGALRM && 其他信号
			(*p)->state==TASK_INTERRUPTIBLE)	//	是可唤醒的睡眠
				(*p)->state=TASK_RUNNING;		//	TASK_RUNNING，调度器下次就可以选它运行了
		}

/* 
	this is the scheduler proper: 
	调度程序的主要部分：
		基于 进程的 时间片 & 优先权调度机制，选择 后续任务


*/
	while (1) {
		c = -1;			// 暂存	counter(任务的剩余运行时间)
		next = 0;
		i = NR_TASKS;
		p = &task[NR_TASKS];
		while (--i) {	// 遍历任务
			if (!*--p)
				continue;
			if ((*p)->state == TASK_RUNNING && (*p)->counter > c)	// c用于统计 剩余运行时间 最大 的 就绪态任务
				c = (*p)->counter, next = i;
		}
		if (c) break;
		// c == 0, 每个 就绪态任务 的 counter 都等于0，此刻所有任务的时间片都运行完，必须重新分配counter（睡眠状态的进程，也要参与重新分配counter）
		for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
		/*
			重置 时间片，算法是：原先的 / 2 + priority
			这种算法的好处是：
				因为IO进程本身经常是 非就绪态的，这样变相增加 IO任务的 时间片（可以理解成：IO任务本身消耗CPU少，下次多分一点时间片给它）
		*/
			if (*p)
				(*p)->counter = ((*p)->counter >> 1) +
						(*p)->priority;
	}
	// 得到了最大的counter，对应的task
	switch_to(next);	// 切换到选中的任务，如果c = -1. next = 0，就切换idle任务
}
```

上下文切换的核心逻辑：`switch_to`：设置寄存器、栈指针
```c
/*
 *	switch_to(n) should switch tasks to task nr n, first
 * checking that n isn't the current task, in which case it does nothing.
 * This also clears the TS-flag if the task we switched to has used
 * tha math co-processor latest.

	关键词：
	基于 TSS(Task State Segment) 的硬件任务切换
	全局唯一的 GDT(Global Descriptor Table, 保护模式中)表
	每个task都有一个 运行时的段选择子(selector)

	业务逻辑：
	设置 _tmp = {a, b}，作为跳转目标的占位符
	
	赋值语句：
		dx = _TSS(n), %1 = (*&__tmp.b)

	1. 判断 task n 是否是当前任务
		是，跳转到下面的"1"	（是当前任务的话，就无需切换）
		否，dx --> %1	(也就是b，而a不需要赋值，因为offset会被忽略)
		PS:	x86的长跳转格式是：ljmp selector:offset		这里的地址 等价于 _tmp.b:_tmp.a

	2. 交换 ecx(task n) 和 current
	3. 长跳转到%0, 即"m" (*&__tmp.a)代表的内存位置，触发 硬件任务切换（PS："*&"这种怪异的写法是让GCC认为这是可寻址的内存对象，避免优化成寄存器）
	4. 切换后，比较ecx(task n) 和 _last_task_used_math
		不等，跳过clts代码
		相等，清楚CR0.TS标志，允许使用FPU(浮点协处理器)
 */
#define switch_to(n) {\
struct {long a,b;} __tmp; \
__asm__("cmpl %%ecx,_current\n\t" \
	"je 1f\n\t" \
	"movw %%dx,%1\n\t" \
	"xchgl %%ecx,_current\n\t" \
	"ljmp %0\n\t" \
	"cmpl %%ecx,_last_task_used_math\n\t" \
	"jne 1f\n\t" \
	"clts\n" \
	"1:" \
	::"m" (*&__tmp.a),"m" (*&__tmp.b), \	// 这行的m意思是：__tmp.a是内存操作数，__tmp.b是内存操作数
	"d" (_TSS(n)),"c" ((long) task[n])); \
}
```

### `sys_pause()`	将当前任务转为：可中断等待状态，并重新调度
使进程进入睡眠状态，直到收到一个信号
（PS：该函数的业务逻辑直到0.95版才完全实现）
```c
int sys_pause(void)
{
	current->state = TASK_INTERRUPTIBLE;
	schedule();
	return 0;
}
```

### `sleep_on()`	（很复杂）把task 设置为：不可中断等待 状态，让睡眠队列 头指针 指向该任务
当一个进程等待资源时，把它放在等待队列（初始为空）中。只有wake_up能唤醒这里的进程。
```c
void sleep_on(struct task_struct **p)	// 入参是 等待队列头指针，因为可能修改它，所以是二级指针
{
	struct task_struct *tmp;

	if (!p)
		return;
	if (current == &(init_task.task))	//	task0	sleep是无意义的，其运行不依赖运行状态
		panic("task[0] trying to sleep");

	// 函数调用时，会传进等待队列，所以tmp指向等待队列的首元素
	tmp = *p;
	*p = current;						// 插入 当前任务
	current->state = TASK_UNINTERRUPTIBLE;
	schedule();							// 触发CPU执行其他进程，当前进程挂起
	/*
		当本进程唤醒（就绪态）时，才调这里，既然唤醒，说明资源已经到达，那么就有必要唤醒所有等待（也是调sleep_on）该资源的进程
		想象很多个进程加入这样的等待队列。等待相同资源的进程，确实会加入同一个逻辑等待队列（通过共享同一个指针变量）
		只有当内核某处代码，以队列头指针作为参数wake_up该队列，然后，头指针进程A被调度过来执行，调下面的if(tmp)，设置队列下一个进程B为就绪态，同样地进程B也会置为进程C
		！！！set state的进程就会被schedule选中执行
		*p = tmp;	// 应该被添加
	*/
	if (tmp)
		tmp->state=0;
}
```
PS: 在函数调用的栈帧中，会把下一行执行代码的地址压入栈中，所以下一行代码地址也是栈帧的一部分
* `sys_pause`就是专门等信号的
* `sleep_on`等磁盘I/O等操作

### `interruptible_sleep_on()`	设置可中断等待状态（信号 / wake_up都可能唤醒）
注意！！！看起来这里是确保先唤醒最新加入的任务，然后链式唤醒，
```c
void interruptible_sleep_on(struct task_struct **p)
{
	struct task_struct *tmp;

	if (!p)
		return;
	if (current == &(init_task.task))
		panic("task[0] trying to sleep");
	// 往等待队列插入当前任务
	tmp=*p;
	*p=current;
repeat:	current->state = TASK_INTERRUPTIBLE;
	schedule();
	// 当任务被唤醒时，执行下列代码
	if (*p && *p != current) {		//	如果等待队列还有任务，并且并非当前任务，说明在当前任务被放入队列后，又有新的任务加入了
	// 则把该等待任务也置为 可运行就绪态，进行唤醒（这里是和sleep_on一样的嵌套调用，因为说明共同等待的条件满足了），让自己仍然等待，并重新执行调度程序。这些后来才进入队列的任务被唤醒时，会唤醒当前任务（最下面的tmp->state=0）
		(**p).state=0;
		goto repeat;
	}
	*p = tmp;	// 让队列头指针 指向其余等待任务，说明当前指针处理完了
	// *p=NULL;	linus写错了
	if (tmp)
		tmp->state=0;
}
```

！！！`interruptible_sleep_on`，`sleep_on`的差异在于wake_up必然是从头部开始触发的（因为肯定是单核系统），信号可能是从队列中间位置触发

### `wake_up()`	唤醒 *p 指向的任务， *p 是任务等待队列头指针
新的等待任务是插入在链表头部的，所以唤醒的其实是最后进入等待队列的任务
```c
void wake_up(struct task_struct **p)
{
	if (p && *p) {
		(**p).state=0;
		// *p=NULL;	linus写错了
	}
}
```

### `do_timer()`，时钟中断 C处理函数，`在 system_call.s 中_timer_interrupt 被调用`
入参`cpl`是 `当前特权级0或3`，是时钟中断发生时，正在被执行的代码选择符 中的特权级
cpl = 0:	中断发生时正在执行`内核代码`
cpl = 3:	正在执行`用户代码`
一个进程时间片用完时，进行`任务切换`，并执行一个`计时更新`
```c
void do_timer(long cpl)
{
	extern int beepcount;
	extern void sysbeepstop(void);

	if (beepcount)
		if (!--beepcount)		//	beepcount 在每次时钟中断，递减一次
			sysbeepstop();

	if (cpl)	//	普通用户
		current->utime++;
	else		//	内核程序
		current->stime++;

	if (next_timer) {			//	如果存在定时器，next_timer 指向一个按 “到期时间” 排序 的定时器链表
		next_timer->jiffies--;	//	第一个定时器（的剩余时间） - 1（这里只处理第一个定时器的原因是：第一个定时器的 jiffies 表示：距离它到期还有多少个时钟中断；第二个定时器的 jiffies 表示：在第一个定时器到期之后，还要等多少个中断才轮到它）
		while (next_timer && next_timer->jiffies <= 0) {
			void (*fn)(void);
			
			fn = next_timer->fn;
			next_timer->fn = NULL;
			next_timer = next_timer->next;		//	从定时器中 移除该定时器
			(fn)();				//	调用 处理函数
		}
	}
	if (current_DOR & 0xf0)		//	current_DOR：软件控制器的 数字输出寄存器，0xf0表示有软驱处于活动状态
		do_floppy_timer();		//	软盘定时程序
	if ((--current->counter)>0) return;	//	“当前进程” 运行时间还没完，则退出
	current->counter=0;					//	若 其时间片耗尽，则把counter 清零
	if (!cpl) return;					//	如果是 用户态，则 触发进程切换；而内核态 不依赖counter进行调度
	schedule();
}

// 补充：
static struct timer_list {
	long jiffies;
	void (*fn)();
	struct timer_list * next;
} timer_list[TIME_REQUESTS], * next_timer = NULL;
```



# 第13章 内存管理






# 第14章 头文件






