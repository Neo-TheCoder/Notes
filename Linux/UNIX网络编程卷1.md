
# 第六章 I/O复用: `select`和`poll`函数
## 6.1 概述
在5.12节中，我们看到TCP客户同时处理两个输入:`标准输入`和`TCP套接字`。
我们遇到的问题是就在客户阻塞于(标准输入上的)`fgets调用`期间，服务器进程会被杀死。
服务器TCP虽然正确地给客户TCP发送了一个`FIN`，但是既然客户进程正阻塞于从标准输入读入的过程，它将看不到这个`EOF`，直到`从套接读`时为止(可能已过了很长时间)。
这样的进程需要一种`预先告知内核`的能力，**使得内核一旦发现进程指定的一个或多个`IO条件就绪`(也就是说输入已准备好被读取，或者描述符已能承接更多的输出)，它就通知进程**。
这个能力称为`IO复用 (I/O multiplexing)`，是由`select`和`poll`这两个函数支持的。
我们还介绍前者较新的称为`pselect`的POSIX变种。
有些系统提供了更为先进的让进程在一串事件上等待的机制。轮询设备(poll device)就是这样的机制之一，不过不同厂家提供的方式不尽相同，我们将在第14章中阐述这种机制。

> I/O复用典型使用在下列网络应用场合：
* 当`客户`处理`多个描述符（通常是交互式输入和网络套接字）`时，必须使用I/O复用；
* 如果一个TCP服务器即要`处理 监听套接字(用于接收客户端的连接请求)`，又要`处理 已连接套接字(用于数据传输)`，一般使用I/O复用；
* 一个客户同时处理多个套接字是可能的，不过比较少见；
* 如果一个服务器即要处理`TCP`，又要处理`UDP`，一般就要使用I/O复用。
* 如果一个服务器要处理`多个服务`或者`多个协议`，一般就要使用I/O复用。
I/O复用并非只限于网络编程，许多重要的应用程序也需要使用这项技术。

## 6.2 I/O模型
UNIX下可用的5种`I/O模型`的基本区别：
1. 阻塞式I/O；
2. 非阻塞式I/O；
3. I/O复用（`select`和`poll`）；
4. 信号驱动式I/O（`SIGIO`）；
5. 异步I/O（`POSIX`的`aio_系列函数`）

一个`输入操作`通常包括两个不同的阶段：
1. `等待`数据准备好；
2. 从`内核`向`进程` `复制`数据。
对于一个套接字上的输入操作，第一步通常涉及`等待数据从网络中到达`。
当所等待分组到达时，它被复制到`内核中的 某个缓冲区`。
第二步就是把数据从`内核缓冲区`复制到`应用进程缓冲区`。

### 6.2.1 阻塞式I/O模型
`最流行的I/O模型`是`阻塞式I/O (blocking I/O)模型`，本书到目前为止的所有例子都使用该模型。
默认情形下，所有`套接字`都是`阻塞的`。
以数据报套接字作为例子，我们有如图6-1所示的情形。
我们使用UDP而不是TCP作为例子的原因在于：就UDP而言，数据准备好读取的概念比较简单:要么整个数据报已经收到，要么还没有。
然而对于TCP来说，诸如套接字低水位标记(low-water mark)等额外变量开始起作用，导致这个概念变得复杂。
在本节的例子中，我们把`recvfrom`函数视为系统调用，因为我们正在区分应用进程和内核不论它如何实现(在源自`Berkeley`的内核上是作为系统调用，在`SystemV`内核上是作为调用系统调用`getmsg`的函数)，一般都会从在`应用进程空间`中运行`切换`到在`内核空间`中运行，一段时间之后再切换回来。
在图6-1中，进程调用`recvfrom`，其系统调用 `直到 数据报到达 且 被复制到应用进程的缓冲区中 或者 发生错误`才返回。
最常见的错误是 `系统调用被 信号 中断`，如5.9节所述。我们说进程在从调用`recvfrom`开始到它返回的整段时间内是被阻塞的。`recvfrom`成功返回后，应用进程开始处理数据报。

### 6.2.2 非阻塞式I/O模型
进程把一个`套接字`设置成`非阻塞`是在通知内核：当所请求的`I/O操作`非得把本进程投入睡眠才能完成时，不要把本进程投入睡眠，而是返回一个`错误`。
我们将在第16章中详细介绍非阻塞式IO (nonblocking I/O)，不过图6-2概要展示了我们即将考虑的例子。
前三次调用recvfrom时没有数据可返回，因此内核转而立即返回一个`EWOULDBLOCK错误`。
第四次调用recvfrom时已有一个数据报准备好，它被`复制到 应用进程缓冲区`，于是recvfrom成功返回。我们接着处理数据。
当一个应用进程像这样对一个非阻塞描述符循环调用recvfrom时，我们称之为`轮询`，应用进程持续轮询内核，以查看某个操作是否就绪，这么做往往`耗费大量的CPU时间`。
这种模型通常是在专门提供某一种功能的系统中才有。

### 6.2.3 I/O复用模型
有了`IO复用(I/O multiplexing)`，我们就可以调用`select`或`poll`，**`阻塞`在这两个系统调用中的`某一个`之上**，而不是阻寒在真正的IO系统调用上。
图6-3概括展示了IO复用模型。
**我们阻塞于`select`调用，等待(`多个中的任意一个`)数据报套接字变为`可读`**。
当`select`返回`套接字可读`这一条件时，我们调用`recvfrom` `把 所读数据报 复制到 应用进程缓冲区`。
比较图6-3和图6-1，I/O复用并不显得有什么优势，事实上由于使用`select`需要两个而不是单个系统调用，I/O复用还稍有劣势。
不过我们将在本章稍后看到，使用select的优势在于我们可以`等待多个描述符就绪`。

与I/O复用密切相关的另一种I/O模型是在多线程中使用`阻塞式I/O`。
这种模型与上述模型极为相似，但它没有使用select阻塞在多个文件描述符上，而是使用多个线程(**每个文件描述符一个线程**)，这样每个线程都可以自由地调用诸如`recvfrom`之类的`阻塞式I/O系统调用`了。

### 6.2.4 信号驱动式I/O模型
我们可以用信号，让内核在描述符就绪时发送`SIGIO信号`通知我们，我们称这种模型为`信号驱动式I/O`。
我们首先开启`套接字`的`信号驱动式I/O`功能，并通过`sigaction系统调用`安装一个信号处理函数。
该系统调用将立即返回，我们的进程继续工作，也就是说它没有被阻塞。
当数据报准备好读取时，内核就为进程产生一个SIGIO信号。
我们随后即可以在`信号处理函数`中调用`recvfrom`读取数据报，并**通知主循环数据已准备好 待处理，也可以立即通知主循环，让它读取数据报**。
无论如何处理`SIGIO`信号，这种模型的优势在于**等待数据报到达期间进程不被阻塞**。
主循环可以继续执行，只要等待来自`信号处理函数`的通知:既可以是数据已准备好被处理，也可以是数据报已准备好被读取。

### 6.2.5 异步I/O模型
`异步IO(asynchronous I/O)`由POSIX规范定义。
演变成当前POSIX规范的各种早期标准所定义的实时函数中存在的差异已经取得一致。
一般地说，这些函数的工作机制是：**告知内核启动某个操作，并让内核在整个操作(包括将数据从内核复制到我们自己的缓冲区)完成后通知我们**。
！！！这种模型与前一节介绍的信号驱动模型的主要区别在于：
* `信号驱动式IO`是由`内核`通知我们何时可以`启动一个IO操作`，
* 而`异步I/O模型`是由`内核`通知我们`IO操作何时完成`。
我们调用`aio_read`函数（POSIX异步I/O函数以aio_或lio_开头），给内核传递`描述符，缓冲区指针，缓冲区大小（read相同的三个参数）和文件偏移（与lseek类似）`，并告诉内核当整个操作完成时如何通知我们。
该系统调用立即返回，而且在等待I/O完成期间，我们的进程不被阻塞。
本例子中我们假设要求内核在操作完成时产生某个信号。该信号直到数据已复制到应用进程缓冲区才产生，这一点不同于信号驱动式I/O模型。

### 6.2.6 各种I/O模型的比较
图6-6对比了上述5种不同的I/O模型。
可以看出，前4种模型的`主要区别`在于`第一阶段`，因为它们的`第二阶段`是一样的：在数据从`内核`复制到`调用者的缓冲区`期间，进程阻塞于`recvfrom`调用。
相反，异步IO模型在这两个阶段都要处理，从而不同于其他4种模型。

### 6.2.7 同步IO 和异步I/O 对比
POSIX把这两个术语定义如下:
* `同步I/O操作`(synchronous I/O opetation)
    导致请求进程`阻塞`，直到IO操作完成
* `异步I/O操作`(asynchronous I/O opetation)
    不导致请求进程阻塞。

根据上述定义，我们的前4种模型：阻塞式I/O模型，非阻塞式I/O模型，I/O复用模型和信号驱动式I/O模型都是同步I/O模型，因为其中真正的I/O操作（recvfrom）将阻塞进程。
   只有异步I/O模型与POSIX定义的异步I/O相匹配。

## 6.3 `select`函数
该函数允许进程指示内核等待多个事件中的`任何一个发生`，并只在有`一个或多个事件`发生或`经历一段指定的时间后`才唤醒它。
作为一个例子，我们可以调用select，告知内核仅在下列情况发生时才返回:
* 集合`{1，4，5}`中的任何描述符准备好`读`;
* 集合`{2，7}`中的任何描述符准备好`写`;
* 集合`{1，4}`中的任何描述符有`异常条件`待处理
也就是说，我们**调用`select`告知内核`对哪些描述符(就读、写或异常条件)感兴趣`以及`等待多长时间`**。
我们感兴趣的描述符不局限于`套接字`，任何`描述符`都可以使用select来测试。

```cpp
#include <sys/select.h>
#include <sys/time.h>
int select(int maxfdp1, fd set *readset, fd set *writeset, fd set *exceptset, const struct timeval *timeout);
```
返回:若有就绪描述符则为`其数目`，若超时则为0，若出错则为-1

### `timeout`参数
告知内核等待所指定描述符中的任何一个就绪，可花多长时间
其timeval结构用于指定这段时间的秒数和微秒数。
```c
struct timeval {
    long tv_sec;    // sec
    long tv_usec;   // micro sec
};
```
这个参数有以下三种可能。
1. 永远等待下去:
    仅在有一个描述符准备好I/O时才返回。
    为此，我们把该参数设置为空指针。
2. 等待一段固定时间:
    在有一个描述符准备好I/O时返回，但是不超过由该参数所指向的timeval结构中指定的秒数和微秒数。
3. 根本不等待:
    检查描述符后立即返回，这称为`轮询(polling)`。
    为此，该参数必须指向个timeval结构，而且其中的定时器值(由该结构指定的秒数和微秒数)必须为0。

前两种情形的等待通常会被`进程在等待期间捕获的信号`中断，并从信号处理函数返回。
尽管timeval结构允许我们指定一个微妙级的分辨率，然而内核支持的真实分辨率往往粗糙的多，可能是毫秒级的。
中间的三个参数`readset`、`writeset`、和`exceptset`指定我们要让内核测试`读、写和异常条件`的描述符。
目前支持的`异常条件`只有两个：
1. 某个套件字的带外数据的到达   ？？？
2. 某个已置为分组模式的伪终端存在可从其主端读取的控制状态信息   ？？？

 如何给这三个参数中的每一个参数指定一个或多个描述符值是一个设计上的问题。
 `select`使用描述符集，通常是一个`整数数组`，其中每个整数中的每一位对应一个描述符。
 举例来说，假设使用32位整数，那么该数组的第一个元素对应于描述符0 ~ 31，第二个元素对应于描述符32 ~ 63，以此类推。
 所有这些实现细节都与应用程序无关，它们隐藏在名为fd_set的数据类型和以下四个宏中：
 ```c
    void FD_ZERO(fd_set *fdset);                /* clear all bits in fdset */
    void FD_SET(int fd, fd_set *fdset);        /* turn on the bit for fd in fdset */
    void FD_CLR(int fd, fd_set *fdset);        /* turn off the bit for fd in fdset */
    int   FD_ISSET(int fd, fd_set *fdset);     /* is the bit for fd on in fdset ? */
```
我们分配一个fd_set数据类型的描述符集，并用这些宏设置或测试该集合中的每一位，也可以用C语言中的赋值语句把它赋值成另外一个描述符集。
我们所讨论的`每个描述符占用整数数组中一位`的方法仅仅是select函数的可能实现之一。
不过把描述符集中的每个描述符称为位（bit）是常见的，例如“打开读集合中表示监听描述符的位”。

`poll`函数使用一个完全不同的表示方法：一个`可变长度`的`结构数组`，其中每个结构代表一个描述符。
举个例子，以下代码用于定义一个`fd_set`类型的变量，然后打开描述符1、4和5对于的位：
```c
    fd_set      rset;
    FD_ZERO(&rset);
    FD_SET(1, &rset);
    FD_SET(4, &rset);
    FD_SET(5, &rset);
```
描述符集的`初始化`非常重要，因为作为自动变量分配的一个描述符集如果没有初始化，那么可能发生不可预期的后果。
select函数的中间三个参数`readset、writeset和exceptset`，如果我们对某一个的条件不感兴趣，就可以把它设置为空指针。
事实上，如果这三个指针均为空，我们就有了一个比Unix的sleep函数更为精确的`定时器（sleep睡眠以秒为最小单位）`。`poll函数`提供类似的功能。
`maxfdp1`参数指定`待测试的描述符个数`，它的值是`待测试的最大描述符加1`，描述符`0,1,2 ...`一直到`maxfdp1 - 1`均将被测试。

`头文件<sys/select.h>`中定义的`FD_SETSIZE`常值是数据类型fd_set中的描述符总数，其值通常是1024，不过很少有程序用到那么多的描述符。
`maxfdp1`参数迫使我们计算出所关心的最大描述符并告知内核该值。
以前面给出的`打开描述符1、4和5`的代码为例，其maxfdp1值就是6。是6而不是5的原因在于：我们指定的是`描述符的个数`而非最大值，而描述符是从`0`开始的。
存在这个参数以及计算其值的额外负担纯粹是为了`效率原因`。
**每个`fd_set`都有表示大量描述符（典型数量为1024）的空间，然而一个`普通进程`所用的`数量`却`少得多`。内核正是通过`在进程与内核之间`不复制描述符集中`不必要的部分`，从而不测试总为0的那些位来提高效率的。**

`select`函数修改由指针`readset、writeset和exceptset`所指向的描述符集，因而这三个参数都是`值-结果参数`。(PS: `值-结果参数`是指在函数调用过程中，参数既作为`输入值`传递给函数，又作为`输出值`返回给调用者。在函数执行完毕后，这类参数的值可能会被修改，并且这种修改对调用者是可见的)
调用该函数时，我们指定所关心的描述符的值，该函数返回时，结果将指示哪些描述符已就绪。
该函数返回后，我们使用`FD_ISSET宏`来测试fd_set数据类型中的描述符。
描述符集内任何与未就绪描述符对应的位返回时均清成0。
为此，每次重新调用select函数时，我们都得再次把所有描述符集内所关心的位均`置为1`。
**使用`select`时最常见的两个编程错误是：忘了对最大描述符`加1`；忘了描述符集是`值-结果参数`**。
第二个错误导致调用select时，描述符集内我们认为是1的位却被置为0。
该函数的返回值表示跨所有描述符集的已就绪的总位数。如果在任何描述符就绪之前定时器到时，那么返回0。返回-1表示出错（譬如本函数被一个所捕获的信号中断）。

### 6.3.1 描述符就绪条件
我们一直在讨论等待某个描述符准备好`I/O(读或写)`或是等待其上发生一个待处理的`异常条件`(带外数据)。
尽管可读性和可写性对于普通文件这样的描述符显而易见，然而对于引起select返回套接字“就绪”的条件我们必须讨论得更明确些(TCPv2的图16-52)。
1. 满足下列四个条件之一，表明一个套接字准备好`读`：
a）该套接字`接收缓冲区`中的数据字节数 `大于等于` 套接字`接收缓冲区低水位`的当前大小。
b）该连接的读半部关闭（也就是收到了`FIN`的TCP连接，表示对端关闭了`写操作`）。
    对这样的套接字的读操作将不阻塞并返回0（也就是返回EOF）
c）该套接字是一个`监听套接字`且已完成的连接数不为0。
    对这样的套接字的`accept`通常不会阻塞。
d）其上有一个`套接字错误`待处理，对这样的套接字的读操作将不阻塞并返回-1，也就是返回一个错误，同时把`errno`设置成确切的错误条件。
    这些待处理错误也可以通过指定`SO_ERROR`套接字选项调用`getsockopt`获取并清除。

2. `可写`条件
a）该套接字`发送缓冲区`中的可用空间字节数 `大于等于` 套接字`发送缓冲区低水位`标记的当前大小
b）该连接的写半部关闭。
    对这样的套接字的写操作将产生`SIGPIPE信号`
c）使用`非阻塞式`connect的套接字已经建立连接，或者connect已经以失败告终。
d）其上有一个`套接字错误`待处理，对这样的套接字的写操作将不阻塞并返回-1，也就是返回一个错误，同时把errno设置成确切的错误条件。
    这些待处理错误也可以通过指定SO_ERROR套接字选项调用getsockopt获取并清除。

3. 异常条件
如果一个套接字存在`带外数据`或者仍处于`带外标记`，那么他有异常条件待处理。
注意:当某个套接字上发生`错误`时，它将由select标记为`既可读又可写`。
`接收低水位标记 和 发送低水位标记`的目的在于：允许应用进程控制在`select`返回可读或可写条件之前，有多少数据可读或有多大空间可用于写。
举例来说，如果我们知道除非至少存在64个字节的数据，否则我们的应用进程没有任何有效工作可做，那么可以把接收低水位标记设置为64，以防少于64个字节的数据准备好读时select唤醒我们。
任何`UDP套接字`只要其`发送低水位标记` 小于等于 `发送缓冲区大小`(默认应该总是这种关系)就总是可写的，这是因为UDP套接字不需要连接。

### 6.3.2 select的最大描述符数
早些时候我们说过，大多数应用程序不会用到许多描述符。
譬如说我们很少能找到一个使用几百个描述符的应用程序。
然而使用那么多描述符的应用程序确实存在，它们往往使用`select`来复选描述符。
最初设计select时，操作系统通常对每个进程可用的最大描述符数设置了上限(4.2BSD的限制为31)，select就使用相同的限制值。
然而当今的Unix版本允许每个进程使用事实上无限数目的描述(往往仅受限于内存总量和管理性限制)，因此我们的问题是这对select有什么影响?

值得注意的是，有些应用程序（典型例子是：需要复选大量描述符的事件驱动型服务器程序，所需描述符量超过1024个）开始改用`poll`代替`select`，这样可以避免描述符有限的问题。
还要注意的是，`select`的典型实现在描述符数增大时可能存在`扩展性问题`
请注意TCPv2的图16-53声明了3个在内核中的描述符集，并把内核的`FD_SETSIZE`定义作为上限使用。
因此增大描述符集大小的唯一方法是先增大`FD_SETSIZE`的值，再`重新编译内核`。不重新编译内核而改变其值是不够的



## 6.10 poll函数
poll功能与select类似，在处理流设备时，能够提供额外的信息。
```c
#include <poll.h>
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
```
### fds
第一个参数是指向一个结构体数组第一个元素的指针，数组的每个元素都是`pollfd`结构，用于指定测试某个给定描述符fd的条件：
```c
struct pollfd {
        int   fd;         /* file descriptor */
        short events;     /* requested events */
        short revents;    /* returned events */
           };
```
要测试的条件由events成员指定，函数在相应的`revents`成员中返回该描述符的状态
（每个描述符都有两个变量，一个为调用值，另一个为返回结果，从而避免使用值-结果参数。
回想select函数的中间三个参数都是`值-结果参数`。这两个成员中的每一个都由指定某个特定条件的一位或多位构成。
图6-23列出了用于指定`events标志`以及测试`revents标志`的一些常值。）

我们将该图分为三个部分：第一部分处理输入的四个常值，第二部分处理输出的三个常值，第三部分处理错误的三个常值。
其中第三部分的三个常值不能在events中设置，但是当相应条件存在时就在revents中返回。
`poll`识别三类数据：`普通（normal）`、`优先级带（priority band）`和`高优先级（high priority）`。
这些术语均出自`基于流`的实现。
就`TCP和UDP套接字`而言，以下条件引起poll返回特定的revent。
不幸的是，POSIX在其poll的定义中留了许多空洞（也就是说有许多方法可返回相同的条件）。
1. 所有`正规tcp数据`和`所有udp数据`都被认为是`普通数据`。
2. tcp的带外数据被认为优先级带数据。
3. 当tcp连接的读半部关闭时（譬如收到了一个来自对端的FIN），也被认为是普通数据，随后的读操作将返回0。
4. tcp连接存在错误即可认为是普通数据，也可以认为是错误（POLLERR）。
    无论哪种情况，随后的读操作将返回-1，并把errno设置成合适的值。这可用于处理诸如接收到RST和发生超时等条件。
5. 在监听套接字上有新的连接可用既可认为是普通数据，也可以认为是优先级数据。
    大多数实现视之为普通数据。
6. 非阻塞式connect的完成被认为是使相应套接字可写。

### nfds
`结构数组中元素的个数`是由`nfds`参数指定。

### timeout
`timeout`参数指定poll函数返回前`等待多长时间`。
他是一个指定应等待毫秒数的正值。
表示永远等待的`INFTIM常值`被定义为一个负值。如果系统不能提供毫秒级精度的定时器，该值就向上舍入到最接近的支持的值。
当发生错误时，`poll函数`的返回值为`-1`，若定时器到时之前没有任何描述符就绪，则返回0，否则返回就绪描述符的个数，即revents成员值非0的描述符个数。
如果我们不再关心某个特定描述符，那么可以把他对应的`pollfd`结构的fd成员设置成一个负值。`poll`函数将忽略这样的pollfd结构的events成员，返回时将他的revents成员的值置为0。
回顾在`select`技术中，我们就常量`FD_SETSIZE`以及`每个描述符集`中`最大描述符数目`相比`每个进程中 最大描述符数目`展开讨论。
而在`poll`技术中，便不再有此问题，因为分配一个`pollfd`结构的数组，并把该数组中元素的数目通知内核成了调用者的责任。
内核不再需要知道类似`fd_set`的固定大小的数据类型。






































