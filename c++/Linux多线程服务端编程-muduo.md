
# 第一章 线程安全的对象生命期管理


## 1.1 当析构函数遇到多线程
与其他面向对象语言不同，C++ 要求程序员自己管理对象的生命期，这在多线程环境下显得尤为困难。当一个对象能被多个线程同时看到时，那么对象的销毁时机就会变得模糊不清，可能出现多种竟态条件(race condition ):
* 在即将析构一个对象时，从何而知此刻是否有别的线程正在执行该对象的成员函数？
* 如何保证在执行成员函数期间，对象不会在另一个线程被析构？
* 在调用某个对象的成员函数之前，如何得知这个对象还活着?它的析构函数会不会碰巧执行到一半？

使用`std::shared_ptr`可以一劳永逸解决这些问题。

### 1.1.1 线程安全的定义
`一个线程安全的class`满足以下三条件：
1. 多线程同时访问时，其表现出正确的行为
2. 无论操作系统如何调度这些线程，无论这些线程的执行顺序如何交织
3. 调用端代码无须额外的同步或其他协调操作
显然`std::vector`、`std::string`不是线程安全的








