
# 第一章 线程安全的对象生命期管理


## 1.1 当析构函数遇到多线程
与其他面向对象语言不同，C++ 要求程序员自己管理对象的生命期，这在多线程环境下显得尤为困难。当一个对象能被多个线程同时看到时，那么对象的销毁时机就会变得模糊不清，可能出现多种竟态条件(race condition):
* 在即将析构一个对象时，从何而知此刻是否有别的线程正在执行该对象的成员函数？
* 如何保证在执行成员函数期间，对象不会在另一个线程被析构？
* 在调用某个对象的成员函数之前，如何得知这个对象还活着?它的析构函数会不会碰巧执行到一半？

使用`std::shared_ptr`可以一劳永逸解决这些问题。

### 1.1.1 线程安全的定义
`一个线程安全的class`满足以下三条件：
1. 多线程同时访问时，其表现出正确的行为
2. 无论操作系统如何调度这些线程，无论这些线程的执行顺序如何交织
3. 调用端代码无须额外的同步或其他协调操作
显然`std::vector`、`std::string`不是线程安全的


## 1.2 对象的创建容易
对象构造要做到线程安全，唯一的要求是在构造期间不要泄露 this 指针，即
* 不要在构造函数中注册任何回调;
* 也不要在构造函数中把`this`传给跨线程的对象:
* 即便在构造函数的最后一行也不行。

之所以这样规定，是因为在构造函数执行期间对象还没有完成初始化，如果 this被泄露（escape）给了其他对象（其自身创建的子对象除外），
那么别的线程有可能访问这个半成品对象，这会造成难以预料的后果。

也就是说，对于观察者模式（需要把自己的this指针传递出去），要用两段式构造（`构造函数()` + `Init()`）：构造函数 + 注册回调
既然允许二段式构造，那么构造函数不必主动抛异常（抛出异常的话，要注意内存等资源的释放），调用方靠`initialize()`的返回值来判断对象是否构造成功，这能简化错误处理。
即使构造函数的最后一行也不要泄露this，因为Foo有可能是个基类，基类先于派生类构造，执行完`Foo::Foo()`的最后一行代码还会继续执行派生类的构造函数，这时派生类对象还处于构造中，仍然不安全。
相对来说，对象的构造做到线程安全还是比较容易的，毕竟曝光少，回头率为零。
而析构的线程安全就不那么简单，这也是本章关注的焦点。


## 1.3 销毁困难
对象析构，这在单线程里不构成问题，最多需要注意避免空悬指针和野指针。而在多线程程序中，存在了太多的竞态条件。对一般成员函数而言，做到线程安全的办法是让它们顺次执行，而不要并发执行（关键是不要同时读写共享状态，也就是让每个成员函数的临界区不重叠。这是显而易见的，不过有一个隐含条件或许不是每个人都能立刻想到:成员函数用来保护临界区的互斥器本身必须是有效的。**而析构函数破坏了这一假设，它会把mutex成员变量销毁掉**！
- 空指针：指向已销毁的对象或已回收的地址
- 野指针：未初始化的指针


## 1.4 线程安全的Observer很难
**一个动态创建的对象是否还存活，是不能通过指针看出来的**，因为如果销毁，就无法访问，无法访问就无从得知状态，如果原址又创建了新的对象，则无从判断原对象。

面向对象中，对象间关系主要有三种（后两种关系容易出现内存问题）：
1. 组合
    对象x的生命周期由其唯一的拥有者owner控制，因而不会有多线程下的问题，外层对象析构的时候自然析构了x

2. 聚合
    类似大雁和雁群的关系，即整体与部分的关系
    如果b是动态建的并在整个程序结束前有可能被释放，那么就会出现谈到的竞态条件。

3. 关联
    很宽泛的关系
    对象a使用到了对象b，调用了后者的成员函数，例如：a持有b的指针，而b的生命周期不由a单独控制


那么似乎一个简单的解决办法是：只创建不销毁。
程序使用一个对象池来暂存用过的对象，下次申请新对象时，如果对象池里有存货，就重复利用现有的对象，否则就新建一个。对象用完了，不是直接释放掉，而是放回池子里。
这个办法当然有其自身的很多缺点，但至少能避免访问失效对象的情况发生。
这种山寨办法的问题有:
- 对象池的线程安全，如何安全地、完整地把对象放回池子里，防止出现“部分放回”的竞态？(线程A认为对象x已经放回了，线B认为对象x还活着。)
- 全局共享数据引发的lock contention（即由于获取锁而导致的并发度低的问题），这个集中化的对象池会不会把多线程并发的操作串行化？
- 如果共享对象的类型不止一种，那么是重复实现对象池还是使用类模板？
- 会不会造成内存泄漏与分片？因为对象池占用的内存只增不减，而且多个对象池不能共享内存(想想为何)。
回到正题上来，**如果对象x注册了任何非静态成员函数回调，那么必然在某处持有了指向x的指针，这就暴露在了race condition之下。**



## 1.5 裸指针为什么不行
指向对象的原始指针(raw pointer)是坏的尤其当暴露给别的线程时。observable应当保存的不是原始的 observer*，而是别的什么东西，能分辨 observer 对象是否存活。
类似地，如果 observer 要在析构函数里解注册(这虽然不能解决前面提到的race condition，但是在析构函数里打扫战场还是应该的)
那么 subject_的类型也不能是原始的 observable*。

### 空悬指针
有两个指针 p1和p2，指向堆上的同一个对象 object，p1和p2位于不同的线程中。
假设线程A通过p1指针将对象销了(尽管把p1置为了NULL)，那p2就成了空指针。
这是一种典型的C/C++ 内存错误。

要想安全地销毁对象，最好在别人(线程)都看不到的情况下，偷偷地做。
(这正是垃圾回收的原理：**所有人都用不到的东西一定是垃圾。**)

#### “解决办法”
引入一层间接性：让p1和p2指向的对象（称之为proxy）永久有效（p1和p2是二级指针）。
何时让proxy释放呢？

#### 优化
##### `引用计数`
为了安全地释放proxy，我们可以引入引用计数(reference counting)，再把p1和p2都从指针变成对象sp1和sp2。
proxy 现在有两个成员：指针、计数器


#### 一个万能的解决方案
引入另外一层间接性(another layer ofindirection)，用对象来管理共享资源(如果把object 看作资源的话)亦即 handle/body 惯用技法(idiom)。当然，编写线程安全、高效的引用计数 handle 的难度非凡作为一名谦卑的序员7，用现成的库就行。万幸，C++的TR1标准库里提供了一对“神兵利器”可助我们完美解决这个头疼的问题。

`shared_ptr<T>`是一个类模板(class template)，它只有一个类型参数，使用起来很方便。
引用计数是自动化资源管理的常用手法，当引用计数降为0时，对象（资源）即被销毁。
`weak_ptr<T>`也是一个引用计数型智能指针，但是它不增加对象的引用次数，即弱(weak)引用。
* `shared_ptr`控制对象的生命期。
shared_ptr是`强引用`(想象成用铁丝绑住堆上的对象)：只要有一个指向对象的 shared_ptr 存在，该x对象就不会析构。当指向对象x的最后一个shared_ptr析构或reset()的时候，保证会被销毁。

* `weak_ptr`不控制对象的生命期，但是它知道对象是否还活着(想象成用棉线轻轻拴住堆上的对象)。
如果对象还活着，那么它可以提升(promote)为有效的shared_ptr；
如果对象已经死了，提升会失败，返回一个空的shared_ptr。`提升/lock()`行为是线程安全的。

PS：`lock()`函数是 std::weak_ptr 的成员函数，它的作用是尝试获取所监视对象的一个 std::shared_ptr。
如果对象仍然存在，`lock()`函数会返回一个指向该对象的 std::shared_ptr；
如果对象已经被销毁，`lock()`函数会返回一个空的 std::shared_ptr。

shared_ptr/weak_ptr 的“计数”在主流平台上是原子操作，没有用锁，性能不俗。
shared_ptr/weak_ptr 的线程安全级别与std::string和STL容器样，后面还会讲。











