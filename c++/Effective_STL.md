# 条款1 仔细选择你的容器
你知道C++中有很多你可以支配的容器，但是你意识到有多少吗？
要确定你没有忽略你的选项，这里有一个快速回顾。

标准STL`序列`容器：
    `vector`、`string`、`deque`和`list`。

标准STL`关联`容器：
    `set`、`multiset`、`map`和`multimap`。

非标准序列容器:
    `slist`和`rope`
    `slist`是一个`单向链表`，
    `rope`本质上是一个`重型字符串`。
    （“绳子（rope）”是重型的“线（string）”。明白了吗？）
    你可以找到一个关于这些非标准（但常见的）容器的概览在条款50。

非标准关联容器:
    `hash_set`、
    `hash_multiset`、
    `hash_map`和`hash_multimap`。
    我在条款25检验了这些可以广泛获得的基于`散列表`的容器和标准`关联`容器的不同点。

`vector<char>`
    可以作为`string`的替代品。
    条款13描述了这个替代品可能会有意义的情况。

`vector`作为`标准关联容器`的替代品。
    就像条款23所说的，有时候vector可以在时间和空间上都表现得比标准关联容器好。

几种`标准非STL容器`:
    包括`数组`、`bitset`、`valarray`、`stack`、`queue`和`priority_queue`。
    因为它们是`非STL容器`，所以在本书中关于它们我说得很少，虽然条款16提到了数组比STL容器更有优势的一种情况，而条款18揭示了为什么`bitset`可能比`vector<bool>`要好。
    值得注意的是，数组可以和STL算法配合，因为指针可以当作数组的迭代器使用。

这是所有的选项，而且可以考虑的范围和可以在它们之间的选择一样丰富。
不走运的是，STL的大多数讨论只限于容器世界的一个很窄的视野，忽略了很多关于选择适当容器的问题。
就连标准都介入了这个行动，提供了以下的在`vector`、`deque`和`list`之间作选择的指导方案：
`vector`、`list`和`deque`提供给程序员不同的复杂度，
因此应该这么用：
* `vector`是一种可以`默认使用`的`序列`类型，
* 当`很频繁地`对序列中部进行`插入`和`删除`时应该用`list`，
当大部分`插入`和`删除`发生在`序列`的`头`或`尾`时可以选择`deque`这种数据结构。

如果你主要关心的是`算法复杂度`，我想这个方案是有理由的建议，但需要关心更多东西。
现在，我们要检查一些可以补充算法复杂度的重要的容器相关问题，但首先我需要介绍一种STL容器的分类方法，它被讨论的次数并不像它应该的那样多。
那是`连续内存容器`和`基于节点的容器`的区别。

`连续内存容器`（也叫做基于`数组`的容器）在一个或多个（动态分配）的`内存块`中保存它们的元素。
如果一个新元素被查入或者已存元素被删除，其他在同一个内存块的元素就必须向上或者向下移动来为新元素提供空间或者填充原来被删除的元素所占的空间。
这种移动影响了`效率`（参见条款5和14）和`异常安全`（就像我们将会看到的）。
标准的连续内存容器是`vector`、`string`和`deque`。
非标准的rope也是连续内存容器。

`基于节点的容器`在`每个内存块`（动态分配）中`只保存一个元素`。
容器元素的插入或删除只影响指向节点的指针，而不是节点自己的内容。
所以当有东西插入或删除时，元素值不需要移动。
表现为`链表`的容器——比如`list`和`slist`————是基于节点的，所有的标准关联容器也是（它们的典型实现是`平衡树`）。
`非标准的散列容器`使用不同的基于节点的实现，就像我们将会在条款25中看到的。

利用这个不恰当的术语，我们已经准备好描述一些大多数关于在容器间选择的问题。
在这个讨论中，我略过考虑非STL类容器（比如，数组、bitset等），因为毕竟这是本关于STL的书。

你需要`“可以在容器的任意位置插入一个新元素”`的能力吗？
    如果是，你需要`序列容器`，`关联容器`做不到。

你关心元素在容器中的`顺序`吗？
    如果不，`散列容器`就是可行的选择。
    否则，你要避免使用散列容器。

必须使用`标准C++`中的容器吗？
    如果是，就可以除去散列容器、slist和rope。

你需要哪一类迭代器？
    如果必须是`随机访问迭代器`，在技术上你就只能限于`vector`、`deque`和`string`，
    但你也可能会考虑`rope`（关于rope的更多信息在条款50）。
    如果需要`双向迭代器`，你就用不了`slist`（参见条款50）和`散列容器`的一般实现（参见条款25）。

当`插入或者删除`数据时，是否非常在意容器内`现有元素的移动`？
    如果是，你就必须`放弃连续内存容器`（参见条款5）。

容器中的数据的`内存布局`需要`兼容C`吗？
    如果是，你就只能用vector（参见条款16）。

`查找速度`很重要吗？
    如果是，你就应该看看`散列容器`（参见条款25），`排序的vector`（参见条款23）和`标准的关联容器`——大概是这个顺序。

你介意如果容器的底层使用了`引用计数`吗？
    如果是，你就得避开`string`，因为很多string的实现是用引用计数（参见条款13）。
    你也不能用`rope`，因为权威的rope实现是基于引用计数的（参见条款50）。
    于是你得重新审核你的`string`，你可以考虑使用`vector<char>`。

你需要`插入和删除`的`事务性语义`吗？
    也就是说，你需要有`可靠地回退`插入和删除的能力吗？
    如果是，你就需要使用`基于节点`的容器。
    如果你需要`多元素插入`（比如，以范围的方式——参见条款5）的事务性语义，你就应该选择list，因为`list`是`唯一提供多元素插入事务性语义`的标准容器。
    `事务性语义`对于有兴趣写`异常安全代码`的程序员来说非常重要。
    （`事务性语义`也可以在`连续内存容器`上实现，但会有一个`性能开销`，而且代码不那么直观。要了解这方面的知识，请参考Sutter的《Exceptional C++》的条款17[8]。）

你要把`迭代器、指针和引用的失效次数`减到最少吗？
    如果是，你就应该使用基于`节点`的容器，因为在这些容器上进行`插入和删除不会使迭代器、指针和引用失效`（除非它们指向你删除的元素）。
    一般来说，在连续内存容器上插入和删除会使所有指向容器的迭代器、指针和引用失效。

你需要具有有以下特性的序列容器吗：
    1. 可以使用随机访问迭代器；
    
    2. 只要没有删除而且插入只发生在容器结尾，指针和引用的数据就不会失效？
        这个一个非常特殊的情况，但如果你遇到这种情况，deque就是你梦想的容器。
        （有趣的是，当插入只在容器结尾时，deque的迭代器也可能会失效，deque是唯一一个“在迭代器失效时不会使它的指针和引用失效”的标准STL容器。）

这些问题几乎不是事情的完结。比如，它们没有关注不同的容器类型使用不同的内存配置策略（条款10和14讨论了这些策略的一些方面）。
但是，它们已经足够是你信服了，除非你对元素顺序、标准的一致性、迭代器能力、内存布局和C的兼容性、查找速度、因为引用计数造成的行为不规则、事务性语义的轻松实现和迭代器失效的条件没兴趣，你得在容器操作的算法复杂度上花更多的考虑时间。当然这样的复杂度是重要的，但这离整个故事很远。

当面对容器时，STL给了你很多选项。如果你的视线超越了STL的范围，那就会有更多的选项。在选择一个容器前，要保证考虑了所有你的选项。一个“默认容器”？我不这么认为。














# 23 考虑用`有序vector`代替`关联容器`
当需要一个提供`快速查找`的数据结构时，很多STL程序员立刻会想到标准关联容器：`set、multiset、map和multimap`。
直到现在这很好，但不是永远都好。如果查找速度真得很重要，的确也值得考虑使用`非标准的散列容器`
对于多数应用，被认为是常数时间查找的散列容器要好于保证了对数时间查找的set、map和它们的multi同事。

即使你需要的就只是`对数时间查找`的保证，标准关联容器仍然可能不是你的最佳选择。
和直觉相反，对于标准关联容器，所提供的性能也经常劣于本该比较次的`vector`。
`如果你要有效使用STL，你需要明白 什么时候 和 怎么让 一个vector 可以提供比标准关联容器更快的查找`。
`标准关联容器`的典型实现是`平衡二叉查找树`。
一个`平衡二叉查找树`是一个对`插入、删除和查找的混合操作优化`的数据结构。
换句话说，它被设计为应用于进行一些插入，然后一些查找，然后可能再进行一些插入，然后也许一些删除，然后再来一些查找，然后更多的插入或删除，然后更多的查找等。
这个事件序列的关键特征是插入、删除和查找都是混合在一起的。一般来说，没有办法预测对树的下一个操作是什么。

在很多应用中，使用数据结构并没有那么混乱。它们对数据结构的使用可以总结为这样的三个截然不同的阶段：
1. `建立`。
    通过插入很多元素建立一个新的数据结构。
    在这个阶段，几乎所有的操作都是插入和删除。
    几乎没有或根本没有查找。
2. `查找`。
在数据结构中查找指定的信息片。
    在这个阶段，几乎所有的操作都是查找。
    几乎没有或根本没有插入和删除。
3. `重组`。
    修改数据结构的内容，也许通过删除所有现有数据和在原地插入新数据。
    从动作上说，这个阶段等价于阶段1。
    一旦这个阶段完成，应用程序返回阶段2。
对于这么使用它们的数据结构的应用来说，一个vector可能比一个关联容器能提供更高的性能（时间和空间上都是）。
但不是任意的vector都会，只有有序vector。
因为只有有序容器才能正确地使用查找算法——
`binary_search、lower_bound、equal_range`等（参见 条款34 ）。
但为什么一个（有序的）vector的二分法查找比一个二叉树的二分法查找提供了更好的性能？
因为有些东西是过时的但却是真的，其中的一个是`大小问题`。
其他东西不那么过时也不那么真，其中的一个是`引用局部性问题`。


## 考虑第一个`大小问题`
假设我们需要一个容器来容纳Widget对象，而且，因为查找速度对我们很重要，我们考虑一个`Widget的关联容器`和一个`有序vector<Widget>`。
如果我们选择一个关联容器，我们几乎确定了要使用平衡二叉树。
这样的树是由树节点组成，每个都不仅容纳了一个Widget，而且保存了一个该节点到左孩子的指针，一个到它右孩子的指针，和（典型的）一个到它父节点的指针。
`这意味着在关联容器中用于存储一个Widget的空间开销至少会是三个指针`。
与之相对的是，当在vector中存储Widget并没有开销：我们简单地存储一个Widget。
当然，vector本身有开销，在vector结尾也可能有空的（保留）空间（参见 条款14 ），但是每个vector开销是可以忽略的（通常是三个机器字，比如，三个指针或两个指针和一个int），而且如果必要的话，末尾空的空间可以通过`“交换技巧”`（？？？）——去掉（看见 条款17 ）。
即使这个附加的空间没有去掉，也并不影响下面的分析，因为当查找时不会引用那段内存。
假设我们的数据结构足够大，它们可以分成多个内存页面，但是vector比关联容器需要的页面要少。
那是因为vector不需要每个Widget的开销，而关联容器给`每个Widget上附加了三个指针`。
要知道为什么这很重要，假设在你使用的系统上一个Widget的大小是12个字节，指针是4个字节，一个内存页面是4096（4K）字节。
忽略每个容器的开销，当用vector保存时，你可以在一页面上放置341个Widget，但使用关联容器时你最多只能放170个。
`因此关联容器和vector比起来，你将会使用大约两倍的内存`。
如果你使用的环境可以用虚拟内存，就很可以容易地看出那会造成`大量的页面错误`，因此一个系统会因为大数据量而明显慢下来。
实际上我在这里还是对关联容器很乐观的，因为我们假设在二叉树中的节点都群集在一个相关的小内存页面集中。
大部分STL实现使用自定义内存管理器（实现在容器的配置器上——参见 条款10 和 11 ）来达到这样的群集，但是如果你的STL实现没有改进树节点中的引用局部性，这些节点会分散在所有你的内存空间。
那会导致更多的页面错误。
即使使用了自定义群集内存管理器，关联容器也会导致很多页面错误，因为，不像连续内存容器，比如vector，基于节点的容器更难保证在容器的遍历顺序中一个挨着一个的元素在物理内存上也是一个挨着一个。但当进行二分查找时那种内存组织方式（译注：遍历顺序中一个挨着一个的元素在物理内存上也是一个挨着一个）正好是页面错误最少的。
概要：
`在有序vector中存储数据很有可能比在标准关联容器中保存相同的数据消耗更少的内存`；
`当页面错误值得重视的时候，在有序vector中通过二分法查找可能比在一个标准关联容器中查找更快`。
当然，`有序vector的大缺点是它必须保持有序`！
当一个新元素插入时，大于这个新元素的所有东西都必须向上移一位。
它和听起来一样昂贵，如果vector必须重新分配它的内在内存（参见 条款14 ），则会更昂贵，因为vector中所有的元素都必须拷贝。
同样的，如果一个元素从vector中被删除，所有大于它的元素都要向下移动。
vector的插入和删除都很昂贵，但是关联容器的插入和删除则很轻量。
这就是为什么 `只有当你知道你的数据结构使用的时候 查找几乎不和插入和删除混合时，使用有序vector代替关联容器才有意义`。


使用有序vector代替set的代码骨架：
```cpp
vector<Widget> vw; // 代替set<Widget>

... // 建立阶段：很多插入
    // 几乎没有查找

sort(vw.begin(), vw.end()); // 结束建立阶段
/*
    模拟一个multi set时，你可能更喜欢用stable_sort来代替；
    参见条款31
*/
Widget w; // 用于查找的值的对象
... // 开始查找阶段
if (binary_search(vw.begin(), vw.end(), w)) ... // 通过binary_search查找

vector<Widget> ::iterator i = lower_bound(vw.begin(), vw.end(), w); // 通过lower_bound查找

if (i != vw.end() && !(w < *i))... // 条款19 解释了 “ !(w < *i) ”测试
    pair<vector<Widget> ::iterator, vector<Widget>::iterator> range = equal_range(vw.begin(), vw.end(), w); // 通过equal_range查找
if (range.first != range.second) ...
... // 结束查找阶段，开始重组阶段

sort(vw.begin(), vw.end()); // 开始新的查找阶段...
```


里面最难的东西就是怎么在搜索算法中做出选择（比如，binary_search、lower_bound等）， 条款45 可以帮你做出选择。

当你决定用vector代替map或multimap时，事情会变得更有趣，因为`vector必须容纳pair对象`。
毕竟，那是map和multimap所容纳的。
但是要注意，如果你声明一个`map<K, V>`的对象（或者等价的multimap），保存在map中的元素类型是`pair<const K, V>`。
如果要用vector模拟map或者multimap，你必须去掉const，因为当你对`vector排序`时，它的元素的值将会通过`赋值`移动，那意味着pair的两个组件`都必须是可赋值的`。
当使用vector来模拟`map<K, V>`，保存在vector中数据的类型将是`pair<K, V>`，而不是`pair<const K, V>`。
map和multimap以顺序的方式保存他们的元素，但用于排序目的时，它们只作用于元素的key部分（pair的第一个组件），所以当排序vector时你必须做一样的事情。
你需要为你的pair写一个自定义比较函数，因为pair的`operator<`作用于pair的两个组件。
有趣的是，你会需要`第二个比较函数`来进行查找。
`用来排序的比较函数`将作用于两个pair对象，但是查找只用到key值。
必须传给用于查找的比较函数一个`key`类型的对象（要查找的值）和一个`pair`（存储在vector中的一个pair）————两个不同的类型。
还有一个附加的麻烦，你不会知道key还是pair是作为第一个实参传递的，
所以你真的需要两个用于查找的比较函数：
* 一个key值先传递，
* 一个pair先传递。

这个例子演示了怎么把这些东西合在一起：
```cpp
typedef pair<string, int> Data; // 在这个例子里 "map"容纳的类型
class DataCompare { // 用于比较的类
public:
    bool operator()(const Data& lhs, const Data& rhs) const   // 用于 排序 的比较函数（按照key比较 即可）
    {
        return keyLess(lhs.first, rhs.first); // keyLess在下面
    }

    bool operator()(const Data& Ihs, const Data::first_type& k) const // 用于 查找 的比较函数（形式1）
    {
        return keyLess(lhs.first, k);
    }

    bool operator()(const Data::first_type& k, const Data& rhs) const // 用于查找的比较函数（形式2）入参顺序变了而已
    {
        return keyLess(k, rhs.first);
    }

private:
    bool keyLess(const Data::first_type& k1, const Data::first_type& k2) const // 真正的 比较函数
    {
        return k1 < k2;
    }
};
```
在这个例子中，我们假设有序vector将模拟`map<string, int>`。
这段代码几乎是上面讨论的字面转换，除了存在成员函数keyLess。
那个函数的存在是用来保证几个不同的`operator()`函数之间的一致性。
每个这样的函数只是简单地比较两个key的值，所以我们把这个测试放在`keyLess`中并让`operator()`函数返回`keyLess`所做的事情，这比复制那个逻辑要好。
这个软件工程中绝妙的动作增强了DataCompare的可维护性，但有一个小缺点，它提供了有不同参数类型的`operator()`函数，这将导致函数对象无法适配（看见 条款40）。噢，好了。
把有序vector用作map本质上和用作set一样。
唯一大的区别是必须把`DataCompare对象`用作比较函数：
```cpp
vector<Data> vd; // 代替map< string, int>
... // 建立阶段：很多插入，几乎没有查找

sort(vd.begin(), vd.end(), DataCompare()); // 结束建立阶段。（当模拟multimap时，你可能更喜欢用stable_sort来代替；参见 条款31）
string s; // 用于查找的值的对象
... // 开始查找阶段

if (binary_search(vd.begin(), vd.end(), s, DataCompare()))... // 通过binary_search查找
vector<Data> ::iterator i = lower_bound(vd.begin(), vd.end(), s, DataCompare()); // 在次通过lower_bound查找，
if (i != vd.end() && !DataCompare()(s, *i))... // 条款45 解释了 “!DataCompare()(s, *i)” 测试
pair<vector<Data>::iterator, vector<Data>::iterator> range = equal_range(vd.begin(), vd.end(), s, DataCompare()); // 通过equal_range查找
if (range.first != range.second)...

... // 结束查找阶段，开始

// 重组阶段
sort(vd.begin(), vd.end(), DataCompare()); // 开始新的查找阶段...
```
正如你所见，一旦你写了`DataCompare`，东西都很好的依序排列了。
而一旦位置合适了，只要你的程序按照101页描述的阶段方式使用数据结构，它们往往比相应的使用真的map的设计运行得更快而且使用更少内存。
如果你的程序不是按照`阶段的方式`操作数据结构，那么使用有序vector代替标准关联容器几乎可以确定是在浪费时间。
















