***
前言：
学习一门语言，不只是学点语法，高效的使用也是很重要的。对于C++而言更是如此。
***
对后者：C++的有效使用有两大类的建议：
1、一般性的设计策略（两种做法，选哪种）
2、带有具体细节的特定语言特性

# P1 习惯C++

# 01 语言联邦
C++由四个次语言组成：
1. C
2. Object-Oriented C++
3. Template
4. STL

# 02 以const、enum、inline取代#define
因为是预处理阶段做处理，编译器没做处理，**无法正确地出现编译错误**
用const double t = 1.23;就可以看到是t产生的编译错误
使用常量还可以使代码量较小，预处理器只是盲目地替换出现1.23的位置
对于class的专属常量，为了限制作用域在class内部，并防止产生多个实体，最好使用static
如果需要在编译期就使用一个class常量值，最好改用枚举enum,枚举不能用于取地址，不会为它分配额外的存储空间
对于形似函数的宏，最好改用inline的模板函数

# 03 尽可能使用const
```cpp
const* 
// 底层引用
*const
// 顶层引用：即指针本身是常量，值不能改

```
const_iterator可令函数返回常量值，减少错误
const标记成员函数的目的是明确该成员函数可作用于const对象
const和no const成员函数可重载，传入不同参数时调用不同的版本
如果需要这样做，但又不想要代码重复，可以在no const成员调用const成员函数来解决代码重复的问题
```cpp
const_cast<char&>(static_cast<const TextBlock&>(*this)[position]);
// 先确保调用的是const版本，再做去const处理

```


# 04 确定对象被使用前就已经被初始化
对于内置类型要进行手动初始化构造函数最好使用初始化列表（注意顺序），而不要在构造函数中赋值操作来初始化
--> 因为**成员初值列表可以在对象创建时直接初始化成员变量**，而不需要先调用默认构造函数再进行赋值操作，以提高性能
如果使用赋值操作初始化，首先调用默认构造函数创建对象，再调用赋值操作符进行赋值，多进行了对象的创建和销毁，增加了不必要的开销
并且成员初值列表还可以确保成员变量在对象创建时就被正确初始化，避免忘记初始化而可能导致的未定义行为
成员初值列表还可以用于初始化const成员变量和引用类型成员变量，而赋值无法做到这点

对于static对象，在跨编译单元之间的初始化次序说不确定的，C++只保证在本文件内使用之前一定被初始化
```cpp
class FileSystem{...};
FileSystem& tfs()
{
    static FileSystem fs;
    return fs;
}
// 以local static对象替换non-local static对象
```


# P2 构造/析构/赋值
# 05 了解C++默认生成的函数
如果不定义，C++会生成默认的构造函数，析构函数，拷贝赋值运算符，拷贝构造函数
但是如下情况不会生成默认拷贝赋值运算符
1. 类中含有**引用类型**的成员变量
2. 含有**const**的成员变量
3. 基类中的拷贝赋值运算符是私有成员函数

# 不想要编译器自动生成成员函数，则应该明确拒绝
可以声明为private并不予实现

# 07 为多态基类声明virtual析构函数
为了把动态绑定的派生类的析构函数一起调用，否则会内存泄漏

# 08 别让异常逃离析构函数
析构函数不要抛出异常，如果实在要抛出异常，最好使用std::abort，放在catch，把这个行为压下去
由于析构是用于清理资源和执行对象销毁前的操作的，如果析构中抛出异常，会导致对象的销毁被中断，资源无法正确释放，导致内存泄漏或其他不可预测的错误
其次，如果异常逃离析构函数，那么异常可能传播到调用析构函数的地方，可能导致更严重的问题，比如，如果析构函数是由一个容器类的析构函数调用的，那么异常将会传播到容器类的析构函数中，进而导致容器类的析构函数无法正常执行，可能导致容器内的其他对象无法正确销毁。
如果异常逃离析构函数，那么程序的异常处理机制将无法正常工作。通常，当异常发生时，程序会尝试捕获并处理异常，以保证程序的正常执行。但是，如果异常逃离析构函数，那么程序将无法捕获并处理该异常，可能导致程序崩溃或产生未定义的行为。
为了保证程序的稳定性和可靠性，不建议让异常逃离析构函数。可以在析构函数中使用try-catch块来捕获并处理异常，以确保对象的销毁过程能够正常进行，并正确释放资源。

# 09 不在构造和析构中调用vitual函数
构造一个派生类对象时，先调用基类构造函数构造基类部分，此时派生类那部分的成员变量还没有初始化，如果此时调用派生类版本的成员函数，可能会用到并未初始化的派生类部分的成员变量，导致未定义行为，因此，对于在构造函数中调用虚函数，编译器不会产生多态效果，而是调用基类版本。

析构函数：先调用派生类的析构，如果基类中调用派生类版本的virtual函数，显然导致未定义行为。

# 10 令operator=返回一个reference to *this
重载运算符时，尽量保留运算符原本的特性
为了实现连锁赋值（右结合律）
```cpp
(x = y) = z = 15;
// z = 15, x = y, x = z
// x = y返回对x的引用
```

# 11 在operator=中处理自我赋值
编译器生成的默认复制拷贝运算符函数是浅拷贝，对于指针是地址赋值
深拷贝则是：先释放原先的指针指向的内存，再开辟新内存，让指针指向新内存，内容是原指针指向的内容
```cpp
/* 对于以上代码，自我赋值会产生问题
例如：
SampleClass obj;
...
SampleClass& s = obj;
...
s = obj;
*/
// 问题在于先释放了内存,那就没法操作它了


//解决方法之一:
float* tmp = new float(*s.p);
// 用临时指针申请空间并填充内容
delete p;
p = tmp;

// 但是代码重复,有更好的办法:
SampleClass tmp(s);
swap(*this, tmp);
return *this;
// 把负担都交给了拷贝构造函数,因为如果拷贝构造函数无法执行,下面的swap就不会执行

// 当然也可以把入参由传引用改为传值,省略代码量
```

# 12 复制对象时勿忘其每一个成分
copying函数:即copy构造函数,copy assignment操作符
1. 拷贝函数要确保复制对象内"对象内的所有成员变量"及"所有base class 成分".
自定义构造函数时,如果有继承关系,要注意Base部分也要一同复制

2. 不要尝试以某个copying函数实现另一个copying函数.应该将共同机能放进第二个函数中,并由两个copying函数共同调用.
(因为可能导致无限地调用拷贝构造,最后导致栈溢出)

--> 正确做法:建立一个新的成员函数给copying函数调用,这种函数往往是private并且命名为init,从而安全地消除重复代码

# P3 资源管理
# 13 以对象管理资源
在构造函数中获取资源,在析构函数中释放资源,避免资源泄漏
考虑一个函数中：调用工厂函数得到返回的工厂对象，做完一系列操作后释放，但是在这个一系列操作中可能提前return（或许是由于软件开发过程中其他人的修改），因此要从根本上处理：把资源放进对象内，确保当控制流离开函数作用域，对象的析构函数自动释放资源，
实际的做法可以考虑用智能指针进行封装：智能指针对象析构时，会自动释放资源（当引用计数为0）
这就是所谓的**RAII思想：资源取得时机便是初始化时机**
                    **管理对象运用析构函数确保资源被释放**
需要注意，如果资源释放动作可能导致抛出异常，那么就可能无法无法正确释放资源，但是条款8规定：析构函数不要抛出异常，如果实在要抛出异常，最好使用std::abort，放在catch，把这个行为压下去
常用引用计数型智能指针
别用裸指针，容易忘记释放

# 14 在资源管理类中小心copying行为
由于有些资源不是定义在堆上的，没法用智能指针，需要自己实现资源管理类，这需要注意以下细节：
```cpp
// 比如锁定互斥量的Lock对象
class Lock{
private:
    Mutex* mutexPtr;
public:
    explicit Lock(Mutex* pm):mutexPtr(pm)
    {lock(mutexPtr);}   
    ~Lock(){unlock(mutexPtr);}  // 符合RAII
};
```

RAII对象被复制，会有问题：
对此，要么
## **禁止复制**：
将拷贝操作声明为private或者delete

## 要么**对底层资源进行引用计数**：
```cpp
// 比如锁定互斥量的Lock对象
class Lock{
private:
    std::shared_ptr<Mutex>mutexPtr;
public:
    explicit Lock(Mutex* pm):mutexPtr(pm, unlock)   // 将unlock函数作为删除器
    {
        lock(mutexPtr.get());   // get返回裸指针
    }
};
```
由于类的析构函数会自动调用其非静态成员变量的析构函数，此处就是mutexPtr的析构函数，其析构函数会在互斥量的引用计数为0时**自动调用shared_ptr的删除器（unlock函数）**

### 复制底部资源
有时复制资源管理类进行的是深拷贝。
某些标准字符串类型是由指向heap内存的指针构成（用于存放字符串的字符），这种字符串对象内含一个指针指向一块堆内存，当这种字符串对象被复制，不论指针或其所指内存都会被深拷贝。

### 转移底部资源的拥有权
有时需要确保永远只有一个RAII对象指向一个未加工资源，那么就涉及到移动。


# 15 在资源管理类中提供堆原始资源的访问
资源管理类可以防止资源泄漏，但是有时候得绕过资源管理对象直接访问原始资源。

智能指针提供了这样的接口
一方面，重载了->，*以获取内部资源
```cpp
class Font{
    ...
    public:
        FontHandle get() const {return f;}  // 显式转换函数

    private:
        FontHandle f;   // 原始资源
}
    显然如果用户API中大量需要FontHandle对象时，都得调用get()
    可以隐式转换：
    operator FontHandle() const
    {return f;}
    使得调用看起来比较自然：
    上述的隐式函数转换是一种函数语法格式，成员函数的一种，用于将本类型的函数转换成为其他类型，其中的operator相当于一个标志符，说明该是一个隐式函数转换。

    Font f(getFont());
    changeFontSize(f, newFontSize);
    // 但是显然有问题：
    Font f1(getFont());
    FontHandle f2 = f1; // 本意是拷贝Font对象，却反而将f1隐式转换为FontHandle才复制
    由于由Font对象f1管理的FontHandle对象也被f2取得，这是危险的，比如f1销毁了，f2就成了虚吊的。尽管此处是拷贝了一份。
```
提供get()方法获得裸指针并非是设计灾难，因为用户往往需要访问原始资源。

# 16 成对使用new和delete时要采取相同形式
new运算符：
1. 分配了内存
2. 针对此内存调用构造函数
delete恰恰相反

delete指针（指向的对象）的时候，一定要注意指向的是单一对象还是对象数组。因为二者内存布局不一样。显然数组所占用的内存还需要记录数组大小（以便delete时知道腰调用多少次析构函数）
--> 因此程序员需要显示地让delete知道内存中是否存在数组大小记录。
```cpp
std::string* stringPtr2 = new std::string[100];
delete [] stringPtr2;

typedef std::string AddressLines[4];
std::string* pal = new AddressLines;
// 等号右侧返回的是一个string*，就像new string[4]

// 对应：
delete [] pal;
最好不要对数组做typedef，容易忽略这个问题
```

# 17 以独立语句将newed对象置于智能指针
```cpp
// 考虑以下情形：
void processWidget(std::shared_ptr<Widget>pw, int priority);

processWidget(new Widget, priority());
// 由于Widget对象的构造函数声明为explicit，无法隐式转换，因此通过不了编译
// 必须这样写：
processWidget(std::shared_ptr<Widget>(new Widget), priority());
// 但是这种调用可能泄露资源
```
编译器在生成processWidget调用码之前，必须核算即将被传递的各个实参，其中第一个实参：
1. 执行new Widget
2. 调用shared_ptr构造函数
（3. 还有调用priority）
编译器生成的代码完成这三件事的顺序是有多种可能的，当然new Widget必然在shared_ptr之前，但是priority的调用的位置是不确定的
如果是1, 3，2的顺序执行，其中priority的调用异常，就会导致构造失败，new Widget返回的指针丢失，也就是说，在**资源创建**和**资源被转为资源管理类对象**之间可能发生异常干扰
解决办法是，把语句分开：
1. std::shared_ptr<Widget>pw(new Widgnet);
    用智能指针创建对象的语句单独一句
2. processWidget(pw, priority());
    这样调用，不会造成泄漏
因为编译器生成代码时指令乱序是针对语句内的，对于跨语句它不会这么做


# 18 让接口容易被正确使用，而不是误用
本条开始是针对软件设计与声明，以保证正确性、高效性、封装性、维护性、延展性以及协议的一致性。
function接口、class接口、template接口，每一种接口都是客户与你的代码互动的手段。
必须考虑客户可能做出什么样的错误，以日期类为例：
```cpp
Data(int month, int day, int year);
// 可能会以错误的次序传递参数
Data d(2, 30, 1995);

// 可以通过导入新类型来避免
Data d(Day(30), Month(3), Year(1995));  // 在其中做合法性检验
```
预防客户错误的另一个办法：限制类型内的操作：
比如：加上const
一个一般性准则：尽量让你的types的行为与内置types保持一致
避免无端与内置类型不兼容 --> 为了提供行为一致的接口
比如STL容器的接口就十分一致，比如每个容器都有名为size()的成员
比如之前提到的createInvestment函数，返回智能指针而不是裸指针可以避免两个用户错误的机会：忘记在最终把指针delete，或者重复释放一块资源。

shared_ptr有一个好的性质是：会自动调用它的“每个指针专属的删除器” --> 避免跨DLL错误（对象在动态链接库中被new创建，却在另一个DLL内被delte的运行时错误）shared_ptr中缺省的删除器是来自创建时的哪个DLL的delete
```cpp
如果Stock派生自Investment
std::shared_ptr<Investment>creatInvestment(){
    return std::shared_ptr<Investment>(new Stock);
    // 返回的shared_ptr可能被传递给任何其他DLL，这个指向Stock的shared_ptr会追踪记录“当Stock的引用计数为0时该调用的DLL的delete”
}

```

# 19 设计class犹如设计type



















