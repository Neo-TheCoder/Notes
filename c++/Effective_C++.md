***
前言：
学习一门语言，不只是学点语法，高效的使用也是很重要的。对于C++而言更是如此。
***
对后者：C++的有效使用有两大类的建议：
1、一般性的设计策略（两种做法，选哪种）
2、带有具体细节的特定语言特性

# P1 习惯C++

# 01 语言联邦
C++由四个次语言组成：
1. C
2. Object-Oriented C++
3. Template
4. STL

# 02 以const、enum、inline取代#define
因为是预处理阶段做处理，编译器没做处理，**无法正确地出现编译错误**
用const double t = 1.23;就可以看到是t产生的编译错误
使用常量还可以使代码量较小，预处理器只是盲目地替换出现1.23的位置
对于class的专属常量，为了限制作用域在class内部，并防止产生多个实体，最好使用static
如果需要在编译期就使用一个class常量值，最好改用枚举enum,枚举不能用于取地址，不会为它分配额外的存储空间
对于形似函数的宏，最好改用inline的模板函数

# 03 尽可能使用const
```cpp
const* 
// 底层引用
*const
// 顶层引用：即指针本身是常量，值不能改

```
const_iterator可令函数返回常量值，减少错误
const标记成员函数的目的是明确该成员函数可作用于const对象
const和no const成员函数可重载，传入不同参数时调用不同的版本
如果需要这样做，但又不想要代码重复，可以在no const成员调用const成员函数来解决代码重复的问题
```cpp
const_cast<char&>(static_cast<const TextBlock&>(*this)[position]);
// 先确保调用的是const版本，再做去const处理

```


# 04 确定对象被使用前就已经被初始化
对于内置类型要进行手动初始化构造函数最好使用初始化列表（注意顺序），而不要在构造函数中赋值操作来初始化
--> 因为成员初值列表可以在对象创建时直接初始化成员变量，而不需要先调用默认构造函数再进行赋值操作，以提高性能
如果使用赋值操作初始化，首先调用默认构造函数创建对象，再调用赋值操作符进行赋值，多进行了对象的创建和销毁，增加了不必要的开销
并且成员初值列表还可以确保成员变量在对象创建时就被正确初始化，避免忘记初始化而可能导致的未定义行为
成员初值列表还可以用于初始化const成员变量和引用类型成员变量，而赋值无法做到这点

对于static对象，在跨编译单元之间的初始化次序说不确定的，C++只保证在本文件内使用之前一定被初始化
```cpp
class FileSystem{...};
FileSystem& tfs()
{
    static FileSystem fs;
    return fs;
}
// 以local static对象替换non-local static对象
```


# P2 构造/析构/赋值
# 05 了解C++默认生成的函数
如果不定义，C++会生成默认的构造函数，析构函数，拷贝赋值运算符，拷贝构造函数
但是如下情况不会生成默认拷贝赋值运算符
1. 类中含有**引用类型**的成员变量
2. 含有**const**的成员变量
3. 基类中的拷贝赋值运算符是私有成员函数

# 不想要编译器自动生成成员函数，则应该明确拒绝
可以声明为private并不予实现

# 07 为多态基类声明virtual析构函数
为了把动态绑定的派生类的析构函数一起调用，否则会内存泄漏

# 08 别让异常逃离析构函数
析构函数不要抛出异常，如果实在要抛出异常，最好使用std::abort，放在catch，把这个行为压下去
由于析构是用于清理资源和执行对象销毁前的操作的，如果析构中抛出异常，会导致对象的销毁被中断，资源无法正确释放，导致内存泄漏或其他不可预测的错误
其次，如果异常逃离析构函数，那么异常可能传播到调用析构函数的地方，可能导致更严重的问题，比如，如果析构函数是由一个容器类的析构函数调用的，那么异常将会传播到容器类的析构函数中，进而导致容器类的析构函数无法正常执行，可能导致容器内的其他对象无法正确销毁。
如果异常逃离析构函数，那么程序的异常处理机制将无法正常工作。通常，当异常发生时，程序会尝试捕获并处理异常，以保证程序的正常执行。但是，如果异常逃离析构函数，那么程序将无法捕获并处理该异常，可能导致程序崩溃或产生未定义的行为。
为了保证程序的稳定性和可靠性，不建议让异常逃离析构函数。可以在析构函数中使用try-catch块来捕获并处理异常，以确保对象的销毁过程能够正常进行，并正确释放资源。

# 09 不在构造和析构中调用vitual函数
构造一个派生类对象时，先调用基类构造函数构造基类部分，此时派生类那部分的成员变量还没有初始化，如果此时调用派生类版本的成员函数，可能会用到并未初始化的派生类部分的成员变量，导致未定义行为，因此，对于在构造函数中调用虚函数，编译器不会产生多态效果，而是调用基类版本。

析构函数：先调用派生类的析构，如果基类中调用派生类版本的virtual函数，显然导致未定义行为。

# 10 令operator=返回一个reference to *this
重载运算符时，尽量保留运算符原本的特性
为了实现连锁赋值（右结合律）
```cpp
(x = y) = z = 15;
// z = 15, x = y, x = z
// x = y返回对x的引用
```

# 11 在operator=中处理自我赋值
编译器生成的默认复制拷贝运算符函数是浅拷贝，对于指针是地址赋值
深拷贝则是：先释放原先的指针指向的内存，再开辟新内存，让指针指向新内存，内容是原指针指向的内容
```cpp
/* 对于以上代码，自我赋值会产生问题
例如：
SampleClass obj;
...
SampleClass& s = obj;
...
s = obj;
*/
// 问题在于先释放了内存,那就没法操作它了


//解决方法之一:
float* tmp = new float(*s.p);
// 用临时指针申请空间并填充内容
delete p;
p = tmp;

// 但是代码重复,有更好的办法:
SampleClass tmp(s);
swap(*this, tmp);
return *this;
// 把负担都交给了拷贝构造函数,因为如果拷贝构造函数无法执行,下面的swap就不会执行

// 当然也可以把入参由传引用改为传值,省略代码量
```

# 12 复制对象时勿忘其每一个成分
copying函数:即copy构造函数,copy assignment操作符
1. 拷贝函数要确保复制对象内"对象内的所有成员变量"及"所有base class 成分".
自定义构造函数时,如果有继承关系,要注意Base部分也要一同复制

2. 不要尝试以某个copying函数实现另一个copying函数.应该将共同机能放进第二个函数中,并由两个copying函数共同调用.
(因为可能导致无限地调用拷贝构造,最后导致栈溢出)

--> 正确做法:建立一个新的成员函数给copying函数调用,这种函数往往是private并且命名为init,从而安全地消除重复代码

# P3 资源管理
# 13 以对象管理资源
在构造函数中获取资源,在析构函数中释放资源,避免资源泄漏
考虑一个函数中：调用工厂函数得到返回的工厂对象，做完一系列操作后释放，但是在这个一系列操作中可能提前return（或许是由于软件开发过程中其他人的修改），因此要从根本上处理：把资源放进对象内，确保当控制流离开函数作用域，对象的析构函数自动释放资源，
实际的做法可以考虑用智能指针进行封装：智能指针对象析构时，会自动释放资源（当引用计数为0）
这就是所谓的**RAII思想：资源取得时机便是初始化时机**
                    **管理对象运用析构函数确保资源被释放**
需要注意，如果资源释放动作可能导致抛出异常，那么就可能无法无法正确释放资源，但是条款8规定：析构函数不要抛出异常，如果实在要抛出异常，最好使用std::abort，放在catch，把这个行为压下去
常用引用计数型智能指针
别用裸指针，容易忘记释放

# 14 在资源管理类中小心copying行为
由于有些资源不是定义在堆上的，没法用智能指针，需要自己实现资源管理类，这需要注意以下细节：
```cpp
// 比如锁定互斥量的Lock对象
class Lock{
private:
    Mutex* mutexPtr;
public:
    explicit Lock(Mutex* pm):mutexPtr(pm)
    {lock(mutexPtr);}   
    ~Lock(){unlock(mutexPtr);}  // 符合RAII
};
```

RAII对象被复制，会有问题：
对此，要么
## **禁止复制**：
将拷贝操作声明为private或者delete

## 要么**对底层资源进行引用计数**：
```cpp
// 比如锁定互斥量的Lock对象
class Lock{
private:
    std::shared_ptr<Mutex>mutexPtr;
public:
    explicit Lock(Mutex* pm):mutexPtr(pm, unlock)   // 将unlock函数作为删除器
    {
        lock(mutexPtr.get());   // get返回裸指针
    }
};
```
由于类的析构函数会自动调用其非静态成员变量的析构函数，此处就是mutexPtr的析构函数，其析构函数会在互斥量的引用计数为0时**自动调用shared_ptr的删除器（unlock函数）**

### 复制底部资源
有时复制资源管理类进行的是深拷贝。
某些标准字符串类型是由指向heap内存的指针构成（用于存放字符串的字符），这种字符串对象内含一个指针指向一块堆内存，当这种字符串对象被复制，不论指针或其所指内存都会被深拷贝。

### 转移底部资源的拥有权
有时需要确保永远只有一个RAII对象指向一个未加工资源，那么就涉及到移动。


# 15 在资源管理类中提供堆原始资源的访问
资源管理类可以防止资源泄漏，但是有时候得绕过资源管理对象直接访问原始资源。

智能指针提供了这样的接口
一方面，重载了->，*以获取内部资源
```cpp
class Font{
    ...
    public:
        FontHandle get() const {return f;}  // 显式转换函数

    private:
        FontHandle f;   // 原始资源
}
    显然如果用户API中大量需要FontHandle对象时，都得调用get()
    可以隐式转换：
    operator FontHandle() const
    {return f;}
    使得调用看起来比较自然：



```






# 16 成对使用new和delete时要采取相同形式





