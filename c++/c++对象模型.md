# 前言
在结构化语言中，函数调用背后有着堆栈建立、参数排列、返回地址、堆栈清除等幕后机制，还算能理解。
由于面向对象语言，编译器帮我们做了太多操作，让人困惑。比如：构造函数、析构、虚函数、继承、多态，有时编译器还会合成一些额外的函数，有时编译器又会扩张我们的函数内容，放进更多的操作，有时往对象加入填充字节，影响sizeof的结果。

## 什么是C++对象模型
1. 语言中直接支持面向对象程序设计的部分
2. 对于各种支持的底层实现机制
“不变量”概念：c++ class中的完整virtual在编译期就固定了，运行时无法动态增加 --> 使得虚拟调用有快速的dispatch结果，但牺牲了运行期的弹性
了解底层实现模型，才能写出高效的C++代码
本书还旨在去除一些对于C++的错误认识。
以静态初始化为例：
一个类在main函数外面被初始化，这就是通过**静态初始化**做到的，它的实现依赖于开发环境对此的支持属于哪一个层级。

# 第一章 关于对象
C++相比C提供了面向对象的思维方式，相比C语言完全可以用对象封装，甚至可以利用模板来实现类型参数。
## 那么C++加上封装的代价是什么？
以class Point3d为例，相比c语言版本结构体的实现，并没有增加成本，而成员函数并不会在对象中产生函数实体（**每一个非inline成员函数只产生一个函数实体**，而拥有0个或者1个定义的inline函数则会在其每一个使用者身上产生一个函数实体），
实际上，**C++在布局以及存取时间上主要的额外负担是由virtual引起的：**
1. 虚函数（用于实现有效率的执行期绑定）
2. 虚基类（用于实现多次在继承体系中出现的基类，有一个单一而被共享的实体）
此外，还有**多重继承下的额外负担**，发生在：一个派生类和其第二或后继的基类的转换之间（为了应对命名冲突和二义性）
一般来说，并无天生理由说C++程序一定比C庞大或者迟缓

## 1.1 C++对象模式
C++中，**数据成员有两种情况：static、非static**
**三种成员函数：static、非static、virtual**

```cpp
class Point{
public:
    Point{float xval};
    virtual ~Point();
    float x() const;
    static int PointCount();

protected:
    virtual ostream& print(ostream &os) const;
    float _x;
    static int _point_count;
};

```



先考虑**简单对象模型**

### 简单对象模型




















