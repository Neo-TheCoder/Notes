# 前言
在结构化语言中，函数调用背后有着堆栈建立、参数排列、返回地址、堆栈清除等幕后机制，还算能理解。
由于面向对象语言，编译器帮我们做了太多操作，让人困惑。比如：构造函数、析构、虚函数、继承、多态，有时编译器还会合成一些额外的函数，有时编译器又会扩张我们的函数内容，放进更多的操作，有时往对象加入填充字节，影响sizeof的结果。

## 什么是C++对象模型
1. 语言中直接支持面向对象程序设计的部分
2. 对于各种支持的底层实现机制
“不变量”概念：c++ class中的完整virtual在编译期就固定了，运行时无法动态增加 --> 使得虚拟调用有快速的dispatch结果，但牺牲了运行期的弹性
了解底层实现模型，才能写出高效的C++代码
本书还旨在去除一些对于C++的错误认识。
以静态初始化为例：
一个类在main函数外面被初始化，这就是通过**静态初始化**做到的，它的实现依赖于开发环境对此的支持属于哪一个层级。

# 第一章 关于对象
C++相比C提供了面向对象的思维方式，相比C语言完全可以用对象封装，甚至可以利用模板来实现类型参数。
## 那么C++加上封装的代价是什么？
以class Point3d为例，相比c语言版本结构体的实现，并没有增加成本，而成员函数并不会在对象中产生函数实体（**每一个非inline成员函数只产生一个函数实体**，而拥有0个或者1个定义的inline函数则会在其每一个使用者身上产生一个函数实体），
实际上，**C++在布局以及存取时间上主要的额外负担是由virtual引起的：**
1. 虚函数（用于实现有效率的执行期绑定）
2. 虚基类（用于实现多次在继承体系中出现的基类，有一个单一而被共享的实体）
此外，还有**多重继承下的额外负担**，发生在：一个派生类和其第二或后继的基类的转换之间（为了应对命名冲突和二义性）
一般来说，并无天生理由说C++程序一定比C庞大或者迟缓

## 1.1 C++对象模式
C++中，**数据成员有两种情况：static、非static**
**三种成员函数：static、非static、virtual**

```cpp
class Point{
public:
    Point(float xval);
    virtual ~Point();
    float x() const;
    static int PointCount();

protected:
    virtual ostream& print(ostream &os) const;
    float _x;
    static int _point_count;
};
```

### 简单对象模型
图表示Point对象本体全都是存储地址，每一个地址指向了某一成员变量、或者是成员函数。好处是避免了因为成员变量有不同的类型，因而需要不同的存储空间。
访问成员是通过指针数组的索引来实现的。

这个模型实际根本不会用，但是思想被应用到C++的指向成员的指针观念中。

### 表格驱动对象模型
把所有与members相关的信息抽出来，分别放在：
1. data member table
2. member function table
class object本身持有的是指向这两个表格的指针

这个模型实际也不会用，但是思想被应用到C++的虚函数中。

### c++对象模型
C++之父的C++对象模型是简单对象模型的派生：把非静态数据成员放在每一个class object内，静态置于之外，所有函数（静态与非静态）也是放在class object之外。
而虚函数的实现：
1. 每个class产生一个**虚函数表（vtbl）**：存放指向虚函数的指针
2. 每一个class object持有一个**指向相关的虚函数表的指针（vptr）**
虚函数表的指针是由**构造函数、析构函数、拷贝运算符来自动完成的**
每一个class所关联的type_info object（即用于支持RTTI的、存储类型信息的对象）也是靠虚函数表来指示，通常由虚函数表的第一个位置来指示。

该模型这样设计的好处是：考虑**占据空间和存取数据的效率**
缺点是：类定义如有改动，需要重新编译

#### 加上继承
虚继承：比如钻石继承的情况下，基类只会有一个实体
如何存储继承信息？搞一个基类表怎么样，类对象本身只持有一个基类表指针？
缺点是随着继承深度增加，“间接性”也增加，即：孙子类取得爷爷类的成员要两次间接存取。如果让派生类对应的基类表记录所有层级的基类，访问就快了，但是付出了空间上的代价。
C++2.0中的设计是：在class object中为每一个有关联的virtual base class添加一个指针。

### 对象模型如何影响程序
不同的对象模型，会导致：
1. 现有的程序代码必须修改
2. 必须加入新的程序代码
因为要考虑C++代码转变为机器码（这个转换是和模型相关的）
举例：
```cpp
X foobar(){
    X xx;
    X *px = new X;

    // foo()是一个虚函数
    xx.foo();
    px->foo();

    delete px;
    return xx;
}

/* ！以下形成引用入参的内部逻辑是：RVO：Return Value Optimization
    编译优化技术，减少不必要的复制和构造过程
*/

// 会被转换为：
void foobar(X &_result){
    // 构造_result，用于取代原来的局部变量 xx
    _result.X::X(); // 构造函数

    // X *px = new X;的展开
    px = _new(sizeof(X));
    if( px!= 0)
        px->X::X();

    // xx.foo()的展开 调用对象的方法，做不到调用虚函数
    // 以_result取代xx
    foo(&_result);

    // 使用虚函数机制，扩展px->foo()
    (*px->vtbl[2])(px)  // 调用虚函数表对应的虚函数

    // 扩展delete px;
    if( px!= 0 ){
        (*px->vtbl[1])(px); // destructor   析构也需要调用虚函数表
        _delete(px);
    }

    // 不需使用named return statement
    // 不需要摧毁局部变量
    return;
}

```

## 1.2 关键词所带来的差异
```cpp
// 无法确定是生命还是函数调用（直到看到1024这个整数）
int (*pf)(1024);

int(*pq)(); // 声明而非调用
```
当语言无法区分语句是一个声明还是一个表达式，那么就需要一个超越语言范围的规则。

### 策略性正确的struct
```cpp
// struct
struct mumble{
    char pc[1]; // 放在尾端，实现数据大小可变
};

struct mumble *pmumb1 = (struct mumble*)malloc(sizeof(struct mumble) + strlen(string) + 1);
strcpy(&memble.pc, string);

// 如果采用class 可能指定不同的访问权限区域，可能由其他类派生而来，有虚函数
class stumble{
public:
    // ...
protected:
    // ...
private:
    // ...
    char pc[1];
}
// 
```
C++中，处于同一个访问区域的数据，必定要保证以其声明次序出现在内存布局中，然而放置在多个访问区域中的各笔数据，排序次序是不定的。
```cpp
class stumble{
public:
    // ...
protected:
    // ...
private:
    char pc[1]; // 需要位于最后
};
```
如果想让一个复杂的C++ class的某部分数据，使它拥有C声明的那种样子，这部分最好抽取出来成为一个独立的struct声明，操作如下：
```cpp
struct C_point{...};
class Point: public C_point{...};
// 利用派生

// 于是C和C++两种用法都可获得支持：
extern void draw_line(Point, Point);
extern "C" void draw_rect(C_point, C_point);
draw_line(Point(0, 0), Point(0, 0));
draw_rect(Point(0, 0), Point(0, 0));
```
在C++中，extern "C"是一个关键字组合，它用于告诉编译器使用C语言的命名和调用约定来编译某段代码块或函数，并避免C++的名称修饰（name mangling）。
C++编译器为了支持函数重载和命名空间等特性，会对函数和全局变量等进行名称修饰，即在函数或变量名前添加一些符号或编码，以体现它们的类型和特征。这种名称修饰导致C++编译生成的符号与C语言不兼容，无法直接调用。
因此，当需要在C++代码中调用C语言编写的代码时（比如使用C语言编写的库），就需要使用extern "C"来告诉编译器不对特定的代码块进行名称修饰，以便在C++代码中正确调用C语言代码。
由于某些C++编译器在支持虚函数的机制中对于class的继承布局做了一些改变，因而，**组合，而非继承，才是把C、C++组合在一起的唯一可行方法**。
```cpp
// 组合而非继承
struct C_point(...);
class Point{
public:
    operator C_point(){return _c_point;}
    // ...
private:
    C_point _c_point;
};
```
C struct中的合理用途，是当你要传递“一个复杂的class object的全部或部分”到某个C函数中去，struct声明可以将数据封装起来，并保证拥有与C兼容的空间布局（条件是组合而非继承，如果是继承而非组合，编译器会决定是否应该有额外的data members被安插到base struct subobject中）。


## 1.3 对象的差异
c++程序设计模型直接支持三种**程序设计典范**
### 程序模型
是指面向过程

### 抽象数据类型模型
抽象指的是：和一组public接口一起提供，而运算的定义的是隐藏的
比如string的==方法或者赋值，就隐藏了细节

### 面向对象模型
比如先设计一个抽象基类，然后相关的派生类由此派生而来。

混用不同的程序设计模型会有问题：
比如：
```cpp
// 想要以基类实例实现多态时：

Base b;
class Derived1: public Base{...};
Derived1 d1;
d1 = b;
b.check_in();   // 调用的还是基类的方法

// 多态应该通过基类的指针或者引用来实现
Base& b2 = d1;
b2.check_in();  // 调用的是派生类的方法

```














