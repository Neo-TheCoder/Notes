# 前言
在结构化语言中，函数调用背后有着堆栈建立、参数排列、返回地址、堆栈清除等幕后机制，还算能理解。
由于面向对象语言，编译器帮我们做了太多操作，让人困惑。比如：构造函数、析构、虚函数、继承、多态，有时编译器还会合成一些额外的函数，有时编译器又会扩张我们的函数内容，放进更多的操作，有时往对象加入填充字节，影响sizeof的结果。

## 什么是C++对象模型
1. 语言中直接支持面向对象程序设计的部分
2. 对于各种支持的底层实现机制
“不变量”概念：c++ class中的完整virtual在编译期就固定了，运行时无法动态增加 --> 使得虚拟调用有快速的dispatch结果，但牺牲了运行期的弹性
了解底层实现模型，才能写出高效的C++代码
本书还旨在去除一些对于C++的错误认识。
以静态初始化为例：
一个类在main函数外面被初始化，这就是通过**静态初始化**做到的，它的实现依赖于开发环境对此的支持属于哪一个层级。

# 第一章 关于对象
C++相比C提供了面向对象的思维方式，相比C语言完全可以用对象封装，甚至可以利用模板来实现类型参数。
## 那么C++加上封装的代价是什么？
以class Point3d为例，相比c语言版本结构体的实现，并没有增加成本，而成员函数并不会在对象中产生函数实体（**每一个非inline成员函数只产生一个函数实体**，而拥有0个或者1个定义的inline函数则会在其每一个使用者身上产生一个函数实体），
实际上，**C++在布局以及存取时间上主要的额外负担是由virtual引起的：**
1. 虚函数（用于实现有效率的执行期绑定）
2. 虚基类（用于实现多次在继承体系中出现的基类，有一个单一而被共享的实体）
此外，还有**多重继承下的额外负担**，发生在：一个派生类和其第二或后继的基类的转换之间（为了应对命名冲突和二义性）
一般来说，并无天生理由说C++程序一定比C庞大或者迟缓

## 1.1 C++对象模式
C++中，**数据成员有两种情况：static、非static**
**三种成员函数：static、非static、virtual**

```cpp
class Point{
public:
    Point(float xval);
    virtual ~Point();
    float x() const;
    static int PointCount();

protected:
    virtual ostream& print(ostream &os) const;
    float _x;
    static int _point_count;
};
```

### 简单对象模型
图表示Point对象本体全都是存储地址，每一个地址指向了某一成员变量、或者是成员函数。好处是避免了因为成员变量有不同的类型，因而需要不同的存储空间。
访问成员是通过指针数组的索引来实现的。

这个模型实际根本不会用，但是思想被应用到C++的指向成员的指针观念中。

### 表格驱动对象模型
把所有与members相关的信息抽出来，分别放在：
1. data member table
2. member function table
class object本身持有的是指向这两个表格的指针

这个模型实际也不会用，但是思想被应用到C++的虚函数中。

### c++对象模型
C++之父的C++对象模型是简单对象模型的派生：把非静态数据成员放在每一个class object内，静态置于之外，所有函数（静态与非静态）也是放在class object之外。
而虚函数的实现：
1. 每个class产生一个**虚函数表（vtbl）**：存放指向虚函数的指针
2. 每一个class object持有一个**指向相关的虚函数表的指针（vptr）**
虚函数表的指针是由**构造函数、析构函数、拷贝运算符来自动完成的**
每一个class所关联的type_info object（即用于支持RTTI的、存储类型信息的对象）也是靠虚函数表来指示，通常由虚函数表的第一个位置来指示。

该模型这样设计的好处是：考虑**占据空间和存取数据的效率**
缺点是：类定义如有改动，需要重新编译

#### 加上继承
虚继承：比如钻石继承的情况下，基类只会有一个实体
如何存储继承信息？搞一个基类表怎么样，类对象本身只持有一个基类表指针？
缺点是随着继承深度增加，“间接性”也增加，即：孙子类取得爷爷类的成员要两次间接存取。如果让派生类对应的基类表记录所有层级的基类，访问就快了，但是付出了空间上的代价。
C++2.0中的设计是：在class object中为每一个有关联的virtual base class添加一个指针。

### 对象模型如何影响程序
不同的对象模型，会导致：
1. 现有的程序代码必须修改
2. 必须加入新的程序代码
因为要考虑C++代码转变为机器码（这个转换是和模型相关的）


## 1.2 关键词所带来的差异
```cpp
// 无法确定是生命还是函数调用（直到看到1024这个整数）
int (*pf)(1024);
```










