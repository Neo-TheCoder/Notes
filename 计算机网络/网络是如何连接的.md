网络是由很多计算机等设备相互连接组成的，因此在通信的过程中需要确定正确的通信对象，并将请求和响应发送给它们。请求和响应在传递的过程中可能会丢失或损坏，因此这些情况也必须要考虑到。所以说，我们需要一种机制，无论遇到任何情况都能够将请求和响应准确无误地发送给对方。由于请求和响应都是由 0 和 1 组成的数字信息，所以可以说，我们需要的是一种能够将数字信息搬运到指定目的地的机制。

这种机制是由操作系统中的网络控制软件，以及交换机、路由器等设备分工合作来实现的，它的基本思路是将数字信息分割成一个一个的小块，然后装入一些被称为“包”（Packet）的容器中来运送。“包”这个词大家可能在用手机的时候经常会碰到 ，但在这里类似于邮政和快递中的概念。大家可以这样理解：包相当于信 件或者包裹，而交换机和路由器则相当于邮局或快递公司的分拣处理区。包的头部存有目的地等控制信息，通过许多交换机和路由器的接力，就可以根据控制信息对这些包进行分拣，然后将它们一步一步地搬运到目的地。无论是家庭和公司里的局域网，还是外面的互联网，它们只是在规模上有所不同，基本的机制都是相同的。

# 每章概要

## 第一章 web浏览器
从输入网址开始（URL）：
http://www.lab.glasscom.com/sample1.html
浏览器按照规则解析URL，然后生成请求消息<请给我sample1.html这一文件中储存的网页数据>，浏览器将请求消息发送给Web服务器，准确来说，是委托操作系统中的网络控制软件将消息发送给服务器。

## 第二章 协议栈、网卡
探索搬运数据的机制。网络控制软件叫做协议栈，它会将从浏览器接收到的消息打包，然后加上目的地址等控制信息（类似于把信装进信封，然后写上收信人的地址，此外，还有其他功能：发生通信错误时重新发送包，调节数据发送的效率），然后，协议栈会把包交给网卡（负责以太网或者无线网络通信的硬件），网卡将包转换为电信号并通过网线发送出去，包就因此进入网络。

## 第三章 集线器、交换机、路由器
客户端计算机可以通过家庭或者公司的局域网接入互联网，也可以直接接入互联网
网卡发送的包会经过交换机等设备，到达用来接入互联网的路由器，路由器的后面就是互联网，网络运营商负责将包送到目的地

## 第四章 接入网、网络运营商
紧接着，数据从路由器（用于接入互联网）出发，进入了互联网的内部，互联网的入口线路称为接入网，这种通信线路具体来说有：电话线、ISDN、ADSL、光线、专线等。接入网连接到签约的网络运营商，并接入被称为接入点（Point of Presence）的设备。
接入点的实体是一台转为运营商设计的路由器（类比离你家最近的邮局，从各个邮筒收集来的信件在邮局进行分拣，然后送往全国甚至全世界）接入点的后面就是互联网的骨干部分：**其中存在很多运营商和大量的路由器，相互连接组成网，网络包在其中经过若干路由器的接力，发送到目标Web服务器上**
家用和公司局域网一般采用以太网进行连接
互联网中除了以太网还会使用别的技术来传送网络包

## 第五章 防火墙、缓存服务器
通过骨干网，网络包最终到达了Web服务器所在的局域网，接着会遇到防火墙，它会检查进入的包，然后网络包可能会遇到缓存服务器，因为网页数据中有一部分是可复用的，访问网页数据时先查找缓存服务器，而且大型网站可能还配备负载均衡器，将Web服务器设置为分布式的。

## 第六章 Web服务器
网络包到达Web服务器后，数据被**解包**还原为原始的请求消息，然后交给Web服务器程序，这个解包也是由操作系统中的协议栈（网络控制软件）来完成的。然后Web服务器程序分析请求消息的含义，根据指示将数据装入响应消息中，发回给客户端。
响应到达客户端后，浏览器将数据在屏幕显示出来。

# 第一章 浏览器内部
## 1.1 生成http请求消息
浏览器是具备多种客户端功能的综合性客户端软件
访问Web服务器时，URL是以"http:"开头的，访问FTP服务器时用"ftp:"，是根据协议来的
不同的服务器程序使用不同的端口号，以示区分
URL的组成：
https:// Web服务器域名 + 端口号 + 文件路径名（文件路径 + 文件名）

### 1.1.2 浏览器先要解析URL
解析完才能生成发送给Web服务器的请求消息

### 1.1.3 也可以省略文件名
这样的话，访问时就是找默认文件

### 1.1.4 HTTP的基本思路
很简单：
1. 客户端向服务器发送请求消息（包含操作对象以及如何操作，即URI统一资源标识符 + 方法（比如GET（获取数据）、POST（表单，将用户输入数据一并发送）、HEAD等））
2. Web服务器收到请求并解析，执行相应操作，将结果存放在响应消息中，响应消息的开头有状态码，表示操作的成功与否

### 1.1.5 生成HTTP请求消息
有严格的格式要求，消息头 + 消息体

### 1.1.6 发送请求后会收到响应
响应消息特有的状态码和响应短语

## 1.2 向DNS服务器查询Web服务器的IP地址
### 1.2.1 IP地址的基本知识
生成HTTP消息后，要**委托操作系统将消息发送**给Web服务器
因此必须先查询网址中，服务器域名对应的IP地址

小型如公司内部的局域网都是基于TCP/IP的思路来设计的：
即：**一些小的子网（用集线器链接起来的几台计算机），通过路由器连接起来组成一个大的网络**
集线器和路由器都是对包进行转发的设备，集线器分为中继式集线器、交换式集线器
家用集线器内置了集线器功能
在网络中，所有设备都会被分配一个地址，类比现实生活中的“XX号XX室”。“号”对应的数字是分配给整个子网的（--> 网络号），“室”对应的数字是分配给子网中的计算机的（--> 主机号），加起来就是**IP地址**
#### 消息在物理上具体是怎么发送的呢？
发送的消息首先经过子网中的集线器，转发到距离最近的路由器上，然后路由器根据消息的目的地判断下一个路由器的位置，将消息转发到下一个路由器，接着，消息再次经过子网内的集线器被转发到下一个路由器，不断重复这样的过程，消息最终就到了目的地。PS：数据是以包的形式传送的。
（不能存在有两台设备使用相同的IP地址的情况）

实际的IP地址：
32位，是网络号 + 主机号
具体结构是子网掩码确定的
比如：
10.11.12.13/255.255.255.0（前24位是网络号）
10.11.12.13/24
如果主机号部分的比特全为0，则该地址表示的不是单独一台计算机，而是代表整个子网
如果主机号部分的比特全为1，则该地址表示对整个子网进行广播

### 1.2.2 域名和IP地址并用的理由
TCP/IP网络是通过IP地址来确定通信对象的
要记住一长串数字显然是困难的
如果Web服务器使用了虚拟主机功能，则无法通过IP地址来访问
使用一串数字通信效率是比较高的，便于（路由器）处理
人使用域名，路由器使用IP地址，显然需要一个机制来实现通过名称来查询IP地址，或者反过来，这个机制就是DNS

### 1.2.3 Socket库提供查询IP地址的功能
查询IP地址只要询问最近的DNS服务器即可
我们的计算机必然有DNS客户端（DNS解析器，实际上是一段程序，包含在操作系统的Socket库）
通过编程来向DNS服务器发出查询很简单，就是调调接口
解析器得到DNS发来的IP地址后，写入浏览器指定的内存地址，然后浏览器再从该内存地址取出IP地址

### 1.2.5 解析器的内部原理
浏览器会调用socket提供的gethostbyname接口，内部大致实现如下：
生成发送给DNS服务器的查询消息
向DNS服务器发送查询消息 --> 调用到操作系统内部的协议栈（发送UDP消息， ）
接收DNS服务器返回的响应消息
从响应消息中取出IP地址，存放到内存地址
返回应用程序

要访问的Web服务器只有已经在DNS服务器上注册，才能找到记录。

## 1.3 全世界DNS服务器的大接力
### 1.3.1 DNS服务器的基本工作
来自DNS客户端的查询消息：
1. 域名
2. class，用于识别网络，但是实际上永远填写的是代表互联网的IN
3. 记录类型
当类型为A,表示域名对应的是IP地址
B，则是邮件服务器

### 1.3.2 域名的层次结构
显然，互联网如此多的服务器是需要许多的DNS服务器来记录的，这些信息是分布式保存的。
域名是有层次结构的：
www.lab.glasscom.com，越靠右层级越高
一个域的信息是作为一个整体存放在DNS服务器中的
一个域是不可分割的，但是可以创建下级域
假设公司的域是example.co.jp，可以在这个域的下面创建两个子域，sub1.example.co.jp，sub2.example.co.jp，这两个不同的事业部。
www.nikkeibp.co.jp这个域名，jp表示分配给日本的域，下一级是日本国内进行分类的域，再下一级是分配给某个公司的，www就是服务器的名称。

### 1.3.3 寻找相应的DNS服务器并获取IP地址
重点：将负责管理下级域的DNS服务器的IP地址注册到上级DNS服务器中，以此类推，例如：负责管理lab.glasscom.com域的DNS服务器的IP地址需要注册到glasscom.com域的DNS服务器中，因此，我们才可以通过上级DNS服务器查询出下级DNS服务器的IP地址。
实际上还有根域的设定，www.lab.glasscom.com.，最后的.就是表示根域，但是常常忽略。根域的DNS服务器信息（其IP极少，而且几乎不变）要保存在互联网中所有的DNS服务器中。
客户端首先访问最近的DNS服务器，如果没有记录的话，就去根域找，根域发现www.lab.glasscom.com这个域名属于com域，然后去找com问问看。

### 1.3.4 通过缓存加快DNS服务器的响应
实际情况中，一台DNS服务器可以管理多个域的信息。DNS服务器有缓存功能。缓存也是有有效期的，因为注册信息可能发生改变。

## 1.4 委托协议栈发送消息
### 1.4.1 数据收发操作概览
操作系统如何收发数据？
（TCP）服务器一方创建socket，（进入等待状态）等待客户端向该socket建立连接，然后就可以收发数据了。
简单理解就是：
1. 创建socket
2. 将管道连接到服务器端的socket
3. 收发数据
4. 断开管道并删除socket
其中，**这些操作都是协议栈去做的**
```cpp
<内存地址> = gethostbyname("www.lab.glasscom.com");
// 1 准备
fd = socket(ipv4, <流模式>);    // 和DNS服务器交互
// 2 连接
connect(<fd>，<ip地址>，<端口号>, ...);   // 和DNS服务器交互
// 3 发送
write(<fd>，<发送数据>，<发送数据长度>);    // 和操作系统协议栈交互

// 3 接收
<接收缓冲区地址> = read(<描述符>，<接收缓冲区>);  // 和WEB服务器交互 读取数据到应用程序内部的内存空间

// 4 断开
close(<描述符>);    // 和WEB服务器交互
```
因为通信关系可能存在多个，因此要fd来区分。
connect时还需要填写端口号，IP地址具体到网络的某台计算机，端口具体到计算机的某个套接字。
**准确来说，IP地址不是分配给每一台设备的，而是分配给设备中安装的网络硬件的，一台设备如果安装了多个网络硬件，那么就会有多个IP地址**
服务器上所使用的端口号是根据应用的种类事先规定好的：Web是80号端口，电子邮件是25号端口。
即：浏览器访问Web服务器时使用的80号端口，是规定好的。
端口号和IP地址都是由IANA组织统一管理的。
既然确定连接对象的套接字需要使用端口号，那么服务器也得知道客户端的套接字才行吧？
--> 实际上，客户端在创建套接字时，协议栈会为这个套接字**随便分配一个端口号**，当协议栈进行连接操作时，会将这个随便分配的端口号通知服务器。
HTTP协议规定，当Web服务器发送完响应消息后，应该主动执行断开操作。
实际负责收发消息的是：
**协议栈、网卡驱动 和 网卡**，只有这3者相互配合，数据才能够在网络中流动起来。


# 第二章 用电信号传输TCP/IP数据――――探索协议栈和网卡
本章重点：
1. 创建套接字
2. 连接服务器
3. 收发数据
4. 从服务器断开连接并删除套接字
5. IP与以太网的包收发操作（协议栈会与网卡进行配合，将数据切分成小块并封装成网络包，再将网络包转换成电信号/光信号发送出去）
6. 用UDP协议收发数据的操作（TCP协议具有丢失重发功能，但UDP也有其必要性）

### 2.1.1 协议栈的内部结构
图2.1 利用网络发送数据的分层结构
1. 网络应用程序（调用Socket库），如浏览器、邮件客户端、
2. 操作系统 包含协议栈 其中涉及TCP（建立连接） / UDP（不需要连接） / IP（用于传送网络包，确定路由，涉及ICMP（Internet Control Message Protocol）、ARP（Address Resolution Protocol：将IP地址解析为相应的物理MAC地址））
浏览器、邮件等一般的应用程序都是使用TCP收发数据的，像DNS等收发较短的控制数据使用UDP
在互联网上传送数据时，数据会被切分成一个一个的网络包，而将网络包发送给通信对象的操作就是由IP来负责的。此外，IP中还包括ICMP协议和ARP协议。ICMP用于告知网络包传送过程中产生的错误以及各种控制消息，ARP 用于根据IP地址查询相应的以太网MAC地址（符合IEEE规格的局域网设备都使用同一格式的地址）。

1. 网卡驱动程序（用于控制网卡）
2. 硬件：网卡

### 2.1.2 套接字的实体就是通信控制信息
毫无疑问，协议栈内部有一块用于存放控制信息的内存空间（通信对象的IP地址、端口号、通信操作的进行状态等），这些控制信息是协议栈在执行操作时需要参阅的
套接字中还要记录是否已经收到响应，以及超时时间
Windows系统中可以使用netstat显示套接字内容（可以理解为通信关系的展现）
（此处的套接字不是socket的概念）
协议 本地地址 外部地址 状态 PID
TCP 0.0.0.0:125 0.0.0.0:0 LISTENING 884
0.0.0.01表示还没有开始通信，没有绑定IP地址
PID列表示使用该套接字的程序
举例说明：
协议 本地地址 外部地址 状态 PID
TCP 10.10.1.16:1031 10.10.1.80:139 ESTABLISHED 4
表示：PID为4的程序正在使用IP地址为10.10.1.16的网卡与IP地址为10.10.1.18的对象进行通信，并且，对方使用的是139端口，是Windows文件服务器使用的端口。
另一行表示PID为984的程序正在135端口等待另一方的连接，其中本地IP地址和远程IP地址都是0.0.0.0，这表示通信还没开始，IP地址不确定。

### 2.1.3 调用socket时的操作
由于套接字中记录了通信双方的信息以及通信处于怎样的状态，所以只要通过描述符确定了相应的套接字，协议栈就能够获取所有的相关信息，这样一来，应用程序就不需要每次都告诉协议栈应该和谁进行通信了。

## 2.2 连接服务器
### 2.2.1 连接是什么意思
**连接实际上是通信双方交换控制信息，在套接字中记录这些必要信息并准备数据收发的一连串操作**
控制信息：用于控制数据收发操作所需的一些信息（比如IP地址和端口号），连接过程中还会分配一块用于临时存放要收发的数据的内存空间
如同打电话，通电话之前的准备自然而然地称为连接

### 2.2.2 负责保存控制信息的头部
控制信息实际上大体可以分为两类：
#### 1 客户端和服务器相互联络时交换的控制信息
不仅连接时需要，数据收发和断开连接操作，整个通信过程都需要，这些内容在TCP协议规格中进行了定义，位于TCP头部
TCP头部20个字节：发送方端口号、接收方端口号、序号、ACK号、数据偏移量、保留字段、控制位、窗口、校验和、紧急指针、可选字段
**整个数据包：1、以太网和IP的控制信息、2、TCP的控制信息、数据块**
在连接、断开等没有应用程序数据的情况下，双方只传递控制信息

客户端和服务器在通信中会将必要的信息记录在头部并相互确认，例如下面这样：
发送方：“开始数据发送。”
接收方：“请继续。”
发送方：“现在发送的是 ×× 号数据。”
接收方：“×× 号数据已收到。”

#### 控制信息还有另外一类，那就是保存在套接字中，用来控制协议栈操作的信息。
应用程序**传递来的信息**以及从通信对象**接收到的信息**都会保存在这里，还有收发数据操作的**执行状态**等信息也会保存在这里，协议栈会根据这些信息来执行每一步的操作。我们可以说，套接字的控制信息和协议栈的程序本身其实是一体的，因此，“协议栈具体需要哪些信息”会根据协议栈本身的实现方式不同而不同 ，但这并没有什么问题。因为协议栈中的控制信息通信对方是看不见的，只要在通信时按照规则将必要的信息写入头部，客户端和服务器之间的通信就能够得以成立。
例如，Windows 和 Linux 操作系统的内部结构不同，协议栈的实现方式不同，必要的控制信息也就不同。但即便如此，两种系统之间依然能够互相通信，同样地，计算机和手机之间也能够互相通信。正如前面所说，协议栈的实现不同，因此我们无法具体说明协议栈里到底保存了哪些 控制信息，但可以用命令来显示一些重要的套接字控制信息，这些信息无论何种操作系统的协议 栈都是共通的，通过理解这些重要信息，就能够理解协议栈的工作方式了。

### 2.2.3 连接操作的实际过程
connect（< 描述符 >, < 服务器 IP 地址和端口号 >, …）
上面的调用提供了服务器的 IP 地址和端口号，这些信息会传递给协议栈中的 TCP 模块。然后，**TCP模块会与该IP地址对应的对象，也就是与服务器的TCP模块交换控制信息**，这一交互过程包括下面几个步骤。
首先，客户端先创建一个包含表示开始数据收发操作的控制信息的头部。
如表 2.1 所示，头部包含很多字段， 这里要关注的重点是**发送方和接收方的端口号**。
到这里，客户端（发送方）的套接字就准确找到了服务器 （接收方）的套接字，也就是搞清楚了我应该连接哪个套接字。
然后，我们将**头部中的控制位的SYN比特设置为1，可以认为它表示连接**。此外还需要设置适当的序号和窗口大小，这一点我们会稍后详细讲解。
**当TCP头部创建好之后，接下来TCP模块会将信息传递给IP模块并委托它进行发送**。
IP模块执行网络包发送操作后，网络包就会通过网络到达服务器，然后服务器上的IP模块会将接收到的数据传递给TCP模块，服务器的TCP模块根据TCP头部中的信息找到端口号对应的套接字，
也就是说，从处于等待连接状态的套接字中找到与TCP头部中记录的端口号相同的套接字就可以了。当找到对应的套接字之后，套接字中会写入相应的信息，并将状态改为正在连接。上述操作完成后，服务器的TCP模块会返回响应，这个过程和客户端一样，需要在TCP头部中设置发送方和接收方端口号以及SYN比特。
此外，**在返回响应时还需要将ACK控制位设为1，这表示已经接收到相应的网络包**。因为网络中经常会发生错误，网络包也会发生丢失，因此双方在通信时必须相互确认网络包是否已经送达 ，而设置 ACK 比特就是用来进行这一确认的。接下来，服务器TCP模块会将TCP头部传递给IP模块，并委托IP模块向客户端返回响应。
建立连接后，协议栈的连接操作结束，控制流程被交回到应用程序。

## 2.3 收发数据
### 2.3.1 将HTTP请求消息交给协议栈
数据收发操作是从应用程序调用write,将要发送的数据交给协议栈开始的。协议栈并不关心应用程序发送的数据，因为对它来说只是一定长度的二进制字节序列。
协议栈发送数据时，是**先把数据存放在内部的发送缓冲区**，并等待应用程序的下一段数据。意义在于：一次将多少数据交给协议栈是由应用程序自行决定的，协议栈并不能控制这一行为，**如果协议栈一收到数据就马上发送，就可能发送大量的小包，导致网络效率下降，因此需要在数据积累到一定量时再发送，具体是多少就取决于操作系统了**
累积多少再发送有以下几个决定因素：
1. 每个网络包能容纳的数据长度：协议栈会根据一个叫做MTU（Max Transmission Unit最大传输单元）的参数来判断 MTU表示一个网络包的最大长度，在以太网中一般是1500字节（这个数字是包含了头部的总长度，因此最大数据长度为1500 - 头部 = MSS，Max Segment Size，最大分段大小，TCP和IP的头部加起来一般是40字节，那么MSS就是1460）当从应用程序收到的数据长度超过或者接近 MSS 时再发送出去，就可以避免发送大量小包的问题了。

报头/起始帧分界符SFD + MAC头部 + [ IP头部 + TCP头部 + 数据 ] + FCS（帧校验序列）

2. 另一个判断要素是**时间**，当应用程序发送数据频率不高时，如果总是等待缓冲区数据长度到MSS时再发送，就可能因为等待时间太长而造成发送延迟，因此应该果断发送，协议栈内会有一个计数器，经过一定时间（ms级别）后，就把网络包发送出去
这两个因素需要取得一定的平衡，这是由操作系统中协议栈的开发者决定的，当然，**协议栈也给应用程序保留了控制发送时机的余地**，比如如果指定“不等待填满缓冲区直接发送”，则协议栈就会按照要求直接发送数据。像浏览器这种会话型的应用程序在向服务器发送数据时，等待填满缓冲区导致延迟会产生很大影响，因此一般会使用直接发送的选项。

### 2.3.2 对较大的数据进行拆分
HTTP 请求消息一般不会很长，一个网络包就能装得下，但如果其中要提交表单数据，长度就可能超过一个 网络包所能容纳的数据量，比如在博客或者论坛上发表一篇长文就属于这种情况。
这种情况下，发送缓冲区中的数据就会超过 MSS 的长度，这时我们当然不需要继续等待后面的数据了。**发送缓冲区中的数据会被以 MSS 长度为单位进行拆分，拆分出来的每块数据会被放进单独的网络包中**。
根据发送缓冲区中的数据拆分的情况，当判断需要发送这些数据时，就在每一块数据前面加上TCP头部， 并根据套接字中记录的控制信息标记发送方和接收方的端口号，然后交给IP模块来执行发送数据的操作

### 2.3.3 使用 ACK 号确认网络包已收到
TCP模块拆分数据时，会计算偏移量，记录在TCP头部，通过“序号”字段就可以得到偏移。
（序号表示的是字节序号）
例如：
数据包1：序号1       长度1460字节   对应接收方的ACK号 1461
数据包2：序号1461    长度1460字节   对应接收方的ACK号 2921
数据包3：序号2921    长度1460字节   对应接收方的ACK号 4381

接收方可以检查收到的网络包有没有遗漏：
接收方接收了上一次收到的数据包的第1460字节，那么接下来收到序号为1461的包，是正常的，但是如果收到的数据包序号为2921，那就说明遗漏了，
如果确认没有遗漏，接收方会将到目前为止接收到的数据长度加起来，计算出一共已经收到了多少个字节，然后将这个数值写入 TCP头部的ACK号中发送给发送方。
简单来说，发送方说的是“现在发送的是从第 ×× 字节开始的部分，一共有××字节哦！”。**而接收方则回复说，“到第 ×× 字节之前的数据我已经都收到了哦！”**这个返回ACK号的操作被称为**确认响应**，通过这样的方式，发送方就能够确认对方到底收到了多少数据。
PS：接收方返回ACK号时，还需要把控制位中的ACK比特设置为1，
实际通信中，序号并非从1开始，而是**随机值**，如果从1开始则容易被攻击。
因此在建立连接的过程中，有一个将SYN控制位设为1并发送给服务器的操作，就是在这一步将序号的初始值告知对方的。实际上，在将SYN设为1的同时，还需要同时设置序号字段的值，而这里的值就代表序号的初始值。
我们在前面讲连接操作的时候说过SYN为1表示进行连接，这是因为**将SYN设为1并告知初始序号**这一操作仅在连接过程中出现，因此发送SYN为1的网络包就表示发起连接的意思。实际上，SYN是 Synchronize（同步）的缩写，意思是通过告知初始序号使通信双方保持步调一致，以便完成后续的数据收发检查，这才是SYN原本的含义。
要注意实际TCP数据收发是双向的。
首先客户端先计算出一个序号，然后将序号和数据一起发送给服务器，服务器收到之后会计算ACK号并返回给客户端;
相反地，服务器也需要先计算出另一个序号，然后将序号和数据一起发送给客户端，客户端收到之后计算ACK号并返回给服务器。 此外，如图所示，客户端和服务器双方都需要各自计算序号，因此双方需要在连接过程中互相告知自己计算的序号初始值。
TCP采用这样的方式确认对方是否收到了数据，在得到对方确认之前，发送过的包都会保存在发送缓冲区中。如果对方没有返回某些包对应的ACK号，那么就重新发送这些包。
**通过这一机制，我们可以确认接收方有没有收到某个包，如果没有收到则重新发送，这样一来，无论网络中发生任何错误，我们都可以发现并采取补救措施（重传网络包）**。反过来说，有了这一机制，我们就不需要在其他地方对错误进行补救了。
**网卡、集线器、路由器都没有错误补偿机制，一旦检测到错误就直接丢弃相应的包。应用程序也是一样，因为采用TCP传输，即便发生一些错误对方最终也能够收到正确的数据，所以应用程序只管自顾自地发送这些数据就好了。**
**不过，如果发生网络中断、服务器宕机等问题，那么无论 TCP 怎样重传都不管用。这种情况下，无论如何尝试都是徒劳，因此 TCP会在尝试几次重传无效之后强制结束通信，并向应用程序报错。**

### 2.3.4 根据网络包平均往返时间调整 ACK 号等待时间
超时重传的时间要设置得合理：
因为ACK号返回变慢往往是由网络拥塞引起的，出现多余的重传会导致本来就很拥塞的网络雪上加霜。
TCP采用了动态调整 等待时间的方法，这个等待时间是根据 ACK号返回所需的时间来判断的。具体来说，TCP会在发送数据的 过程中持续测量ACK号的返回时间，如果 ACK号返回变慢，则相应延长等待时间；相对地，如果 ACK号马上就能返回，则相应缩短等待时间。
由于计算机的时间测量精度较低，ACK 返回时间过短时无法被正确测量，因此等待时间有一个最小值，这个值在每个操作系统上不一样， 基本上是在 0.5 秒到 1 秒之间。

### 2.3.5 使用窗口有效管理ACK号
使用滑动窗口的机制来实现高效的通信（无发完一个包就等待一个ACK号的方式是最简单的，但是什么都不做显然太浪费了）
**发完一个包后，不等待ACK号返回，而是直接发送后续的一系列包，把等待ACK号的时间利用起来**
如果不等返回ACK号就连续发送包，就有可能会出现发送包的频率超过接收方处理能力的情况。
具体解释一下。当接收方的TCP收到包后，会先将数据存放到接收缓冲区中。然后，接收方需要计算ACK号，将数据块组装起来还原成原本的数据并传递给应用程序，如果这些操作还没完成下一个包就到了也不用担心，因为下一个包也会被暂存在接收缓冲区中。**如果数据到达的速率比处理这些数据并传递给应用程序的速率还要快，那么接收缓冲区中的数据就会越堆越多，最后就会溢出。**缓冲区溢出之后，后面的数据就进不来了，因此接收方就收不到后面的包了，这就和中途出错的结果是一样的，也就意味着超出了接收方处理能力。
我们可以通过下面的方法来避免这种情况的发生。首先，**接收方需要告诉发送方自己最多能接收多少数据，然后发送方根据这个值对数据发送操作进行控制，这就是滑动窗口方式的基本思路。**

**能够接收的最大数据量称为窗口大小** ，它是TCP调优参数中非常有名的一个。

### 2.3.6 ACK与窗口的合并
要提高收发数据的效率，还需要考虑另一个问题，那就是返回ACK号和更新窗口的时机。如果假定这两个参数是相互独立的，分别用两个单独的包来发送，结果会如何呢？
首先，什么时候需要更新窗口大小呢？当收到的数据刚刚开始填入缓冲区时，其实没必要每次都向发送方更新窗口大小，因为只要发送方在每次发送数据时减掉已发送的数据长度就可以自行计算出当前窗口的剩余长度。
因此，**更新窗口大小的时机应该是接收方从缓冲区中取出数据传递给应用程序的时候。这个操作是接收方应用程序发出请求时才会进行的，而发送方不知道什么时候会进行这样的操作**，因此当接收方将数据传递给应用程序，导致接收缓冲区剩余容量增加时，**就需要告知发送方，这就是更新窗口大小的时机**。
那么ACK号又是什么情况呢？当接收方收到数据时，如果确认内容没有问题，就应该向发送方返回ACK号，因此我们可以认为收到数据之后马上就应该进行这一操作。
如果将前面两个因素结合起来看，首先，发送方的数据到达接收方，**在接收操作完成之后就需要向发送方返回ACK号**，而再经过一段时间，**当数据传递给应用程序之后才需要更新窗口大小**。但如果根据这样的设计来实现，每收到一个包，就需要向发送方分别发送ACK号和窗口更新这两个单独的包。这样一来，接收方发给发送方的包就太多了，导致网络效率下降。

因此，接收方在发送ACK号和窗口更新时，并不会马上把包发送出去，而是会**等待一段时间，在这个过程中很有可能会出现其他的通知操作，这样就可以把两种通知合并在一个包里面发送了**。举个例子，在等待发送ACK号的时候正好需要更新窗口，这时就可以把ACK号和窗口更新放在一个包里发送，从而**减少包的数量**。**当需要连续发送多个ACK号时，也可以减少包的数量，这是因为ACK号表示的是已收到的数据量，也就是说，它是告诉发送方目前已接收的数据的最后位置在哪里，因此当需要连续发送ACK号时，只要发送最后一个ACK号就可以了，中间的可以全部省略**。**当需要连续发送多个窗口更新时也可以减少包的数量，因为连续发生窗口更新说明应用程序连续请求了数据，接收缓冲区的剩余空间连续增加**。这种情况和ACK号一样，可以省略中间过程，只要发送最终的结果就可以了。

### 2.3.7 接收HTTP响应消息
到这里，我们已经讲解完协议栈接到浏览器的委托后发送 HTTP 请求消息的一系列操作过程了。 不过，浏览器的工作并非到此为止。发送 HTTP 请求消息后，接下来还需要等待 Web 服务器返回响应消息。对于响应消息，浏览器需要进行接收操作，这一操作也需要协议栈的参与。
首先，浏览器在委托协议栈发送请求消息之后，会调用read程序来获取响应消息。然后，控制流程会通过read转移到协议栈，然后协议栈会执行接下来的操作。和发送数据一样，接收数据也需要将数据暂存到接收缓冲区中，这里的操作过程如下。首先，协议栈尝试从接收缓冲区中取出数据并传递给应用程序，但这个时候请求消息刚刚发送出去，响应消息可能还没返回。响应消息的返回还需要等待一段时间，因此这时接收缓冲区中并没有数据，那么接收数据的操作也就无法继续。这时，协议栈会将应用程序的委托，也就是从接收缓冲区中取出数据并传递给应用程序的工作暂时挂起 ，等服务器返回的响应消息到达之后再继续执行接收操作。

## 2.4 从服务器断开并删除套接字
### 2.4.1 数据发送完毕后断开连接
毫无疑问，收发数据结束的时间点应该是应用程序判断所有数据都已经发送完毕的时候。这时，数据发送完毕的一方会发起断开过程，但不同的应用程序会选择不同的断开时机。
以Web为例，浏览器向Web服务器发送请求消息，Web服务器再返回响应消息，这时收发数据的过程就全部结束了，服务器一方会发起断开过程。当然，可能也有一些程序是客户端发送完数据就结束了，不用等服务器响应，这时客户端会先发起断开过程。这一判断是应用程序作出的，**协议栈在设计上允许任何一方先发起断开过程**。
这里讲的是HTTP1.0的情形，在 HTTP1.1中，服务器返回响应消息之后，客户端还可以继续发起下一个请求消息，如果接下来没有请求要发送了，客户端一方会发起断开过程。无论哪种情况，完成数据发送的一方会发起断开过程，这里我们以服务器一方发起断开过程为例来进行讲解。
首先，**服务器一方的应用程序会调用Socket库的close程序。然后，服务器的协议栈会生成包含断开信息的TCP头部，具体来说就是将控制位中的 FIN比特设为1**。接下来，协议栈会委托IP模块向客户端发送数据。同时，服务器的套接字中也会记录下断开操作的相关信息。

### 2.4.2 删除套接字
和服务器的通信结束之后，用来通信的套接字也就不会再使用了，这时我们就可以删除这个套接字了。不过，套接字并不会立即被删除，而是会等待一段时间之后再被删除。**等待这段时间是为了防止误操作**。

## 2.5 IP 与以太网的包收发操作
### 2.5.1 包的基本知识
TCP模块在执行连接、收发、断开等各阶段操作时，都需要委托IP模块将数据封装成包发送给通信对象。
我们先来介绍一下关于网络包的一些基本知识。首先，**包是由头部和数据两部分构成的**。
**头部包含目的地址等控制信息**，大家可以把它理解为快递包裹的面单；头部后面就是委托方要发送给对方的数据，也就相当于快递包裹里的货物。

路由器和集线器是两种不同的转发设备，它们在传输网络包时有着各自的分工:
**（1）路由器根据目标地址判断下一个路由器的位置**
**（2）集线器在子网中将网络包传输到下一个路由**

### 2.5.2 包收发操作概览
凡是局域网所使用的头部都叫MAC头部，但其内容根据局域网的类型有所不同。此外，对于除局域网之外的其他通信技术，还有不同名称 的各种头部，但它们只是名字不叫MAC头部而已，承担的作用和MAC头部是相同的。
IP模块负责添加如下两个头部。
（1）MAC头部：以太网用的头部，包含MAC地址
（2）IP头部：IP用的头部，包含IP地址

### 2.5.3 生成包含接收方IP地址的IP头部
路由表举例：
| Network Destination | Netmask | Gateway | Interface | Metric |
| --- | --- | --- | --- | --- |
| 0.0.0.0 | 0.0.0.0 | 10.10.1.1 | 10.10.1.16 | 25 |
| 192.168.1.0 | 255.255.255.0 | 10.10.1.2 | 10.10.1.16 | 2 |
| 255.255.255.255 | 255.255.255.255 | 10.10.1.16 | 10.10.1.16 | 1 |
Gateway和Interface相同，意味着不需要经过路由器转发，表示当前路由器与网络直接连接，可以直接向目标IP地址发送包
若二者不同，则表示目标网络需要通过路由器的该接口发送给网关路由器
（路由器有多个interface，每个interface是由一个IP地址指示）
IP头部有协议号信息，表示包的内容是来自哪个模块

### 2.5.4 生成以太网用的MAC头部
IP头部中接收方IP地址表示网络包的目的地
但是以太网中不能直接这样填写，而是要依靠匹配的方式才能在以太网中把包发往目的地
MAC头部结构：
接收方MAC地址(48bit) + 发送方MAC地址(48bit) + 以太类型(16bit，用于标识是IP协议、还是ARP协议的包，ARP协议：Address Resolution Protocol，目标IP地址解析为对应的MAC地址)
MAC地址是一个整体，在网卡生产时写入ROM

实际上，只有在操作系统启动过程中对网卡进行初始化的时候才会读取MAC地址，读取出来之后会存放在内存中，每次执行收发操作时实际上使用的是内存中的值。此外，**读取MAC地址的操作是由网卡驱动程序来完成的，因此网卡驱动程序也可以不从网卡ROM中读取地址，而是将配置文件中设定的MAC地址拿出来放到内存中并用于设定MAC头部，或者也可以通过命令输入MAC地址**。
接收方MAC地址需要查看路由表，但是路由表中的表项信息也是要通过某一操作才能得到的，那就是ARP查询。


### 2.5.5 通过ARP查询目标路由器的MAC地址
ARP：地址解析协议
在以太网中广播：即：把包发给连接在同一以太网中的所有设备，ARP协议就是发广播包，询问某一个设备IP地址对应的MAC地址是多少。
ARP的结果会放在ARP缓存中，真正发包时先查询ARP缓存。
MAC地址的写法：00-80-C2-...（6字节）
或者用':'分隔
而实际情况中，IP地址是经常变化的，因此ARO缓存经过一段时间就会删除，也就几分钟。
**打包的工作是由IP模块负责的。**尽管MAC头部是以太网所需的内容，并非IP的职责范围，但是这样做是有意义的，因为如果在把数据交给网卡之前，IP模块就能够完成整个打包工作，那么网卡直接发送就可以了，对于除了IP以外的数据包也是一样，网卡直接发就行了，这样网卡就可以支持各种类型的包的处理，

### 2.5.6 以太网的基本知识
以太网是为多台计算机能够自由、廉价地通信而设计的通信技术，本质上就是一根网线，收发器这个设备则是把不同网线之间的信号连接起来。
网络中的一台计算机发送信号时，信号就会通过网线流过整个网络，最终到达所有设备，好比一个大房间里一个人说话所有人都能听见。那么这样的话就没法区分是想和谁说话了，于是就有了数据包MAC头部信息加MAC地址，通过以太网类型就可以判断出包里面装了什么类型的内容。
以太网的3个基本性质：
1. 将包发送到MAC头部的接收方MAC地址代表的目的地
2. 用发送方MAC地址识别发送方
3. 用以太类型识别包的内容
PS：这些性质也适用于无线局域网，只不过无线局域网没有以太类型，而是有一个类似功能的参数代替
（路由器等网络设备的网卡是集成在设备内部的）
以太网和IP一样，不关心网络包的实际内容，也就是说，以太网的收发操作和TCP的工作阶段无关

### 2.5.7 将IP包转换成电或光信号发送出去
IP生成的网络包只是内存中的数字信息，把数字信息转换成电信号才能在网线上传输  --> 负责执行这一操作的是**网卡**，在网卡驱动程序的帮助之下
网卡有哪些构成要素呢？
具体看图
计算机启动操作系统时，网卡驱动程序会对硬件做初始化操作（比如硬件错误检查、初始设置），然后硬件才可用。MAC模块中会做设置MAC（Media Access Control）地址的操作。
生产网卡时，会往网卡的ROM写入世界唯一的MAC地址，被网卡驱动读取。
MAC地址真正生效的时刻是在网卡驱动程序初始化时在MAC模块中设置的那个地址。

### 2.5.8 给网络包再加3个控制数据
网卡驱动从IP模块获取包后，复制到网卡内的缓冲区，然后向MAC模块发送“发送包的命令”
**MAC模块做了什么**：将包从缓冲区取出，在开头加上**报头和起始帧分界符（SFD）**，在末尾加上用于检测错误的**帧检验序列（FCS）**（将包从头到尾的内容作为输入，传入一个公式得来，类似于CRC校验码）。
（PS：数据包和数据帧其实是一回事）
报头：0，1交替出现的比特序列，占据56位。用于确定包的读取时机，起始帧分界符最后两个比特为1，网卡把这里作为包的起始位置
电信号表达数字信息，就是让0，1表示特定的电压和电流，实际情况中只有电压变化才能发觉比特的界限    --> 需要将时钟信号叠加进去

### 2.5.9 向集线器发送网络包
网卡加上SFD、FCS之后就可以把包通过网线发送出去了，方式有两种：
1. 集线器的半双工模式（同一时刻只能发送或者接收）
为了避免信号碰撞，要先检查网线中是否有别的设备发送的信号，等它发完了再发
将数字信息转为电信号的速率就是网络的传输速率
**PHY（MAU）模块功能就是对MAC模块产生的信号进行格式转换（转成可在网线中传输的格式）**
PHY模块还要监控线路是否有信号进来，没有才能发送，两台设备间的网线不能超过100米（双绞线，而光纤可以更长），这样发生错误的可能性小，即便发生错误，协议栈还有TCP兜底
若发生了信号碰撞，则通信无意义，等待时间是必须错开的，它是根据MAC地址生成的随机数算出来的，重试10次就报告通信错误

2. 交换机的全双工模式（发送和接收同时进行）
第三章介绍

### 2.5.10 接收返回包
既然使用集线器的半双工以太网中，信号会到达连接在集线器的所有设备，接收操作的第一步就是不管三七二十一把信号收进来。
网卡通知计算机是利用了**中断机制**，计算机持续执行别的任务，收到网卡的通知才处理。
具体：网卡向扩展总线中的中断信号线发送信号，该信号线通过计算机中的中断控制器连接到CPU。当产生中断信号时，**CPU会暂时挂起正在处理的任务，切换到操作系统中的中断处理程序**。然后，中断处理程序会调用网卡驱动，控制网卡执行相应的接收操作。
中断是有编号的，网卡在安装的时候就在硬件中设置了中断号，**在中断处理程序中则将硬件的中断号和相应的驱动程序绑定**。
那么网卡发起中断时，就会自动调用网卡驱动了。
网卡驱动被中断处理程序调用后，会从网卡缓冲区取出收到的包，通过MAC头部中的以太类型字段判断协议类型：IP协议、IPX/SPX、AppleTalk等，也就是交给对应的协议栈

### 2.5.11 将服务器的相应包从IP传递给TCP
网卡驱动将包交给TCP/IP协议栈来处理：
IP模块先开始工作，检查IP头部，查看接收方IP地址，如果server返回的包的接收方IP地址和客户端网卡的地址一致就可以接收了。
如果client收到不属于自己的包，会通过ICMP消息告知发送方，具体是Destination unreachable。
如果接收方IP地址正确，这个包会被接收，然后IP模块把数据包还原成原始的包（**因为局域网中只能传输小包，将大的包分片处理**，IP头部有标记，属于同一个包的分片具有相同的ID，再加上偏移量就可以还原）。
然后就是TCP模块的工作了，
**TCP模块会根据IP头部中的接收方和发送方IP地址，以及TCP头部中的接收方和发送方端口号来查找对应的套接字**。找到对应的套接字之后，就可以根据套接字中记录的通信状态，执行相应的操作了。例如，如果包的内容是应用程序数据，则返回确认接收的包，并将数据放入缓冲区，等待应用程序来读取；如果是建立或断开连接的控制包，则返回相应的响应控制包，并告知应用程序建立和断开连接的操作状态。

严格来说，TCP模块和IP模块有各自的责任范围，TCP头部属于TCP的责任范围，而IP头部属于IP模块的责任范围。根据这样的逻辑， 当包交给TCP模块之后，TCP 模块需要查询 IP 头部中的接收方和发送方 IP 地址来查找相应的套接字，这个过程就显得有点奇怪。因为 IP头部是IP模块负责的，TCP 模块去查询它等于是越权了。
如果要避免越权，应该对两者进行明确的划分，IP模块只向TCP模块传递TCP头部以及它后面的数据，而对于IP头部中的重要信息，即接收方和发送方的IP地址，则由IP模块以附加参数的形式告知TCP模块。然而，如果根据这种严格的划分来开发程序的话，IP模块和TCP模块之间的交互过程必然会产生成本，而且 IP 模块和 TCP 模块进行类似交互的场景其实非常多，总体的交互成本就会很高，程序的运行效率就会下降。因此，就像之前提过的一样，不妨将责任范围划分得宽松一些，**将 TCP 和 IP 作为一个整体来看待，减少不必要的交互**，所谓的严格划分就是只有IP模块能读取IP信息，然后传给TCP模块，那不如直接让TCP模块取得，这样可以带来更大的灵活性。此外，关于为什么查找套接字同时需要接收方和发送方的 IP 地址和端口号，我们会在第 6 章介绍端口号机制时一起讲解。

## 2.6 UDP协议的收发操作
有些应用程序不使用TCP协议而是使用UDP协议,比如向DNS服务器查询IP地址
TCP的复杂是为了将数据高效且可靠地发送给对方,可靠就意味着得确认对方是否收到我们发送的数据,如果没有就得**重发**
最简单的方法就是把数据全部发送完毕后让接收方返回一个接收确认,没收到的话就全部重发,别像TCP那样管理发送和确认的进度
如果漏了一个包就重发,怎么看都很低效,因此要避免重发已经送达的包,而只发出错或者未送达的包     -->     TCP的复杂正是因为这一点

但是比如数据很短的情况下,一个包就能装下,也不用考虑哪个包未送达的情况了,就不需要TCP的复杂机制了,也不用建立和断开连接的控制包了,并且发送数据时对端一般也都会回复,就不用专门的接收确认包了

### 2.6.2 控制用的短数据
以上场景就适合UDP,DNS查询等交换控制信息一般一个包的大小就完事了.
UDP不建立/断开连接,直接在应用程序获取的数据前面加上UDP头部,然后交给IP发送就行了
**接收:只要根据IP头部中的接收方和发送方IP地址,以及UDP头部中的接收方和发送方端口号,找到相应的套接字并将数据交给相应的应用程序就可以了**
遇到错误或者丢包都完全不管
由于出错时,对端自然收不到消息,**应用程序自然会注意到**,就会重发(由于这样的操作不复杂,也不会增加应用程序的负担)

UDP可发送数据最大长度：IP包的最大长度 - IP头部 - UDP头部
而MTU、MSS是基于以太网和通信线路上网络包的最大长度来计算的
而UDP最大数据长度则单纯是长度的相减：65536 - 20 -8 65507（由于超过了以太网和通信线路上网络包的最大长度要让IP模块分片之后再传输）
**UDP头部**：8个字节：发送方端口号、接收方端口号、数据长度、校验和（都是16bit）

### 2.6.3 音频和视频数据
























