网络是由很多计算机等设备相互连接组成的，因此在通信的过程中需要确定正确的通信对象，并将请求和响应发送给它们。请求和响应在传递的过程中可能会丢失或损坏，因此这些情况也必须要考虑到。所以说，我们需要一种机制，无论遇到任何情况都能够将请求和响应准确无误地发送给对方。由于请求和响应都是由 0 和 1 组成的数字信息，所以可以说，我们需要的是一种能够将数字信息搬运到指定目的地的机制。

这种机制是由操作系统中的网络控制软件，以及交换机、路由器等设备分工合作来实现的，它的基本思路是将数字信息分割成一个一个的小块，然后装入一些被称为“包”（Packet）的容器中来运送。“包”这个词大家可能在用手机的时候经常会碰到 ，但在这里类似于邮政和快递中的概念。大家可以这样理解：包相当于信 件或者包裹，而交换机和路由器则相当于邮局或快递公司的分拣处理区。包的头部存有目的地等控制信息，通过许多交换机和路由器的接力，就可以根据控制信息对这些包进行分拣，然后将它们一步一步地搬运到目的地。无论是家庭和公司里的局域网，还是外面的互联网，它们只是在规模上有所不同，基本的机制都是相同的。

# 每章概要

## 第一章 web浏览器
从输入网址开始（URL）：
http://www.lab.glasscom.com/sample1.html
浏览器按照规则解析URL，然后生成请求消息<请给我sample1.html这一文件中储存的网页数据>，浏览器将请求消息发送给Web服务器，准确来说，是委托操作系统中的网络控制软件将消息发送给服务器。

## 第二章 协议栈、网卡
探索搬运数据的机制。网络控制软件叫做协议栈，它会将从浏览器接收到的消息打包，然后加上目的地址等控制信息（类似于把信装进信封，然后写上收信人的地址，此外，还有其他功能：发生通信错误时重新发送包，调节数据发送的效率），然后，协议栈会把包交给网卡（负责以太网或者无线网络通信的硬件），网卡将包转换为电信号并通过网线发送出去，包就因此进入网络。

## 第三章 集线器、交换机、路由器
客户端计算机可以通过家庭或者公司的局域网接入互联网，也可以直接接入互联网
网卡发送的包会经过交换机等设备，到达用来接入互联网的路由器，路由器的后面就是互联网，网络运营商负责将包送到目的地

## 第四章 接入网、网络运营商
紧接着，数据从路由器（用于接入互联网）出发，进入了互联网的内部，互联网的入口线路称为接入网，这种通信线路具体来说有：电话线、ISDN、ADSL、光线、专线等。接入网连接到签约的网络运营商，并接入被称为接入点（Point of Presence）的设备。
接入点的实体是一台转为运营商设计的路由器（类比离你家最近的邮局，从各个邮筒收集来的信件在邮局进行分拣，然后送往全国甚至全世界）接入点的后面就是互联网的骨干部分：**其中存在很多运营商和大量的路由器，相互连接组成网，网络包在其中经过若干路由器的接力，发送到目标Web服务器上**
家用和公司局域网一般采用以太网进行连接
互联网中除了以太网还会使用别的技术来传送网络包

## 第五章 防火墙、缓存服务器
通过骨干网，网络包最终到达了Web服务器所在的局域网，接着会遇到防火墙，它会检查进入的包，然后网络包可能会遇到缓存服务器，因为网页数据中有一部分是可复用的，访问网页数据时先查找缓存服务器，而且大型网站可能还配备负载均衡器，将Web服务器设置为分布式的。

## 第六章 Web服务器
网络包到达Web服务器后，数据被**解包**还原为原始的请求消息，然后交给Web服务器程序，这个解包也是由操作系统中的协议栈（网络控制软件）来完成的。然后Web服务器程序分析请求消息的含义，根据指示将数据装入响应消息中，发回给客户端。
响应到达客户端后，浏览器将数据在屏幕显示出来。

# 第一章 浏览器内部
## 1.1 生成http请求消息
浏览器是具备多种客户端功能的综合性客户端软件
访问Web服务器时，URL是以"http:"开头的，访问FTP服务器时用"ftp:"，是根据协议来的
不同的服务器程序使用不同的端口号，以示区分
URL的组成：
https:// Web服务器域名 + 端口号 + 文件路径名（文件路径 + 文件名）

### 1.1.2 浏览器先要解析URL
解析完才能生成发送给Web服务器的请求消息

### 1.1.3 也可以省略文件名
这样的话，访问时就是找默认文件

### 1.1.4 HTTP的基本思路
很简单：
1. 客户端向服务器发送请求消息（包含操作对象以及如何操作，即URI统一资源标识符 + 方法（比如GET（获取数据）、POST（表单，将用户输入数据一并发送）、HEAD等））
2. Web服务器收到请求并解析，执行相应操作，将结果存放在响应消息中，响应消息的开头有状态码，表示操作的成功与否

### 1.1.5 生成HTTP请求消息
有严格的格式要求，消息头 + 消息体

### 1.1.6 发送请求后会收到响应
响应消息特有的状态码和响应短语

## 1.2 向DNS服务器查询Web服务器的IP地址
### 1.2.1 IP地址的基本知识
生成HTTP消息后，要**委托操作系统将消息发送**给Web服务器
因此必须先查询网址中，服务器域名对应的IP地址

小型如公司内部的局域网都是基于TCP/IP的思路来设计的：
即：**一些小的子网（用集线器链接起来的几台计算机），通过路由器连接起来组成一个大的网络**
集线器和路由器都是对包进行转发的设备，集线器分为中继式集线器、交换式集线器
家用集线器内置了集线器功能
在网络中，所有设备都会被分配一个地址，类比现实生活中的“XX号XX室”。“号”对应的数字是分配给整个子网的（--> 网络号），“室”对应的数字是分配给子网中的计算机的（--> 主机号），加起来就是**IP地址**
#### 消息在物理上具体是怎么发送的呢？
发送的消息首先经过子网中的集线器，转发到距离最近的路由器上，然后路由器根据消息的目的地判断下一个路由器的位置，将消息转发到下一个路由器，接着，消息再次经过子网内的集线器被转发到下一个路由器，不断重复这样的过程，消息最终就到了目的地。PS：数据是以包的形式传送的。
（不能存在有两台设备使用相同的IP地址的情况）

实际的IP地址：
32位，是网络号 + 主机号
具体结构是子网掩码确定的
比如：
10.11.12.13/255.255.255.0（前24位是网络号）
10.11.12.13/24
如果主机号部分的比特全为0，则该地址表示的不是单独一台计算机，而是代表整个子网
如果主机号部分的比特全为1，则该地址表示对整个子网进行广播

### 1.2.2 域名和IP地址并用的理由
TCP/IP网络是通过IP地址来确定通信对象的
要记住一长串数字显然是困难的
如果Web服务器使用了虚拟主机功能，则无法通过IP地址来访问
使用一串数字通信效率是比较高的，便于（路由器）处理
人使用域名，路由器使用IP地址，显然需要一个机制来实现通过名称来查询IP地址，或者反过来，这个机制就是DNS

### 1.2.3 Socket库提供查询IP地址的功能
查询IP地址只要询问最近的DNS服务器即可
我们的计算机必然有DNS客户端（DNS解析器，实际上是一段程序，包含在操作系统的Socket库）
通过编程来向DNS服务器发出查询很简单，就是调调接口
解析器得到DNS发来的IP地址后，写入浏览器指定的内存地址，然后浏览器再从该内存地址取出IP地址

### 1.2.5 解析器的内部原理
浏览器会调用socket提供的gethostbyname接口，内部大致实现如下：
生成发送给DNS服务器的查询消息
向DNS服务器发送查询消息 --> 调用到操作系统内部的协议栈（发送UDP消息， ）
接收DNS服务器返回的响应消息
从响应消息中取出IP地址，存放到内存地址
返回应用程序

要访问的Web服务器只有已经在DNS服务器上注册，才能找到记录。

## 1.3 全世界DNS服务器的大接力
### 1.3.1 DNS服务器的基本工作
来自DNS客户端的查询消息：
1. 域名
2. class，用于识别网络，但是实际上永远填写的是代表互联网的IN
3. 记录类型
当类型为A,表示域名对应的是IP地址
B，则是邮件服务器

### 1.3.2 域名的层次结构
显然，互联网如此多的服务器是需要许多的DNS服务器来记录的，这些信息是分布式保存的。
域名是有层次结构的：
www.lab.glasscom.com，越靠右层级越高
一个域的信息是作为一个整体存放在DNS服务器中的
一个域是不可分割的，但是可以创建下级域
假设公司的域是example.co.jp，可以在这个域的下面创建两个子域，sub1.example.co.jp，sub2.example.co.jp，这两个不同的事业部。
www.nikkeibp.co.jp这个域名，jp表示分配给日本的域，下一级是日本国内进行分类的域，再下一级是分配给某个公司的，www就是服务器的名称。

### 1.3.3 寻找相应的DNS服务器并获取IP地址
重点：将负责管理下级域的DNS服务器的IP地址注册到上级DNS服务器中，以此类推，例如：负责管理lab.glasscom.com域的DNS服务器的IP地址需要注册到glasscom.com域的DNS服务器中，因此，我们才可以通过上级DNS服务器查询出下级DNS服务器的IP地址。
实际上还有根域的设定，www.lab.glasscom.com.，最后的.就是表示根域，但是常常忽略。根域的DNS服务器信息（其IP极少，而且几乎不变）要保存在互联网中所有的DNS服务器中。
客户端首先访问最近的DNS服务器，如果没有记录的话，就去根域找，根域发现www.lab.glasscom.com这个域名属于com域，然后去找com问问看。

### 1.3.4 通过缓存加快DNS服务器的响应
实际情况中，一台DNS服务器可以管理多个域的信息。DNS服务器有缓存功能。缓存也是有有效期的，因为注册信息可能发生改变。

## 1.4 委托协议栈发送消息
### 1.4.1 数据收发操作概览
操作系统如何收发数据？
（TCP）服务器一方创建socket，（进入等待状态）等待客户端向该socket建立连接，然后就可以收发数据了。
简单理解就是：
1. 创建socket
2. 将管道连接到服务器端的socket
3. 收发数据
4. 断开管道并删除socket
其中，**这些操作都是协议栈去做的**
```cpp
<内存地址> = gethostbyname("www.lab.glasscom.com");
// 1 准备
fd = socket(ipv4, <流模式>);    // 和DNS服务器交互
// 2 连接
connect(<fd>，<ip地址>，<端口号>, ...);   // 和DNS服务器交互
// 3 发送
write(<fd>，<发送数据>，<发送数据长度>);    // 和操作系统协议栈交互

// 3 接收
<接收缓冲区地址> = read(<描述符>，<接收缓冲区>);  // 和WEB服务器交互 读取数据到应用程序内部的内存空间

// 4 断开
close(<描述符>);    // 和WEB服务器交互
```
因为通信关系可能存在多个，因此要fd来区分。
connect时还需要填写端口号，IP地址具体到网络的某台计算机，端口具体到计算机的某个套接字。
**准确来说，IP地址不是分配给每一台设备的，而是分配给设备中安装的网络硬件的，一台设备如果安装了多个网络硬件，那么就会有多个IP地址**
服务器上所使用的端口号是根据应用的种类事先规定好的：Web是80号端口，电子邮件是25号端口。
即：浏览器访问Web服务器时使用的80号端口，是规定好的。
端口号和IP地址都是由IANA组织统一管理的。
既然确定连接对象的套接字需要使用端口号，那么服务器也得知道客户端的套接字才行吧？
--> 实际上，客户端在创建套接字时，协议栈会为这个套接字**随便分配一个端口号**，当协议栈进行连接操作时，会将这个随便分配的端口号通知服务器。
HTTP协议规定，当Web服务器发送完响应消息后，应该主动执行断开操作。
实际负责收发消息的是：
**协议栈、网卡驱动 和 网卡**，只有这3者相互配合，数据才能够在网络中流动起来。


# 第二章 用电信号传输TCP/IP数据――――探索协议栈和网卡
本章重点：
1. 创建套接字
2. 连接服务器
3. 收发数据
4. 从服务器断开连接并删除套接字
5. IP与以太网的包收发操作（协议栈会与网卡进行配合，将数据切分成小块并封装成网络包，再将网络包转换成电信号/光信号发送出去）
6. 用UDP协议收发数据的操作（TCP协议具有丢失重发功能，但UDP也有其必要性）

### 2.1.1 协议栈的内部结构
图2.1 利用网络发送数据的分层结构
1. 网络应用程序（调用Socket库），如浏览器、邮件客户端、
2. 操作系统 包含协议栈 其中涉及TCP（建立连接） / UDP（不需要连接） / IP（用于传送网络包，确定路由，涉及ICMP（Internet Control Message Protocol）、ARP（Address Resolution Protocol：将IP地址解析为相应的物理MAC地址））
浏览器、邮件等一般的应用程序都是使用TCP收发数据的，像DNS等收发较短的控制数据使用UDP
在互联网上传送数据时，数据会被切分成一个一个的网络包，而将网络包发送给通信对象的操作就是由IP来负责的。此外，IP中还包括ICMP协议和ARP协议。ICMP用于告知网络包传送过程中产生的错误以及各种控制消息，ARP 用于根据IP地址查询相应的以太网MAC地址（符合IEEE规格的局域网设备都使用同一格式的地址）。

1. 网卡驱动程序（用于控制网卡）
2. 硬件：网卡

### 2.1.2 套接字的实体就是通信控制信息
毫无疑问，协议栈内部有一块用于存放控制信息的内存空间（通信对象的IP地址、端口号、通信操作的进行状态等），这些控制信息是协议栈在执行操作时需要参阅的
套接字中还要记录是否已经收到响应，以及超时时间
Windows系统中可以使用netstat显示套接字内容（可以理解为通信关系的展现）
（此处的套接字不是socket的概念）
协议 本地地址 外部地址 状态 PID
TCP 0.0.0.0:125 0.0.0.0:0 LISTENING 884
0.0.0.01表示还没有开始通信，没有绑定IP地址
PID列表示使用该套接字的程序
举例说明：
协议 本地地址 外部地址 状态 PID
TCP 10.10.1.16:1031 10.10.1.80:139 ESTABLISHED 4
表示：PID为4的程序正在使用IP地址为10.10.1.16的网卡与IP地址为10.10.1.18的对象进行通信，并且，对方使用的是139端口，是Windows文件服务器使用的端口。
另一行表示PID为984的程序正在135端口等待另一方的连接，其中本地IP地址和远程IP地址都是0.0.0.0，这表示通信还没开始，IP地址不确定。

### 2.1.3 调用socket时的操作
由于套接字中记录了通信双方的信息以及通信处于怎样的状态，所以只要通过描述符确定了相应的套接字，协议栈就能够获取所有的相关信息，这样一来，应用程序就不需要每次都告诉协议栈应该和谁进行通信了。

## 2.2 连接服务器
### 2.2.1 连接是什么意思
**连接实际上是通信双方交换控制信息，在套接字中记录这些必要信息并准备数据收发的一连串操作**
控制信息：用于控制数据收发操作所需的一些信息（比如IP地址和端口号），连接过程中还会分配一块用于临时存放要收发的数据的内存空间
如同打电话，通电话之前的准备自然而然地称为连接

### 2.2.2 负责保存控制信息的头部
控制信息实际上大体可以分为两类：
#### 1 客户端和服务器相互联络时交换的控制信息
不仅连接时需要，数据收发和断开连接操作，整个通信过程都需要，这些内容在TCP协议规格中进行了定义，位于TCP头部
TCP头部20个字节：发送方端口号、接收方端口号、序号、ACK号、数据偏移量、保留字段、控制位、窗口、校验和、紧急指针、可选字段
**整个数据包：1、以太网和IP的控制信息、2、TCP的控制信息、数据块**
在连接、断开等没有应用程序数据的情况下，双方只传递控制信息

客户端和服务器在通信中会将必要的信息记录在头部并相互确认，例如下面这样：
发送方：“开始数据发送。”
接收方：“请继续。”
发送方：“现在发送的是 ×× 号数据。”
接收方：“×× 号数据已收到。”

#### 控制信息还有另外一类，那就是保存在套接字中，用来控制协议栈操作的信息。
应用程序**传递来的信息**以及从通信对象**接收到的信息**都会保存在这里，还有收发数据操作的**执行状态**等信息也会保存在这里，协议栈会根据这些信息来执行每一步的操作。我们可以说，套接字的控制信息和协议栈的程序本身其实是一体的，因此，“协议栈具体需要哪些信息”会根据协议栈本身的实现方式不同而不同 ，但这并没有什么问题。因为协议栈中的控制信息通信对方是看不见的，只要在通信时按照规则将必要的信息写入头部，客户端和服务器之间的通信就能够得以成立。
例如，Windows 和 Linux 操作系统的内部结构不同，协议栈的实现方式不同，必要的控制信息也就不同。但即便如此，两种系统之间依然能够互相通信，同样地，计算机和手机之间也能够互相通信。正如前面所说，协议栈的实现不同，因此我们无法具体说明协议栈里到底保存了哪些 控制信息，但可以用命令来显示一些重要的套接字控制信息，这些信息无论何种操作系统的协议 栈都是共通的，通过理解这些重要信息，就能够理解协议栈的工作方式了。

### 2.2.3 连接操作的实际过程
connect（< 描述符 >, < 服务器 IP 地址和端口号 >, …）
上面的调用提供了服务器的 IP 地址和端口号，这些信息会传递给协议栈中的 TCP 模块。然后，**TCP模块会与该IP地址对应的对象，也就是与服务器的TCP模块交换控制信息**，这一交互过程包括下面几个步骤。
首先，客户端先创建一个包含表示开始数据收发操作的控制信息的头部。
如表 2.1 所示，头部包含很多字段， 这里要关注的重点是**发送方和接收方的端口号**。
到这里，客户端（发送方）的套接字就准确找到了服务器 （接收方）的套接字，也就是搞清楚了我应该连接哪个套接字。
然后，我们将**头部中的控制位的SYN比特设置为1，可以认为它表示连接**。此外还需要设置适当的序号和窗口大小，这一点我们会稍后详细讲解。
**当TCP头部创建好之后，接下来TCP模块会将信息传递给IP模块并委托它进行发送**。
IP模块执行网络包发送操作后，网络包就会通过网络到达服务器，然后服务器上的IP模块会将接收到的数据传递给TCP模块，服务器的TCP模块根据TCP头部中的信息找到端口号对应的套接字，
也就是说，从处于等待连接状态的套接字中找到与TCP头部中记录的端口号相同的套接字就可以了。当找到对应的套接字之后，套接字中会写入相应的信息，并将状态改为正在连接。上述操作完成后，服务器的TCP模块会返回响应，这个过程和客户端一样，需要在TCP头部中设置发送方和接收方端口号以及SYN比特。
此外，**在返回响应时还需要将ACK控制位设为1，这表示已经接收到相应的网络包**。因为网络中经常会发生错误，网络包也会发生丢失，因此双方在通信时必须相互确认网络包是否已经送达 ，而设置 ACK 比特就是用来进行这一确认的。接下来，服务器TCP模块会将TCP头部传递给IP模块，并委托IP模块向客户端返回响应。
建立连接后，协议栈的连接操作结束，控制流程被交回到应用程序。





















