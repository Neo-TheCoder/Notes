网络是由很多计算机等设备相互连接组成的，因此在通信的过程中需要确定正确的通信对象，并将请求和响应发送给它们。请求和响应在传递的过程中可能会丢失或损坏，因此这些情况也必须要考虑到。所以说，我们需要一种机制，无论遇到任何情况都能够将请求和响应准确无误地发送给对方。由于请求和响应都是由 0 和 1 组成的数字信息，所以可以说，我们需要的是一种能够将数字信息搬运到指定目的地的机制。

这种机制是由操作系统中的网络控制软件，以及交换机、路由器等设备分工合作来实现的，它的基本思路是将数字信息分割成一个一个的小块，然后装入一些被称为“包”（Packet）的容器中来运送。“包”这个词大家可能在用手机的时候经常会碰到 ，但在这里类似于邮政和快递中的概念。大家可以这样理解：包相当于信 件或者包裹，而交换机和路由器则相当于邮局或快递公司的分拣处理区。包的头部存有目的地等控制信息，通过许多交换机和路由器的接力，就可以根据控制信息对这些包进行分拣，然后将它们一步一步地搬运到目的地。无论是家庭和公司里的局域网，还是外面的互联网，它们只是在规模上有所不同，基本的机制都是相同的。

# 每章概要

## 第一章 web浏览器
从输入网址开始（URL）：
http://www.lab.glasscom.com/sample1.html
浏览器按照规则解析URL，然后生成请求消息<请给我sample1.html这一文件中储存的网页数据>，浏览器将请求消息发送给Web服务器，准确来说，是委托操作系统中的网络控制软件将消息发送给服务器。

## 第二章 协议栈、网卡
探索搬运数据的机制。网络控制软件叫做协议栈，它会将从浏览器接收到的消息打包，然后加上目的地址等控制信息（类似于把信装进信封，然后写上收信人的地址，此外，还有其他功能：发生通信错误时重新发送包，调节数据发送的效率），然后，协议栈会把包交给网卡（负责以太网或者无线网络通信的硬件），网卡将包转换为电信号并通过网线发送出去，包就因此进入网络。

## 第三章 集线器、交换机、路由器
客户端计算机可以通过家庭或者公司的局域网接入互联网，也可以直接接入互联网
网卡发送的包会经过交换机等设备，到达用来接入互联网的路由器，路由器的后面就是互联网，网络运营商负责将包送到目的地

## 第四章 接入网、网络运营商
紧接着，数据从路由器（用于接入互联网）出发，进入了互联网的内部，互联网的入口线路称为接入网，这种通信线路具体来说有：电话线、ISDN、ADSL、光线、专线等。接入网连接到签约的网络运营商，并接入被称为接入点（Point of Presence）的设备。
接入点的实体是一台转为运营商设计的路由器（类比离你家最近的邮局，从各个邮筒收集来的信件在邮局进行分拣，然后送往全国甚至全世界）接入点的后面就是互联网的骨干部分：**其中存在很多运营商和大量的路由器，相互连接组成网，网络包在其中经过若干路由器的接力，发送到目标Web服务器上**
家用和公司局域网一般采用以太网进行连接
互联网中除了以太网还会使用别的技术来传送网络包

## 第五章 防火墙、缓存服务器
通过骨干网，网络包最终到达了Web服务器所在的局域网，接着会遇到防火墙，它会检查进入的包，然后网络包可能会遇到缓存服务器，因为网页数据中有一部分是可复用的，访问网页数据时先查找缓存服务器，而且大型网站可能还配备负载均衡器，将Web服务器设置为分布式的。

## 第六章 Web服务器
网络包到达Web服务器后，数据被**解包**还原为原始的请求消息，然后交给Web服务器程序，这个解包也是由操作系统中的协议栈（网络控制软件）来完成的。然后Web服务器程序分析请求消息的含义，根据指示将数据装入响应消息中，发回给客户端。
响应到达客户端后，浏览器将数据在屏幕显示出来。

# 第一章 浏览器内部
## 1.1 生成http请求消息
浏览器是具备多种客户端功能的综合性客户端软件
访问Web服务器时，URL是以"http:"开头的，访问FTP服务器时用"ftp:"，是根据协议来的
不同的服务器程序使用不同的端口号，以示区分
URL的组成：
https:// Web服务器域名 + 端口号 + 文件路径名（文件路径 + 文件名）

### 1.1.2 浏览器先要解析URL
解析完才能生成发送给Web服务器的请求消息

### 1.1.3 也可以省略文件名
这样的话，访问时就是找默认文件

### 1.1.4 HTTP的基本思路
很简单：
1. 客户端向服务器发送请求消息（包含操作对象以及如何操作，即URI统一资源标识符 + 方法（比如GET（获取数据）、POST（表单，将用户输入数据一并发送）、HEAD等））
2. Web服务器收到请求并解析，执行相应操作，将结果存放在响应消息中，响应消息的开头有状态码，表示操作的成功与否

### 1.1.5 生成HTTP请求消息
有严格的格式要求，消息头 + 消息体

### 1.1.6 发送请求后会收到响应
响应消息特有的状态码和响应短语

## 1.2 向DNS服务器查询Web服务器的IP地址
### 1.2.1 IP地址的基本知识
生成HTTP消息后，要**委托操作系统将消息发送**给Web服务器
因此必须先查询网址中，服务器域名对应的IP地址

小型如公司内部的局域网都是基于TCP/IP的思路来设计的：
即：**一些小的子网（用集线器链接起来的几台计算机），通过路由器连接起来组成一个大的网络**
集线器和路由器都是对包进行转发的设备，集线器分为中继式集线器、交换式集线器
家用集线器内置了集线器功能
在网络中，所有设备都会被分配一个地址，类比现实生活中的“XX号XX室”。“号”对应的数字是分配给整个子网的（--> 网络号），“室”对应的数字是分配给子网中的计算机的（--> 主机号），加起来就是**IP地址**
#### 消息在物理上具体是怎么发送的呢？
发送的消息首先经过子网中的集线器，转发到距离最近的路由器上，然后路由器根据消息的目的地判断下一个路由器的位置，将消息转发到下一个路由器，接着，消息再次经过子网内的集线器被转发到下一个路由器，不断重复这样的过程，消息最终就到了目的地。PS：数据是以包的形式传送的。
（不能存在有两台设备使用相同的IP地址的情况）

实际的IP地址：
32位，是网络号 + 主机号
具体结构是子网掩码确定的
比如：
10.11.12.13/255.255.255.0（前24位是网络号）
10.11.12.13/24
如果主机号部分的比特全为0，则该地址表示的不是单独一台计算机，而是代表整个子网
如果主机号部分的比特全为1，则该地址表示对整个子网进行广播

### 1.2.2 域名和IP地址并用的理由
TCP/IP网络是通过IP地址来确定通信对象的
要记住一长串数字显然是困难的
如果Web服务器使用了虚拟主机功能，则无法通过IP地址来访问
使用一串数字通信效率是比较高的，便于（路由器）处理
人使用域名，路由器使用IP地址，显然需要一个机制来实现通过名称来查询IP地址，或者反过来，这个机制就是DNS

### 1.2.3 Socket库提供查询IP地址的功能
查询IP地址只要询问最近的DNS服务器即可
我们的计算机必然有DNS客户端（DNS解析器，实际上是一段程序，包含在操作系统的Socket库）
通过编程来向DNS服务器发出查询很简单，就是调调接口
解析器得到DNS发来的IP地址后，写入浏览器指定的内存地址，然后浏览器再从该内存地址取出IP地址

### 1.2.5 解析器的内部原理
浏览器会调用socket提供的gethostbyname接口，内部大致实现如下：
生成发送给DNS服务器的查询消息
向DNS服务器发送查询消息 --> 调用到操作系统内部的协议栈（发送UDP消息， ）
接收DNS服务器返回的响应消息
从响应消息中取出IP地址，存放到内存地址
返回应用程序

要访问的Web服务器只有已经在DNS服务器上注册，才能找到记录。

## 1.3 全世界DNS服务器的大接力
### 1.3.1 DNS服务器的基本工作
来自DNS客户端的查询消息：
1. 域名
2. class，用于识别网络，但是实际上永远填写的是代表互联网的IN
3. 记录类型
当类型为A,表示域名对应的是IP地址
B，则是邮件服务器

### 1.3.2 域名的层次结构
显然，互联网如此多的服务器是需要许多的DNS服务器来记录的，这些信息是分布式保存的。
域名是有层次结构的：
www.lab.glasscom.com，越靠右层级越高
一个域的信息是作为一个整体存放在DNS服务器中的
一个域是不可分割的，但是可以创建下级域
假设公司的域是example.co.jp，可以在这个域的下面创建两个子域，sub1.example.co.jp，sub2.example.co.jp，这两个不同的事业部。
www.nikkeibp.co.jp这个域名，jp表示分配给日本的域，下一级是日本国内进行分类的域，再下一级是分配给某个公司的，www就是服务器的名称。

### 1.3.3 寻找相应的DNS服务器并获取IP地址
重点：将负责管理下级域的DNS服务器的IP地址注册到上级DNS服务器中，以此类推，例如：负责管理lab.glasscom.com域的DNS服务器的IP地址需要注册到glasscom.com域的DNS服务器中，因此，我们才可以通过上级DNS服务器查询出下级DNS服务器的IP地址。
实际上还有根域的设定，www.lab.glasscom.com.，最后的.就是表示根域，但是常常忽略。根域的DNS服务器信息（其IP极少，而且几乎不变）要保存在互联网中所有的DNS服务器中。
客户端首先访问最近的DNS服务器，如果没有记录的话，就去根域找，根域发现www.lab.glasscom.com这个域名属于com域，然后去找com问问看。

### 1.3.4 通过缓存加快DNS服务器的响应
实际情况中，一台DNS服务器可以管理多个域的信息。DNS服务器有缓存功能。缓存也是有有效期的，因为注册信息可能发生改变。

## 1.4 委托协议栈发送消息
### 1.4.1 数据收发操作概览
操作系统如何收发数据？
（TCP）服务器一方创建socket，（进入等待状态）等待客户端向该socket建立连接，然后就可以收发数据了。
简单理解就是：
1. 创建socket
2. 将管道连接到服务器端的socket
3. 收发数据
4. 断开管道并删除socket
其中，**这些操作都是协议栈去做的**
```cpp
<内存地址> = gethostbyname("www.lab.glasscom.com");
// 1 准备
fd = socket(ipv4, <流模式>);    // 和DNS服务器交互
// 2 连接
connect(<fd>，<ip地址>，<端口号>, ...);   // 和DNS服务器交互
// 3 发送
write(<fd>，<发送数据>，<发送数据长度>);    // 和操作系统协议栈交互

// 3 接收
<接收缓冲区地址> = read(<描述符>，<接收缓冲区>);  // 和WEB服务器交互 读取数据到应用程序内部的内存空间

// 4 断开
close(<描述符>);    // 和WEB服务器交互
```
因为通信关系可能存在多个，因此要fd来区分。
connect时还需要填写端口号，IP地址具体到网络的某台计算机，端口具体到计算机的某个套接字。
**准确来说，IP地址不是分配给每一台设备的，而是分配给设备中安装的网络硬件的，一台设备如果安装了多个网络硬件，那么就会有多个IP地址**
服务器上所使用的端口号是根据应用的种类事先规定好的：Web是80号端口，电子邮件是25号端口。
即：浏览器访问Web服务器时使用的80号端口，是规定好的。
端口号和IP地址都是由IANA组织统一管理的。
既然确定连接对象的套接字需要使用端口号，那么服务器也得知道客户端的套接字才行吧？
--> 实际上，客户端在创建套接字时，协议栈会为这个套接字**随便分配一个端口号**，当协议栈进行连接操作时，会将这个随便分配的端口号通知服务器。
HTTP协议规定，当Web服务器发送完响应消息后，应该主动执行断开操作。
实际负责收发消息的是：
**协议栈、网卡驱动 和 网卡**，只有这3者相互配合，数据才能够在网络中流动起来。


# 第二章 用电信号传输TCP/IP数据――――探索协议栈和网卡
本章重点：
1. 创建套接字
2. 连接服务器
3. 收发数据
4. 从服务器断开连接并删除套接字
5. IP与以太网的包收发操作（协议栈会与网卡进行配合，将数据切分成小块并封装成网络包，再将网络包转换成电信号/光信号发送出去）
6. 用UDP协议收发数据的操作（TCP协议具有丢失重发功能，但UDP也有其必要性）

### 2.1.1 协议栈的内部结构
图2.1 利用网络发送数据的分层结构
1. 网络应用程序（调用Socket库），如浏览器、邮件客户端、
2. 操作系统 包含协议栈 其中涉及TCP（建立连接） / UDP（不需要连接） / IP（用于传送网络包，确定路由，涉及ICMP（Internet Control Message Protocol）、ARP（Address Resolution Protocol：将IP地址解析为相应的物理MAC地址））
浏览器、邮件等一般的应用程序都是使用TCP收发数据的，像DNS等收发较短的控制数据使用UDP
在互联网上传送数据时，数据会被切分成一个一个的网络包，而将网络包发送给通信对象的操作就是由IP来负责的。此外，IP中还包括ICMP协议和ARP协议。ICMP用于告知网络包传送过程中产生的错误以及各种控制消息，ARP 用于根据IP地址查询相应的以太网MAC地址（符合IEEE规格的局域网设备都使用同一格式的地址）。

1. 网卡驱动程序（用于控制网卡）
2. 硬件：网卡

### 2.1.2 套接字的实体就是通信控制信息
毫无疑问，协议栈内部有一块用于存放控制信息的内存空间（通信对象的IP地址、端口号、通信操作的进行状态等），这些控制信息是协议栈在执行操作时需要参阅的
套接字中还要记录是否已经收到响应，以及超时时间
Windows系统中可以使用netstat显示套接字内容（可以理解为通信关系的展现）
（此处的套接字不是socket的概念）
协议 本地地址 外部地址 状态 PID
TCP 0.0.0.0:125 0.0.0.0:0 LISTENING 884
0.0.0.01表示还没有开始通信，没有绑定IP地址
PID列表示使用该套接字的程序
举例说明：
协议 本地地址 外部地址 状态 PID
TCP 10.10.1.16:1031 10.10.1.80:139 ESTABLISHED 4
表示：PID为4的程序正在使用IP地址为10.10.1.16的网卡与IP地址为10.10.1.18的对象进行通信，并且，对方使用的是139端口，是Windows文件服务器使用的端口。
另一行表示PID为984的程序正在135端口等待另一方的连接，其中本地IP地址和远程IP地址都是0.0.0.0，这表示通信还没开始，IP地址不确定。

### 2.1.3 调用socket时的操作
由于套接字中记录了通信双方的信息以及通信处于怎样的状态，所以只要通过描述符确定了相应的套接字，协议栈就能够获取所有的相关信息，这样一来，应用程序就不需要每次都告诉协议栈应该和谁进行通信了。

## 2.2 连接服务器
### 2.2.1 连接是什么意思
**连接实际上是通信双方交换控制信息，在套接字中记录这些必要信息并准备数据收发的一连串操作**
控制信息：用于控制数据收发操作所需的一些信息（比如IP地址和端口号），连接过程中还会分配一块用于临时存放要收发的数据的内存空间
如同打电话，通电话之前的准备自然而然地称为连接

### 2.2.2 负责保存控制信息的头部
控制信息实际上大体可以分为两类：
#### 1 客户端和服务器相互联络时交换的控制信息
不仅连接时需要，数据收发和断开连接操作，整个通信过程都需要，这些内容在TCP协议规格中进行了定义，位于TCP头部
TCP头部20个字节：发送方端口号、接收方端口号、序号、ACK号、数据偏移量、保留字段、控制位、窗口、校验和、紧急指针、可选字段
**整个数据包：1、以太网和IP的控制信息、2、TCP的控制信息、数据块**
在连接、断开等没有应用程序数据的情况下，双方只传递控制信息

客户端和服务器在通信中会将必要的信息记录在头部并相互确认，例如下面这样：
发送方：“开始数据发送。”
接收方：“请继续。”
发送方：“现在发送的是 ×× 号数据。”
接收方：“×× 号数据已收到。”

#### 控制信息还有另外一类，那就是保存在套接字中，用来控制协议栈操作的信息。
应用程序**传递来的信息**以及从通信对象**接收到的信息**都会保存在这里，还有收发数据操作的**执行状态**等信息也会保存在这里，协议栈会根据这些信息来执行每一步的操作。我们可以说，套接字的控制信息和协议栈的程序本身其实是一体的，因此，“协议栈具体需要哪些信息”会根据协议栈本身的实现方式不同而不同 ，但这并没有什么问题。因为协议栈中的控制信息通信对方是看不见的，只要在通信时按照规则将必要的信息写入头部，客户端和服务器之间的通信就能够得以成立。
例如，Windows 和 Linux 操作系统的内部结构不同，协议栈的实现方式不同，必要的控制信息也就不同。但即便如此，两种系统之间依然能够互相通信，同样地，计算机和手机之间也能够互相通信。正如前面所说，协议栈的实现不同，因此我们无法具体说明协议栈里到底保存了哪些 控制信息，但可以用命令来显示一些重要的套接字控制信息，这些信息无论何种操作系统的协议 栈都是共通的，通过理解这些重要信息，就能够理解协议栈的工作方式了。

### 2.2.3 连接操作的实际过程
connect（< 描述符 >, < 服务器 IP 地址和端口号 >, …）
上面的调用提供了服务器的 IP 地址和端口号，这些信息会传递给协议栈中的 TCP 模块。然后，**TCP模块会与该IP地址对应的对象，也就是与服务器的TCP模块交换控制信息**，这一交互过程包括下面几个步骤。
首先，客户端先创建一个包含表示开始数据收发操作的控制信息的头部。
如表 2.1 所示，头部包含很多字段， 这里要关注的重点是**发送方和接收方的端口号**。
到这里，客户端（发送方）的套接字就准确找到了服务器 （接收方）的套接字，也就是搞清楚了我应该连接哪个套接字。
然后，我们将**头部中的控制位的SYN比特设置为1，可以认为它表示连接**。此外还需要设置适当的序号和窗口大小，这一点我们会稍后详细讲解。
**当TCP头部创建好之后，接下来TCP模块会将信息传递给IP模块并委托它进行发送**。
IP模块执行网络包发送操作后，网络包就会通过网络到达服务器，然后服务器上的IP模块会将接收到的数据传递给TCP模块，服务器的TCP模块根据TCP头部中的信息找到端口号对应的套接字，
也就是说，从处于等待连接状态的套接字中找到与TCP头部中记录的端口号相同的套接字就可以了。当找到对应的套接字之后，套接字中会写入相应的信息，并将状态改为正在连接。上述操作完成后，服务器的TCP模块会返回响应，这个过程和客户端一样，需要在TCP头部中设置发送方和接收方端口号以及SYN比特。
此外，**在返回响应时还需要将ACK控制位设为1，这表示已经接收到相应的网络包**。因为网络中经常会发生错误，网络包也会发生丢失，因此双方在通信时必须相互确认网络包是否已经送达 ，而设置 ACK 比特就是用来进行这一确认的。接下来，服务器TCP模块会将TCP头部传递给IP模块，并委托IP模块向客户端返回响应。
建立连接后，协议栈的连接操作结束，控制流程被交回到应用程序。

## 2.3 收发数据
### 2.3.1 将HTTP请求消息交给协议栈
数据收发操作是从应用程序调用write,将要发送的数据交给协议栈开始的。协议栈并不关心应用程序发送的数据，因为对它来说只是一定长度的二进制字节序列。
协议栈发送数据时，是**先把数据存放在内部的发送缓冲区**，并等待应用程序的下一段数据。意义在于：一次将多少数据交给协议栈是由应用程序自行决定的，协议栈并不能控制这一行为，**如果协议栈一收到数据就马上发送，就可能发送大量的小包，导致网络效率下降，因此需要在数据积累到一定量时再发送，具体是多少就取决于操作系统了**
累积多少再发送有以下几个决定因素：
1. 每个网络包能容纳的数据长度：协议栈会根据一个叫做MTU（Max Transmission Unit最大传输单元）的参数来判断 MTU表示一个网络包的最大长度，在以太网中一般是1500字节（这个数字是包含了头部的总长度，因此最大数据长度为1500 - 头部 = MSS，Max Segment Size，最大分段大小，TCP和IP的头部加起来一般是40字节，那么MSS就是1460）当从应用程序收到的数据长度超过或者接近 MSS 时再发送出去，就可以避免发送大量小包的问题了。

报头/起始帧分界符SFD + MAC头部 + [ IP头部 + TCP头部 + 数据 ] + FCS（帧校验序列）

2. 另一个判断要素是**时间**，当应用程序发送数据频率不高时，如果总是等待缓冲区数据长度到MSS时再发送，就可能因为等待时间太长而造成发送延迟，因此应该果断发送，协议栈内会有一个计数器，经过一定时间（ms级别）后，就把网络包发送出去
这两个因素需要取得一定的平衡，这是由操作系统中协议栈的开发者决定的，当然，**协议栈也给应用程序保留了控制发送时机的余地**，比如如果指定“不等待填满缓冲区直接发送”，则协议栈就会按照要求直接发送数据。像浏览器这种会话型的应用程序在向服务器发送数据时，等待填满缓冲区导致延迟会产生很大影响，因此一般会使用直接发送的选项。

### 2.3.2 对较大的数据进行拆分
HTTP 请求消息一般不会很长，一个网络包就能装得下，但如果其中要提交表单数据，长度就可能超过一个 网络包所能容纳的数据量，比如在博客或者论坛上发表一篇长文就属于这种情况。
这种情况下，发送缓冲区中的数据就会超过 MSS 的长度，这时我们当然不需要继续等待后面的数据了。**发送缓冲区中的数据会被以 MSS 长度为单位进行拆分，拆分出来的每块数据会被放进单独的网络包中**。
根据发送缓冲区中的数据拆分的情况，当判断需要发送这些数据时，就在每一块数据前面加上TCP头部， 并根据套接字中记录的控制信息标记发送方和接收方的端口号，然后交给IP模块来执行发送数据的操作

### 2.3.3 使用 ACK 号确认网络包已收到
TCP模块拆分数据时，会计算偏移量，记录在TCP头部，通过“序号”字段就可以得到偏移。
（序号表示的是字节序号）
例如：
数据包1：序号1       长度1460字节   对应接收方的ACK号 1461
数据包2：序号1461    长度1460字节   对应接收方的ACK号 2921
数据包3：序号2921    长度1460字节   对应接收方的ACK号 4381

接收方可以检查收到的网络包有没有遗漏：
接收方接收了上一次收到的数据包的第1460字节，那么接下来收到序号为1461的包，是正常的，但是如果收到的数据包序号为2921，那就说明遗漏了，
如果确认没有遗漏，接收方会将到目前为止接收到的数据长度加起来，计算出一共已经收到了多少个字节，然后将这个数值写入 TCP头部的ACK号中发送给发送方。
简单来说，发送方说的是“现在发送的是从第 ×× 字节开始的部分，一共有××字节哦！”。**而接收方则回复说，“到第 ×× 字节之前的数据我已经都收到了哦！”**这个返回ACK号的操作被称为**确认响应**，通过这样的方式，发送方就能够确认对方到底收到了多少数据。
PS：接收方返回ACK号时，还需要把控制位中的ACK比特设置为1，
实际通信中，序号并非从1开始，而是**随机值**，如果从1开始则容易被攻击。
因此在建立连接的过程中，有一个将SYN控制位设为1并发送给服务器的操作，就是在这一步将序号的初始值告知对方的。实际上，在将SYN设为1的同时，还需要同时设置序号字段的值，而这里的值就代表序号的初始值。
我们在前面讲连接操作的时候说过SYN为1表示进行连接，这是因为**将SYN设为1并告知初始序号**这一操作仅在连接过程中出现，因此发送SYN为1的网络包就表示发起连接的意思。实际上，SYN是 Synchronize（同步）的缩写，意思是通过告知初始序号使通信双方保持步调一致，以便完成后续的数据收发检查，这才是SYN原本的含义。
要注意实际TCP数据收发是双向的。
首先客户端先计算出一个序号，然后将序号和数据一起发送给服务器，服务器收到之后会计算ACK号并返回给客户端;
相反地，服务器也需要先计算出另一个序号，然后将序号和数据一起发送给客户端，客户端收到之后计算ACK号并返回给服务器。 此外，如图所示，客户端和服务器双方都需要各自计算序号，因此双方需要在连接过程中互相告知自己计算的序号初始值。
TCP采用这样的方式确认对方是否收到了数据，在得到对方确认之前，发送过的包都会保存在发送缓冲区中。如果对方没有返回某些包对应的ACK号，那么就重新发送这些包。
**通过这一机制，我们可以确认接收方有没有收到某个包，如果没有收到则重新发送，这样一来，无论网络中发生任何错误，我们都可以发现并采取补救措施（重传网络包）**。反过来说，有了这一机制，我们就不需要在其他地方对错误进行补救了。
**网卡、集线器、路由器都没有错误补偿机制，一旦检测到错误就直接丢弃相应的包。应用程序也是一样，因为采用TCP传输，即便发生一些错误对方最终也能够收到正确的数据，所以应用程序只管自顾自地发送这些数据就好了。**
**不过，如果发生网络中断、服务器宕机等问题，那么无论 TCP 怎样重传都不管用。这种情况下，无论如何尝试都是徒劳，因此 TCP会在尝试几次重传无效之后强制结束通信，并向应用程序报错。**

### 2.3.4 根据网络包平均往返时间调整 ACK 号等待时间
超时重传的时间要设置得合理：
因为ACK号返回变慢往往是由网络拥塞引起的，出现多余的重传会导致本来就很拥塞的网络雪上加霜。
TCP采用了动态调整 等待时间的方法，这个等待时间是根据 ACK号返回所需的时间来判断的。具体来说，TCP会在发送数据的 过程中持续测量ACK号的返回时间，如果 ACK号返回变慢，则相应延长等待时间；相对地，如果 ACK号马上就能返回，则相应缩短等待时间。
由于计算机的时间测量精度较低，ACK 返回时间过短时无法被正确测量，因此等待时间有一个最小值，这个值在每个操作系统上不一样， 基本上是在 0.5 秒到 1 秒之间。

### 2.3.5 使用窗口有效管理ACK号
使用滑动窗口的机制来实现高效的通信（无发完一个包就等待一个ACK号的方式是最简单的，但是什么都不做显然太浪费了）
**发完一个包后，不等待ACK号返回，而是直接发送后续的一系列包，把等待ACK号的时间利用起来**
如果不等返回ACK号就连续发送包，就有可能会出现发送包的频率超过接收方处理能力的情况。
具体解释一下。当接收方的TCP收到包后，会先将数据存放到接收缓冲区中。然后，接收方需要计算ACK号，将数据块组装起来还原成原本的数据并传递给应用程序，如果这些操作还没完成下一个包就到了也不用担心，因为下一个包也会被暂存在接收缓冲区中。**如果数据到达的速率比处理这些数据并传递给应用程序的速率还要快，那么接收缓冲区中的数据就会越堆越多，最后就会溢出。**缓冲区溢出之后，后面的数据就进不来了，因此接收方就收不到后面的包了，这就和中途出错的结果是一样的，也就意味着超出了接收方处理能力。
我们可以通过下面的方法来避免这种情况的发生。首先，**接收方需要告诉发送方自己最多能接收多少数据，然后发送方根据这个值对数据发送操作进行控制，这就是滑动窗口方式的基本思路。**

**能够接收的最大数据量称为窗口大小** ，它是TCP调优参数中非常有名的一个。

### 2.3.6 ACK与窗口的合并
要提高收发数据的效率，还需要考虑另一个问题，那就是返回ACK号和更新窗口的时机。如果假定这两个参数是相互独立的，分别用两个单独的包来发送，结果会如何呢？
首先，什么时候需要更新窗口大小呢？当收到的数据刚刚开始填入缓冲区时，其实没必要每次都向发送方更新窗口大小，因为只要发送方在每次发送数据时减掉已发送的数据长度就可以自行计算出当前窗口的剩余长度。
因此，**更新窗口大小的时机应该是接收方从缓冲区中取出数据传递给应用程序的时候。这个操作是接收方应用程序发出请求时才会进行的，而发送方不知道什么时候会进行这样的操作**，因此当接收方将数据传递给应用程序，导致接收缓冲区剩余容量增加时，**就需要告知发送方，这就是更新窗口大小的时机**。
那么ACK号又是什么情况呢？当接收方收到数据时，如果确认内容没有问题，就应该向发送方返回ACK号，因此我们可以认为收到数据之后马上就应该进行这一操作。
如果将前面两个因素结合起来看，首先，发送方的数据到达接收方，**在接收操作完成之后就需要向发送方返回ACK号**，而再经过一段时间，**当数据传递给应用程序之后才需要更新窗口大小**。但如果根据这样的设计来实现，每收到一个包，就需要向发送方分别发送ACK号和窗口更新这两个单独的包。这样一来，接收方发给发送方的包就太多了，导致网络效率下降。

因此，接收方在发送ACK号和窗口更新时，并不会马上把包发送出去，而是会**等待一段时间，在这个过程中很有可能会出现其他的通知操作，这样就可以把两种通知合并在一个包里面发送了**。举个例子，在等待发送ACK号的时候正好需要更新窗口，这时就可以把ACK号和窗口更新放在一个包里发送，从而**减少包的数量**。**当需要连续发送多个ACK号时，也可以减少包的数量，这是因为ACK号表示的是已收到的数据量，也就是说，它是告诉发送方目前已接收的数据的最后位置在哪里，因此当需要连续发送ACK号时，只要发送最后一个ACK号就可以了，中间的可以全部省略**。**当需要连续发送多个窗口更新时也可以减少包的数量，因为连续发生窗口更新说明应用程序连续请求了数据，接收缓冲区的剩余空间连续增加**。这种情况和ACK号一样，可以省略中间过程，只要发送最终的结果就可以了。

### 2.3.7 接收HTTP响应消息
到这里，我们已经讲解完协议栈接到浏览器的委托后发送 HTTP 请求消息的一系列操作过程了。 不过，浏览器的工作并非到此为止。发送 HTTP 请求消息后，接下来还需要等待 Web 服务器返回响应消息。对于响应消息，浏览器需要进行接收操作，这一操作也需要协议栈的参与。
首先，浏览器在委托协议栈发送请求消息之后，会调用read程序来获取响应消息。然后，控制流程会通过read转移到协议栈，然后协议栈会执行接下来的操作。和发送数据一样，接收数据也需要将数据暂存到接收缓冲区中，这里的操作过程如下。首先，协议栈尝试从接收缓冲区中取出数据并传递给应用程序，但这个时候请求消息刚刚发送出去，响应消息可能还没返回。响应消息的返回还需要等待一段时间，因此这时接收缓冲区中并没有数据，那么接收数据的操作也就无法继续。这时，协议栈会将应用程序的委托，也就是从接收缓冲区中取出数据并传递给应用程序的工作暂时挂起 ，等服务器返回的响应消息到达之后再继续执行接收操作。

## 2.4 从服务器断开并删除套接字
### 2.4.1 数据发送完毕后断开连接
毫无疑问，收发数据结束的时间点应该是应用程序判断所有数据都已经发送完毕的时候。这时，数据发送完毕的一方会发起断开过程，但不同的应用程序会选择不同的断开时机。
以Web为例，浏览器向Web服务器发送请求消息，Web服务器再返回响应消息，这时收发数据的过程就全部结束了，服务器一方会发起断开过程。当然，可能也有一些程序是客户端发送完数据就结束了，不用等服务器响应，这时客户端会先发起断开过程。这一判断是应用程序作出的，**协议栈在设计上允许任何一方先发起断开过程**。
这里讲的是HTTP1.0的情形，在 HTTP1.1中，服务器返回响应消息之后，客户端还可以继续发起下一个请求消息，如果接下来没有请求要发送了，客户端一方会发起断开过程。无论哪种情况，完成数据发送的一方会发起断开过程，这里我们以服务器一方发起断开过程为例来进行讲解。
首先，**服务器一方的应用程序会调用Socket库的close程序。然后，服务器的协议栈会生成包含断开信息的TCP头部，具体来说就是将控制位中的 FIN比特设为1**。接下来，协议栈会委托IP模块向客户端发送数据。同时，服务器的套接字中也会记录下断开操作的相关信息。

### 2.4.2 删除套接字
和服务器的通信结束之后，用来通信的套接字也就不会再使用了，这时我们就可以删除这个套接字了。不过，套接字并不会立即被删除，而是会等待一段时间之后再被删除。**等待这段时间是为了防止误操作**。

## 2.5 IP 与以太网的包收发操作
### 2.5.1 包的基本知识
TCP模块在执行连接、收发、断开等各阶段操作时，都需要委托IP模块将数据封装成包发送给通信对象。
我们先来介绍一下关于网络包的一些基本知识。首先，**包是由头部和数据两部分构成的**。
**头部包含目的地址等控制信息**，大家可以把它理解为快递包裹的面单；头部后面就是委托方要发送给对方的数据，也就相当于快递包裹里的货物。

路由器和集线器是两种不同的转发设备，它们在传输网络包时有着各自的分工:
**（1）路由器根据目标地址判断下一个路由器的位置**
**（2）集线器在子网中将网络包传输到下一个路由**

### 2.5.2 包收发操作概览
凡是局域网所使用的头部都叫MAC头部，但其内容根据局域网的类型有所不同。此外，对于除局域网之外的其他通信技术，还有不同名称 的各种头部，但它们只是名字不叫MAC头部而已，承担的作用和MAC头部是相同的。
IP模块负责添加如下两个头部。
（1）MAC头部：以太网用的头部，包含MAC地址
（2）IP头部：IP用的头部，包含IP地址

### 2.5.3 生成包含接收方IP地址的IP头部
路由表举例：
| Network Destination | Netmask | Gateway | Interface | Metric |
| --- | --- | --- | --- | --- |
| 0.0.0.0 | 0.0.0.0 | 10.10.1.1 | 10.10.1.16 | 25 |
| 192.168.1.0 | 255.255.255.0 | 10.10.1.2 | 10.10.1.16 | 2 |
| 255.255.255.255 | 255.255.255.255 | 10.10.1.16 | 10.10.1.16 | 1 |
Gateway和Interface相同，意味着不需要经过路由器转发，表示当前路由器与网络直接连接，可以直接向目标IP地址发送包
若二者不同，则表示目标网络需要通过路由器的该接口发送给网关路由器
（路由器有多个interface，每个interface是由一个IP地址指示）
IP头部有协议号信息，表示包的内容是来自哪个模块

### 2.5.4 生成以太网用的MAC头部
IP头部中接收方IP地址表示网络包的目的地
但是以太网中不能直接这样填写，而是要依靠匹配的方式才能在以太网中把包发往目的地
MAC头部结构：
接收方MAC地址(48bit) + 发送方MAC地址(48bit) + 以太类型(16bit，用于标识是IP协议、还是ARP协议的包，ARP协议：Address Resolution Protocol，目标IP地址解析为对应的MAC地址)
MAC地址是一个整体，在网卡生产时写入ROM

实际上，只有在操作系统启动过程中对网卡进行初始化的时候才会读取MAC地址，读取出来之后会存放在内存中，每次执行收发操作时实际上使用的是内存中的值。此外，**读取MAC地址的操作是由网卡驱动程序来完成的，因此网卡驱动程序也可以不从网卡ROM中读取地址，而是将配置文件中设定的MAC地址拿出来放到内存中并用于设定MAC头部，或者也可以通过命令输入MAC地址**。
接收方MAC地址需要查看路由表，但是路由表中的表项信息也是要通过某一操作才能得到的，那就是ARP查询。


### 2.5.5 通过ARP查询目标路由器的MAC地址
ARP：地址解析协议
在以太网中广播：即：把包发给连接在同一以太网中的所有设备，ARP协议就是发广播包，询问某一个设备IP地址对应的MAC地址是多少。
ARP的结果会放在ARP缓存中，真正发包时先查询ARP缓存。
MAC地址的写法：00-80-C2-...（6字节）
或者用':'分隔
而实际情况中，IP地址是经常变化的，因此ARO缓存经过一段时间就会删除，也就几分钟。
**打包的工作是由IP模块负责的。**尽管MAC头部是以太网所需的内容，并非IP的职责范围，但是这样做是有意义的，因为如果在把数据交给网卡之前，IP模块就能够完成整个打包工作，那么网卡直接发送就可以了，对于除了IP以外的数据包也是一样，网卡直接发就行了，这样网卡就可以支持各种类型的包的处理，

### 2.5.6 以太网的基本知识
以太网是为多台计算机能够自由、廉价地通信而设计的通信技术，本质上就是一根网线，收发器这个设备则是把不同网线之间的信号连接起来。
网络中的一台计算机发送信号时，信号就会通过网线流过整个网络，最终到达所有设备，好比一个大房间里一个人说话所有人都能听见。那么这样的话就没法区分是想和谁说话了，于是就有了数据包MAC头部信息加MAC地址，通过以太网类型就可以判断出包里面装了什么类型的内容。
以太网的3个基本性质：
1. 将包发送到MAC头部的接收方MAC地址代表的目的地
2. 用发送方MAC地址识别发送方
3. 用以太类型识别包的内容
PS：这些性质也适用于无线局域网，只不过无线局域网没有以太类型，而是有一个类似功能的参数代替
（路由器等网络设备的网卡是集成在设备内部的）
以太网和IP一样，不关心网络包的实际内容，也就是说，以太网的收发操作和TCP的工作阶段无关

### 2.5.7 将IP包转换成电或光信号发送出去
IP生成的网络包只是内存中的数字信息，把数字信息转换成电信号才能在网线上传输  --> 负责执行这一操作的是**网卡**，在网卡驱动程序的帮助之下
网卡有哪些构成要素呢？
具体看图
计算机启动操作系统时，网卡驱动程序会对硬件做初始化操作（比如硬件错误检查、初始设置），然后硬件才可用。MAC模块中会做设置MAC（Media Access Control）地址的操作。
生产网卡时，会往网卡的ROM写入世界唯一的MAC地址，被网卡驱动读取。
MAC地址真正生效的时刻是在网卡驱动程序初始化时在MAC模块中设置的那个地址。

### 2.5.8 给网络包再加3个控制数据
网卡驱动从IP模块获取包后，复制到网卡内的缓冲区，然后向MAC模块发送“发送包的命令”
**MAC模块做了什么**：将包从缓冲区取出，在开头加上**报头和起始帧分界符（SFD）**，在末尾加上用于检测错误的**帧检验序列（FCS）**（将包从头到尾的内容作为输入，传入一个公式得来，类似于CRC校验码）。
（PS：数据包和数据帧其实是一回事）
报头：0，1交替出现的比特序列，占据56位。用于确定包的读取时机，起始帧分界符最后两个比特为1，网卡把这里作为包的起始位置
电信号表达数字信息，就是让0，1表示特定的电压和电流，实际情况中只有电压变化才能发觉比特的界限    --> 需要将时钟信号叠加进去

### 2.5.9 向集线器发送网络包
网卡加上SFD、FCS之后就可以把包通过网线发送出去了，方式有两种：
1. 集线器的半双工模式（同一时刻只能发送或者接收）
为了避免信号碰撞，要先检查网线中是否有别的设备发送的信号，等它发完了再发
将数字信息转为电信号的速率就是网络的传输速率
**PHY（MAU）模块功能就是对MAC模块产生的信号进行格式转换（转成可在网线中传输的格式）**
PHY模块还要监控线路是否有信号进来，没有才能发送，两台设备间的网线不能超过100米（双绞线，而光纤可以更长），这样发生错误的可能性小，即便发生错误，协议栈还有TCP兜底
若发生了信号碰撞，则通信无意义，等待时间是必须错开的，它是根据MAC地址生成的随机数算出来的，重试10次就报告通信错误

2. 交换机的全双工模式（发送和接收同时进行）
第三章介绍

### 2.5.10 接收返回包
既然使用集线器的半双工以太网中，信号会到达连接在集线器的所有设备，接收操作的第一步就是不管三七二十一把信号收进来。
网卡通知计算机是利用了**中断机制**，计算机持续执行别的任务，收到网卡的通知才处理。
具体：网卡向扩展总线中的中断信号线发送信号，该信号线通过计算机中的中断控制器连接到CPU。当产生中断信号时，**CPU会暂时挂起正在处理的任务，切换到操作系统中的中断处理程序**。然后，中断处理程序会调用网卡驱动，控制网卡执行相应的接收操作。
中断是有编号的，网卡在安装的时候就在硬件中设置了中断号，**在中断处理程序中则将硬件的中断号和相应的驱动程序绑定**。
那么网卡发起中断时，就会自动调用网卡驱动了。
网卡驱动被中断处理程序调用后，会从网卡缓冲区取出收到的包，通过MAC头部中的以太类型字段判断协议类型：IP协议、IPX/SPX、AppleTalk等，也就是交给对应的协议栈

### 2.5.11 将服务器的相应包从IP传递给TCP
网卡驱动将包交给TCP/IP协议栈来处理：
IP模块先开始工作，检查IP头部，查看接收方IP地址，如果server返回的包的接收方IP地址和客户端网卡的地址一致就可以接收了。
如果client收到不属于自己的包，会通过ICMP消息告知发送方，具体是Destination unreachable。
如果接收方IP地址正确，这个包会被接收，然后IP模块把数据包还原成原始的包（**因为局域网中只能传输小包，将大的包分片处理**，IP头部有标记，属于同一个包的分片具有相同的ID，再加上偏移量就可以还原）。
然后就是TCP模块的工作了，
**TCP模块会根据IP头部中的接收方和发送方IP地址，以及TCP头部中的接收方和发送方端口号来查找对应的套接字**。找到对应的套接字之后，就可以根据套接字中记录的通信状态，执行相应的操作了。例如，如果包的内容是应用程序数据，则返回确认接收的包，并将数据放入缓冲区，等待应用程序来读取；如果是建立或断开连接的控制包，则返回相应的响应控制包，并告知应用程序建立和断开连接的操作状态。

严格来说，TCP模块和IP模块有各自的责任范围，TCP头部属于TCP的责任范围，而IP头部属于IP模块的责任范围。根据这样的逻辑， 当包交给TCP模块之后，TCP 模块需要查询 IP 头部中的接收方和发送方 IP 地址来查找相应的套接字，这个过程就显得有点奇怪。因为 IP头部是IP模块负责的，TCP 模块去查询它等于是越权了。
如果要避免越权，应该对两者进行明确的划分，IP模块只向TCP模块传递TCP头部以及它后面的数据，而对于IP头部中的重要信息，即接收方和发送方的IP地址，则由IP模块以附加参数的形式告知TCP模块。然而，如果根据这种严格的划分来开发程序的话，IP模块和TCP模块之间的交互过程必然会产生成本，而且 IP 模块和 TCP 模块进行类似交互的场景其实非常多，总体的交互成本就会很高，程序的运行效率就会下降。因此，就像之前提过的一样，不妨将责任范围划分得宽松一些，**将 TCP 和 IP 作为一个整体来看待，减少不必要的交互**，所谓的严格划分就是只有IP模块能读取IP信息，然后传给TCP模块，那不如直接让TCP模块取得，这样可以带来更大的灵活性。此外，关于为什么查找套接字同时需要接收方和发送方的 IP 地址和端口号，我们会在第 6 章介绍端口号机制时一起讲解。

## 2.6 UDP协议的收发操作
有些应用程序不使用TCP协议而是使用UDP协议,比如向DNS服务器查询IP地址
TCP的复杂是为了将数据高效且可靠地发送给对方,可靠就意味着得确认对方是否收到我们发送的数据,如果没有就得**重发**
最简单的方法就是把数据全部发送完毕后让接收方返回一个接收确认,没收到的话就全部重发,别像TCP那样管理发送和确认的进度
如果漏了一个包就重发,怎么看都很低效,因此要避免重发已经送达的包,而只发出错或者未送达的包     -->     TCP的复杂正是因为这一点

但是比如数据很短的情况下,一个包就能装下,也不用考虑哪个包未送达的情况了,就不需要TCP的复杂机制了,也不用建立和断开连接的控制包了,并且发送数据时对端一般也都会回复,就不用专门的接收确认包了

### 2.6.2 控制用的短数据
以上场景就适合UDP,DNS查询等交换控制信息一般一个包的大小就完事了.
UDP不建立/断开连接,直接在应用程序获取的数据前面加上UDP头部,然后交给IP发送就行了
**接收:只要根据IP头部中的接收方和发送方IP地址,以及UDP头部中的接收方和发送方端口号,找到相应的套接字并将数据交给相应的应用程序就可以了**
遇到错误或者丢包都完全不管
由于出错时,对端自然收不到消息,**应用程序自然会注意到**,就会重发(由于这样的操作不复杂,也不会增加应用程序的负担)

UDP可发送数据最大长度：IP包的最大长度 - IP头部 - UDP头部
而MTU、MSS是基于以太网和通信线路上网络包的最大长度来计算的
而UDP最大数据长度则单纯是长度的相减：65536 - 20 -8 65507（由于超过了以太网和通信线路上网络包的最大长度要让IP模块分片之后再传输）
**UDP头部**：8个字节：发送方端口号、接收方端口号、数据长度、校验和（都是16bit）

### 2.6.3 音频和视频数据
音视频数据必须再规定时间送达，因而不采用复杂确认响应机制的TCP，重发的数据可能会错过播放的时机。
音视频丢包问题不大，只会失真或者卡顿，是可以接受的。


# 第三章 从网线到网络设备――探索集线器、交换机 和路由器
以太网线（双绞线）是由电话线发展而来的
对于路由器和交换机，包发生错误则直接丢弃，而操作系统中的网络控制软件（协议栈）会重发丢弃的包，使得数据不会丢失
第二章讲述如何将网络包转换成电信号通过网线传输出去
**本章讲述通过网线传输出去的包是如何经过集线器、交换机、路由器等网络设备进入互联网**
1. 信号在网线和集线器中传输
信号在其中会衰减或者失真

2. 交换机的包转发操作
交换机不是简单地让信号流过，而是先接收信号并将其还原为数字信息，然后重新转换成信号并发送出去

3. 路由器的包转发操作
交换机是基于以太网规格工作的
路由器是基于IP工作的

4. 路由器的附加功能
例如将私有地址转为公有地址的功能
阻止危险网络包的包过滤功能



## 3.1 信号在网线和集线器中传输
### 3.1.1 每个包都是独立传输的
从计算机发送出来的网络包在经过转发设备时，转发设备读取控制信息，并查找转发表，以此判断包的目的地，而不关注内容。

换句话说，HTTP请求的方法，TCP的确认响应和序号，客户端和服务器之间的关系，这一切都与包的传输无关。因此，所有的包在传输到目的地 的过程中都是独立的，相互之间没有任何关联。

实际上，我们家里用的路由器已经集成了集线器和交换机的功能。



### 3.1.2 防止网线中的信号衰减很重要
信号到达集线器可能会衰减，网线越长，衰减越严重
衰减的信号再失真就会导致对0和1的误判

### 3.1.3 双绞线是为了抑制噪声
双绞的意义是抵销噪声

### 3.1.4 集线器将信号发往所有线路
当信号到达集线器后，会被广播到整个网络中。**以太网的基本架构就是将包发到所有的设备，然后由设备根据接收方MAC地址来判断应该接收哪些包**，而集线器就是这一架构的忠实体现，它就是负责按照以太网的基本架构将信号广播出去。
**集线器接收到信号，就会从所有接口流出**

由于集线器只是原封不动地将信号广播出去，所以即便信号受到噪声的干扰发生了失真，也会原样发送到目的地。这时，**接收信号的设备，也就是交换机、路由器、服务器等，会在将信号转换成数字信息后通过FCS校验发现错误，并将出错的包丢弃**。当然，**丢弃包并不会影响数据的传输，因为丢弃的包不会触发确认响应。因此协议栈的TCP模块会检测到丢包，并对该包进行重传**。



## 3.2 交换机的包转发操作
### 3.2.1 交换机根据地址表进行转发
交换机的设计是将网络包原样转发到目的地
**交换机内部有一张<MAC地址，网线端口>的映射表**
当接收到包，将端口号和发送方MAC地址写入表中（即：<发送方MAC地址、端口号>），不断学习
交换机中的核心部分是交换电路 / 高速总线 / 共享内存
交换机和集线器的差异就在于：信号从双绞线进入后，进入交换机的PHY(MAU)模块的接收部分（这一点和集线器相同，但是现在其实基本不用集线器了，而是直接将计算机直连交换机），然后传递给MAC模块，将电信号转化为数字信号，通过数据包尾部的FCS校验错误（也就是说，交换机的每个网线接口后面都是一块网卡，或者说，如果在计算机上安装多块网卡，并开启“混杂模式”，让网卡接收所有的网络包，并安装一个网络包转发软件，那这个计算机就变成了一台交换机）
交换机的每个端口和网卡还是有所区别：网卡本身就有MAC地址，针对数据包中的接收方MAC地址做判断：是不是给自己的，而**交换机的端口是不区分的，因为没有AMC地址**。
但是有的交换机内置了计算机，那个计算机的部分是有MAC地址的。
将包存入缓冲区后，**查询该数据包的接收方MAC地址是否已经在MAC地址表中有记录了**。
查表后就可以知道该往那个端口转发了。


### 3.3.2 MAC地址表的维护
维护操作分为两种：
1. 收到包时，将<发送方MAC地址,输入端口号>写入MAC地址表中。写入后，交换机就知道该怎么转发了。
2. 删除地址表中某条记录的操作，毕竟设备的连线可能变化，策略时一段时间不使用后就自动删除。
高端交换机才提供手动维护地址表的功能
一般都是自行维护，不需要手动，低端款式想手动维护也不行


### 3.2.3 特殊操作
考虑以下场景：
计算机A和B都连接在集线器上，然后集线器的另外一个端口连接着交换机。
如果交换机查询地址表后发现记录中的目标端口和这个数据包的源端口是同一个，怎么处理？
A发送的包会被集线器转发到所有端口（交换机和B），然后交换机转发这个包后，又会返回给集线器，这个包又给到计算机A和B，计算机就回收到两个相同的包。
按照合理的设定，交换机会**丢弃一个要发回原端口的包**，直接丢弃
另一种情况：地址表找不到指定的MAC地址，可能是尚未发过，或者地址表重置了。**那么交换机会把包转发到除了源端口以外的所有端口**，只有相应的接收者才会接收包，否则就丢弃。只要接收者返回响应包，交换机就可以把它的地址写入地址表。
如果接收方MAC地址是一个广播地址，那么交换机做同样操作。

### 3.2.4 全双工模式
同时发送和接收
集线器无法同时发送和接收，会产生碰撞
使用双绞线的好处是发送和接收的信号线是各自独立的（虽然1000BASE-T规格的千兆以太网不是这样独立的，但是PHY(MAU)模块可以将二者分离）
如果不存在碰撞，也就不需要半双工模式中的碰撞处理机制了。
也就是说，发送和接收可以同时进行。然而，**以太网规范中规定了在网络中有信号时要等该信号结束后再发送信号**，因此发送和接收还是无法同时进行。
于是，人们对以太网规范进行了修订，增加了一个无论网络中有没有信号都可以发送信号的工作模式，同时规定在这一工作模式下停用碰撞检测这种工作模式就是全双工模式。在全双工模式下，无需等待其他信号结束就可以发送信号，因此它比半双工模式速度要快 。由于双方可以同时发送数据，所以可同时传输的数据量也更大，性能也就更高。


### 3.2.5 自动协商：确定最优的传输速率

能可以由相互连接的双方探测对方是否支持全双工模式，并自动切换成相应的工作模式。
此外，除了能自动切换工作模式之外，还能探测对方的传输速率并进行自动切换。这种自动切换的功能称为自动协商。

在以太网中，当没有数据在传输时，网络中会填充一种被称为**连接脉冲**的脉冲信号。在没有数据信号时就填充连接脉冲，这使得网络中一直都有一定的信号流过，从而能够检测对方是否在正常工作，或者说网线有没有正常连接。以太网设备的网线接口周围有一个绿色的 LED 指示灯，它表示是否检测到正常的脉冲信号。如果绿灯亮，说明 PHY（MAU）模块以及网线连接正常 。

具有特定排列的脉冲信号，通过这种信号可以将自身的状态告知对方。自动协商功能就利用了这样的脉冲信号，即通过这种信号将自己能够支持的工作模式和传输速率相互告知对方，并从中选择一个最优的组合。


### 3.2.6 交换机可同时执行多个转发操作
从设备整体的转发能力来看，交换机要高于集线器。


## 3.3 路由器的包转发操作
### 3.3.1 路由器的基本知识
虽然路由器和交换机都是通过查表判断转发包的目标，但是**路由器是基于IP设计的，而交换机是基于以太网设计的**。
路由器简单来看，分为**转发模块和端口模块**，类似于协议栈的IP模块和网卡之间的关系。

通过更换网卡，计算机不仅可以支持以太网，也可以支持无线局域网，路由器也是一样。如果路由器的端口模块安装了支持无线局域网的硬件，就可以支持无线局域网。
此外，计算机的网卡除了以太网和无线局域网之外很少见到支持其他通信技术的品种，而路由器的端口模块则支持除局域网之外的多种通信技术，如 ADSL、FTTH，以及各种宽带专线等，只要端口模块安装了支持这些技术的硬件即可。

路由器在转发包时，首先会通过端口将发过来的包接收进来，这一步的工作过程**取决于端口对应的通信技术**。对于以太网端口来说，就是按照以太网规范进行工作，而无线局域网端口则按照无线局域网的规范工作，总之就是委托端口的硬件将包接收进来。
接下来，**转发模块**会根据(接收到的包的IP头部中记录的)接收方IP地址，在路由表中进行查询，以此判断转发目标。然后，转发模块将包转移到转发目标对应的端口，端口再按照硬件的规则将包发送出去，也就是转发模块委托端口模块将包发送出去的意思。

**端口模块**会根据相应通信技术的规范来执行包收发的操作,即**端口模块是以实际的发送方或者接收方的身份来收发网络包的**。
以以太网端口为例， 路由器的端口具有MAC地址 ，因此它就能够成为以太网的发送方和接收方。
端口还具有IP地址，从这个意义上来说，它和计算机的网卡是一样的。
当转发包时，首先路由器端口会接收发给自己的以太网包，然后查询转发目标，再由相应的端口作为发送方将以太网包发送出去。这一点和交换机是不同的，**交换机只是将进来的包转发出去而已，它自己并不会成为发送方或者接收方**。
重点在于端口就类似网卡，有选择地发送和接收，相比交换机粒度更细。交换机是作为整体来看，它只是负责将接收到的数据包转发到正确的目标设备，但它不会成为数据包的发送方或接收方。它只是一个数据包的**中继站**。

和网卡一样，MAC地址也是在生产时写入端口的ROM中的。 但**端口并不会成为IP的发送方和接收方**。端口是按照以太网规范接收包的，即当端口的MAC地址和包的接收方MAC地址一致时，端口才接受这个包，否则就丢弃包。

**路由器的各个端口都具有MAC地址和IP地址。**

### 3.3.2 路由表中的信息
路由器查转发表重点是考察IP头部中的IP地址
路由表：
| 目标地址 | 子网掩码 | 网关 | 接口 | 跃点数 |
| ----: | ----: | ----: | ----: | ----: |
| 10.10.1.0 | 25.255.255.0 | ―― | e2 | 1 |
| 0.0.0.0 | 0.0.0.0 | 192.0.2.1 | e1 | 1 |
最左侧的目标地址列记录的是接收方的信息。实际上这里的 IP 地址只包含表示**子网的网络号**部分的比特值，而表示主机号部分的比特值全部为0。路由器会将接收到的网络包的接收方IP地址与路由表中的目标地址进行比较，并找到相应的记录。交换机在地址表中只匹配完全一致的记录，而路由器则会**忽略主机号部分，只匹配网络号部分**。
打个比方，路由器在转发包的时候只看接收方地址属于哪个区，××区发往这一边，××区发往那一边。
**路由聚合：地址本身的子网掩码和路由表中的子网掩码是不一致的。**
我们现在有3个子网，分别为：10.10.1.0/24、10.10.2.0/24、10.10.3.0/24，
路由器 B 需要将包发往这3个子网。在这种情况下，路由器B的路由表中原本应该有对应这3个子网的3条记录，但在这个例子中，**无论发往任何一个子网，都是通过路由器A来进行转发，因此我们可以在路由表中将这3个子网合并成10.10.0.0/16**（毕竟路由表项只记录网络号），这样也可以正确地进行转发，但我们减少了路由表中的记录数量，这就是路由聚合。经过路由聚合，多个子网会被合并成一个子网，子网掩码会发生变化，同时，目标地址列也会改成聚合后的地址。

相对地，还有另外一些情况，如将一个子网进行细分并注册在路由表中，然后拆分成多条记录。 
从结果上看，路由表的子网掩码列只是用来在匹配目标地址时告诉路由器应该匹配多少个比特。而且，目标地址中的地址和实际子网的网络号可能并不完全相同，但即便如此，路由器依然可以正常工作。此外，通过上述方法，**我们也可以将某台具体计算机的地址写入路由表中，这时的子网掩码为255.255.255.255，也就是说地址中的全部32个比特都为1**。这样一来，主机号部分比特全部为0可以表示一个子网，主机号部分比特不全部为0可以表示某一台计算机，两种情况可以用相同的规则来处理路由表的子网掩码列只表示在匹配网络包目标地址时需要对比的比特数量。

**根据目标地址和子网掩码匹配到某条记录后，路由器就会将网络包交给接口列中指定的网络接口（即端口），并转发到网关列中指定的IP地址。**

最后一列是跃点计数，它表示距离目标IP地址的距离是远还是近。这个数字越小，表示距离目的地越近；数字越大，表示距离目的地越远。 
路由表记录维护的方式和交换机也有所不同。交换机中对MAC地址表的维护是包转发操作中的一个步骤 ，而路由器中对路由表的维护是与包转发操作相互独立的，也就是说，在转发包的过程中不需要对路由表的内容进行维护。

对路由表进行维护的方法有几种，大体上可分为以下两类。 
1. 由人手动维护路由记录 
2. 根据路由协议机制，通过路由器之间的信息交换由路由器自行维护路由表的记录 其中2中提到的路由协议有很多种，例如 RIP、OSPC、BGP 等都属于路由协议。


### 3.3.3 路由器的包接收操作
路由器的以太网端口是如何接收包的：
信号到达网线接口部分，其中的PHY（MAU）模块和MAC模块将信号转换为数字信息，对包尾的FCS进行错误检验，如果没问题就检查MAC头部中的接收方MAC地址，如果发现是发给自己的，就放到接收缓冲区，否则就丢弃。


### 3.3.4 查询路由表确定输出端口
接收到包之后，路由器就会丢弃包的MAC头部（因为MAC头部就是为了将包送达路由器，此时任务就完成了）
然后 路由器**根据MAC头部之后的IP头部中的内容进行包转发的操作**：
1. 查询路由表，判断转发目标
如果目的IP为192.168.1.10（00000001.00001010），将其与路由表中的目标地址那一列网络号匹配（不过路由器中的子网和实际的子网并不是完全一致的）。
可能会产生多条匹配，路由器**优先选择网络号比特数最长的**（显然，网络号越长，主机号越短，这样可以缩小范围，根据这条记录判断出的转发目标就更为准确）
可以匹配示例路由表中的：3、4、5都可以匹配
3是表示一个子网
4是表示一台服务器
5是默认

有时候路由表中会存在网络号长度相同的多条记录，例如考虑到路由器或网线的故障而设置的备用路由就属于这种情况。
这时，**需要根据跃点计数的值来进行判断。跃点计数越小说明该路由越近，因此应选择跃点计数较小的记录**。

如果在路由表中无法找到匹配的记录，路由器会丢弃这个包，并通过ICMP消息告知发送方。
这里的处理方式和交换机不同，原因在于网络规模的大小。交换机连接的网络最多也就是几千台设备的规模，这个规模并不大。如果只有几千台设备，**遇到不知道应该转发到哪里的包，交换机可以将包发送到所有的端口上**，虽然这个方法很简单粗暴，但不会引发什么问题。
然而，路由器工作的网络环境就是互联网，它的规模是远远大于以太网的，全世界所有的设备都连接在互联网上，而且规模还在持续扩大，未来的互联网里到底会有多少设备，我们谁都说不准。在如此庞大的网络中，如果将不知道应该转发到哪里的包发送到整个网络上，那就会产生大量的网络包，造成网络拥塞。因此，**路由器遇到不知道该转发到哪里的包，就会直接丢弃**。



### 3.3.5 找不到匹配路由时选择默认路由
目标地址和子网掩码为0.0.0.0，意味着不需要匹配，然后网关列填写接入互联网的路由器地址（即所谓的默认路由和默认网关）

在计算机的TCP/IP设置窗口中也有一个填写默认网关的框，意思是一样的。计算机上也有一张和路由器一样的路由表，其中默认网关的地址就是我们在设置窗口中填写的地址。
由于匹配的比特数越长优先级越高（最长匹配原则），因此子网掩码为 0.0.0.0 的记录优先级是最低的，只有当找不到其他匹配的记录时， 才会选择这条记录。


### 3.3.6 包的有效期
从路由表中查找到转发目标之后，网络包就会被转交给输出端口，并最终发送出去，但在此之前，路由器还 有一些工作要完成。
第一个工作是**更新IP头部中的 TTL（Timeto Live，生存时间）字段**。
TTL字段表示包的有效期。**包每经过一个路由器的转发，这个值就会减1，当这个值变成0时，就表示超过了有效期，这个包就会被丢弃**。
为了防止包在一个地方陷入死循环。如果路由表中的转发目标都配置正确，应该不会出现这样的情况，但如果其中的信息有问题，或者由于设备故障等原因切换到备用路由时导致暂时性的路由混乱，就会出现这样的情况。

发送方在发送包时会将 TTL 设为64或128，也就是说包经过这么多路由器后就会“寿终正寝”。现在的互联 网即便访问一台位于地球另一侧的服务器，最多也只需要经过几十个路由器，因此只要包被正确转发，就可以在过期之前到达目的地。


### 3.3.7 通过分片功能拆分大网络包
路由器的端口并不只有以太网一种，也可以支持其他局域网或专线通信技术。不同的线路和局域网类型各自能传输的最大包长度也不同，因此输出端口的最大包长度可能会小于输入端口 。即便两个端口的最大包长度相同，也可能会因为添加了一些头部数据而导致包的实际长度发生变化，ADSL、FTTH 等宽带接入技术中使用的PPPoE协议就属于这种情况。无论哪种情况，一旦转发的包长度超过了输出端口能传输的最 大长度，就无法直接发送这个包了。
PPPoE：PPP over Ethernet。它是一种控制 ADSL、FTTH 等宽带网络的方式

遇到这种情况，可以使用IP协议中定义的分片功能对包进行拆分，缩短每个包的长度。
需要注意的是，这里说的分片和第2章介绍的TCP对数据进行拆分的机制是不同的：
**TCP拆分数据的操作是在将数据装到包里之前进行的，换句话说，拆分好的一个数据块正好装进一个包里。**
TCP协议规定了最大分段大小（Max Segment Size），是协议规定的数据上限

从IP分片的角度来看，这样一个包其实是一个未拆分的整体，也就是说，**（IP）分片是对一个完整的包再进行拆分的过程。**
IP分片的MTU是物理设备的上限

首先，我们需要知道输出端口的MTU，看看这个包能不能不分片直接发送。
最大包长度是由端口类型决定的，**用这个最大长度减掉头部的长度就是MTU**。
将MTU与要转发的包长度进行比较。如果输出端口的MTU足够大，那么就可以不分片直接发送；
如果输出端口的MTU太小，那么就需要将包按照这个MTU进行分片，但在此之前还需要看一下 IP 头部中的标志字段，确认是否可以分片。

IP协议拆分数据是因为物理设备的限制，一次能够传输的数据由路径上 MTU 最小的设备决定，一旦IP协议传输的数据包超过 MTU 的限制就会发生分片，所以我们需要通过路径 MTU 发现获取传输路径上的 MTU 限制；
TCP协议拆分数据是为了保证传输的可靠性和顺序，作为可靠的传输协议，为了保证数据的传输顺序，它需要为每一个数据段增加包含序列号的TCP协议头，如果数据段大小超过了IP协议的MTU限制，就会带来更多额外的重传和重组开销，影响性能。TCP会根据网络状况自动调整分片大小。

TCP分片是可靠的，在接收端重新组装，而IP分片在网络中传输未必可靠，因为每个分片可能以不同的路径到达接收端，因此接收端要进行重组和去重操作。

**总结：IP协议将过大的数据包分片，避免物理设备的限制**
**TCP协议将过大的数据段分段传输，以保证传输的性能**

一般来说都是可以分片的，但下面两种情况不能分片：
1. 发送方应用程序等设置了不允许分片。
2. 这个包已经是经过分片后的包。

原始数据包结构：
MAC + IP头部 + TCP头部 + Payload

在IP分片的时候，TCP是被IP协议视作Payload的一部分（在分片时，补充的IP头部和原始的头部大部分内容是一样的，只有和分片相关的字段会更新）
（正因如此，可能会出现IP数据包是分片，但是没有TCP头部的情况，如果丢包，TCP协议的接收方就没法重组，整个TCP数据段就都得重传）

当然如果查询IP头部中分片标志位如果不允许分片，就只能丢弃，并通过ICMP消息通知对方


### 3.3.8 路由器的发送操作和计算机相同
到这里，发送前的准备工作就完成了 ，接下来就会进入包的发送操作。

这一步操作取决于输出端口的类型。
如果是以太网端口，则按照以太网的规则将包转换为电信号发送出去；
如果是ADSL，则按照ADSL的规则来转换。
以此类推。在家庭网络中，路由器后面一般连接ADSL等线路接入互联网，因此路由器会根据接入网的规则来发送包。
不过，要理解具体的操作过程，需要先理解相应的通信线路.这里，我们假设路由器位于公司等局域网的内部，即输出端口也是以太网，看看这种情况是如何操作的。

以太网的包发送操作是根据以太网规则来进行的，即便设备种类不同，规则也是相同的。也就是说，其基本过程和协议栈中的IP模块发送包的过程是相同的：**即在包前面加上MAC头部，设置其中的一些字段，然后将完成的包转换成电信号并发送出去。**
首先，为了判断MAC头部中的 MAC 地址应该填写什么值，我们需要根据路由表的网关列判断对方的地址。
如果网关是一个IP地址，则这个IP地址就是我们要转发到的目标地址；
如果网关为空，则IP头部中的接收方IP地址就是要转发到的目标地址。
知道对方的IP地址之后，接下来需要**通过ARP根据IP地址查询MAC地址**，并将查询的结果作为接收方 MAC 地址。
路由器也有ARP缓存，因此首先会在ARP缓存中查询，如果找不到则发送ARP查询请求。
（网关的IP地址和接口的IP地址相同时，表示IP头部中的接收方IP地址就是我们要转发的直接目标，但这段内容是针对Windows计算机的。路由器和Windows不一样，当包可以直接发送到最终接收方时，一般网关列是留空的。）
然后填写发送方MAC地址字段，即路由器端口的MAC地址，以太网类型字段为0080。

如果输出端口为以太网，则发送出去的网络包会通过交换机到达下一个路由器。由于接收方MAC地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。



### 3.3.9 路由器与交换机的关系
要理解两者之间的关系，关键点在于**计算机在发送网络包时，或者是路由器在转发网络包时，都需要在前面加上MAC头部。**
之前的讲解都是说在开头加上MAC头部，但其实准确的说法应该是：**将IP包装进以太网包的数据部分中**。
也就是说，**给包加上MAC头部并发送，从本质上说是将IP包装进以太网包的数据部分中，委托以太网去传输这些数据**。
**IP协议本身没有传输包的功能，因此包的实际传输要委托以太网来进行**。
**路由器是基于IP设计的，而交换机是基于以太网设计的，因此IP与以太网的关系也就是路由器与交换机的关系。**
换句话说，**路由器将包的传输工作委托给交换机来进行**。
当然，这里讲的内容只适用于原原本本实现IP和以太网机制的纯粹的路由器和交换机。
实际的路由器有内置交换机功能的，比如用于连接互联网的家用路由器就属于这一种，对于这种路由器，上面内容可能就不适用了。
但是， 如果把这种“不纯粹”的路由器拆分成“纯粹”的路由器和“纯粹”的交换机，则它们各自都适用上面的内容。 
除了使用交换机，还可以使用集线器，或者用交叉双绞线直接连接到路由器端口都可以。
**关键是，在委托传输时，只要能按照以太网规则传输包，不管是什么样的设备都可以。**

从包的转发目标也可以看出路由器和交换机之间的委托关系。
**IP并不是委托以太网将包传输到最终目的地，而是传输到下一个路由器。**
在创建MAC头部时，也是从IP的路由表中查找出下一个路由器的IP地址，并通过ARP查询出MAC地址，然后将MAC地址写入MAC头部中的，
**这表示IP对以太网的委托只是将包传输到下一个路由器就行了**。
当包到达下一个路由器后，下一个路由器又会**重新委托**以太网将包传输到再下一个路由器。随着这一过程反复执行，包就会最终到达 IP 的目的地，也就是通信的对象。
简单来说，**IP（路由器）负责将包发送给通信对象这一整体过程，而其中将包传输到下一个路由器的过程则是由以太网（交换机）来负责的。**
当然，网络并非只有以太网一种，还有无线局域网，以及接入互联网的通信线路，它们和IP之间的关系又是什么样的呢？
其实只要将以太网替换成无线局域网、互联网线路等通信规格就可以了。
也就是说，如果和下一个路由器之间是通过无线局域网连接的，那么就委托无线局域网将包传输过去；
如果是通过互联网线路连接的，那么就委托它将包传输过去。
除了这里列举的例子之外，世界上还有很多其他类型的通信技术，它们之间的关系也是一样的，**都是委托所使用的通信技术将包传输过去**。
**IP本身不负责包的传输，而是委托各种通信技术将包传输到下一个路由器，**
这样的设计是有重要意义的， 即**可以根据需要灵活运用各种通信技术**，这也是IP的最大特点。正是有了这一特点，我们才能够构建出互联网这一规模巨大的网络。
**IP（路由器）负责将包送达通信对象这一整体过程，而其中将包传输到下一个路由器的过程则是由以 太网（交换机）来负责的。**

IP只是一个逻辑协议，它并不关心如何将数据包物理传输到目标路由器。这部分工作由底层的通信技术来处理，如以太网、无线电波、光纤等。这些技术负责将数据包从一个路由器传输到下一个，直到达到目标。

因此，IP依赖于底层通信技术，委托它们来实际传输数据包，而自身主要负责数据包的路由和寻址。这种分层的设计使得计算机网络能够更加灵活和可扩展，因为不同的通信技术可以被用于不同的网络环境中，而IP仍然可以提供统一的路由和寻址服务。



## 3.4 路由器的附加功能
附加功能：
1. 地址转换
2. 包过滤

最早公司内网需要接入互联网的时候，应该向地址管理机构申请IP地址，并将它们分配给公司里的每台设备。换句话说，那个时候没有内网和外网的区别，所有客户端都是直接连接到互联网的。
但是互联网普及后，如果不能保证每台设备有唯一不重复的地址，就会从根本上影响网络包的传输，这是一个非常严重的 问题。如果任由这样发展下去，不久的将来，一旦固定地址用光，新的设备就无法接入了。

解决地址不足的问题，利用的就是：公司内部设备的地址不一定要和其他公司不重复，公司内部设备就不需要分配固定地址了。
从而大幅节省了IP地址。当然，就算是公司内网，也不是可 以随便分配地址的，因此需要设置一定的规则，**规定某些地址是用于内网的**，这些地址叫作私有地址，而原来的固定地址则叫作公有地址 。

内网中可用作私有地址的IP地址范围：
10.0.0.0 ～ 10.255.255.255
172.16.0.0 ～ 172.31.255.255
192.168.0.0 ～ 192.168.255.255

将公司内网分成两个部分：
一部分是对互联网开放的服务器，另一部分是公司内部设备。
其中对互联网开放的部分分配公有地址，可以和互联网直接进行通信，这一部分和之前介绍的内容是一样的。
相对地，内网部分则分配私有地址，内网中的设备不能和互联网直接收发网络包，而是通过**地址转换机制**进行连接。


### 3.4.2 地址转换的基本原理
地址转换的基本原理是**在转发网络包时对IP头部中的IP地址和端口号进行改写**。
具备地址转换功能的设备不仅有路由器，有些防火墙也有地址转换功能，它的工作方式和路由器是相同的。
地址转换设备将发送方IP地址从私有地址改写成公有地址。
端口号也需要进行改写，地址转换设备会随机选择一个空闲的端口。然后，改写前的私有地址和端口号以及改写后的公有地址和端口号，会作为一组相对应的记录保存在地址转换设备内部的一张表中。

改写发送方IP地址和端口号之后，包就被发往互联网，最终到达服务器，然后服务器会返回一个包。服务器返回的包的接收包是原始包的发送方，因此返回的包的接收方就是改写后的公有地址和端口号。
**这个公有地址其实是地址转换设备的地址**，因此这个返回包就会到达地址转换设备。

**地址转换设备会从地址对应表中通过公有地址和端口号找到相对应的私有地址和端口号，并改写接收方信息，然后将包发给公司内网，这样包就能够到达原始的发送方了**。在后面的包收发过程中，地址转换设备需要根据对应表查找私有地址和公有地址的对应关系，再改写地址和端口号之后进行转发。当数据收发结束，进入断开阶段，访问互联网的操作全部完成后，对应表中的记录就会被删除。 通过这样的机制，具有私有地址的设备就也可以访问互联网了。
从互联网一端来看，实际的通信对象是地址转换设备（路由器）。


### 3.4.3 改写端口号的原因
但早期的地址转换机制是只改写地址，不改写端口号的。
这会导致用这种方法的前提是私有地址和公有地址必须一一对应，也就是说，有多少台设备要上互联网，就需要多少个公有地址。（要不然地址和端口对应表中，就没法区分不同的私有地址了，）
当然，访问动作结束后可以删除对应表中的记录，这时同一个公有地址可以分配给其他设备使用，因此只要让公有地址的数量等于同时访问互联网的设备数量就可以了。
然而公司人数一多，同时访问互联网的人数也会增加。一个几千人的公司里，有几百人同时访问互联网是很正常的，这样就需要几百个公有地址。改写端口号正是为了解决这个问题。客户端一方的端口号本来就是从空闲端口中随机选择的，因此改写了也不会有问题。端口号是一个16比特的数值，总共可以分配出几万个端口 ，因此如果用公有地址加上端口的组合对应一个私有地址，一个公有地址就可以对应几万个私有地址，这种方法提高了公有地址的利用率。
**重点：端口号用来区分私有地址**
PS：16比特可以表示65536个端口号，但并不是所有这些端口都可以用于地址转换。

### 3.4.4 从互联网访问公司内网
对于从公司内网访问互联网的包，即便其发送方私有地址和端口号没有保存在对应表中也是可以正常转发的，
因为用来改写的公有地址就是地址转换设备自身的地址，而端口号只要随便选一个空闲的端口就可以了，这些都可以由地址转换设备自行判断。
然而，对于从互联网访问公司内网的包，如果在对应表中没有记录就无法正常转发。因为如果对应表中没有记录，就意味着地址转换设备无法判断公有地址与私有地址之间的对应关系。
换个角度来看，这意味着对于没有在访问互联网的内网设备，是无法从互联网向其发送网络包的。而且即便是正在访问的设备，也只能向和互联网通信中使用的那个端口发送网络包，无法向其他端口发送包。
也就是说，除非公司主动允许，否则是无法从互联网向公司内网发送网络包的。这种机制具有防止非法入侵的效果。
不过，有时候我们希望能够从互联网访问公司内网，这需要进行一些设置才能实现。之所以无法从互联网访问内网，是因为对应表里没有相应的记录，那么我们只要事先手动添加这样的记录就可以了。一般来说，用于外网访问的服务器可以放在地址转换设备的外面并为它分配一个公有地址，也可以将服务器的私有地址手动添加到地址转换设备中，这样就可以从互联网访问到这台具有私有地址的服务器了。
（地址转换设备的公有地址需要添加到DNS服务器中）
当外部公有地址的设备发来一个数据包时，其中接收方地址为公司内网对应的地址转换设备（路由器），当公司内网的路由器接收到该数据包时，它会查表，根据端口得知对应的内网私有地址，那么也就知道了是哪个设备该接收。


### 3.4.5 路由器的包过滤功能
包过滤也是路由器的一个重要附加功能。
包过滤就是在对包进行转发时，根据MAC头部、IP 头部、TCP头部的内容 ，**按照事先设置好的规则决定是转发这个包，还是丢弃这个包**。我们通常说的防火墙设备或软件，大多数都是利用这一机制来防止非法入侵的。
要注意只阻止非法访问而不影响正常访问是很难的。

为了防止从互联网非法入侵内网，我们可以将来自互联网的所有包都屏蔽掉，但是正如我们第2章介绍过的TCP的工作过程一样，网络包是双向传输的，如果简单地阻止来自互联网的全部包，那么从内网访问互联网的操作也会无法正常进行。  



# 第4章 通过接入网进入互联网内部――探索接入网和网络运营商



