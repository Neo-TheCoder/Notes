# 时间复杂度
## 定义
根据定义，时间复杂度指输入数据大小为`?`时，算法运行所需花费的时间。
需要注意：
统计的是算法的`「计算操作数量」`，而不是「运行的绝对时间」。
`计算操作数量` 和 `运行绝对时间` 呈正相关关系，并不相等。
算法运行时间受到「编程语言 、计算机处理器速度、运行环境」等多种因素影响。
例如，同样的算法使用 Pytho? 或 C++ 实现、使用 CPU 或 GPU 、使用本地 IDE 或力扣平台提交，运行时间都不同。
****

体现的是 `计算操作` 随 `数据大小?` 变化时的变化情况。
假设算
法运行总共需要「1次操作」、「100 次操作」，此两情况的时间复杂度都为常级 ?(1)；需要「? 次操作」、「100? 次操作」的时间复杂度都为?(?)


## 符号表示
根据输入数据的特点，时间复杂度具有「最差」、「平均」、「最佳」三种情况，分别使用 ? / Θ / Ω三种符号表示。
以下借助一个查找算法的示例题目帮助理解。

题目： 输入长度为 ? 的整数数组 nums ，判断此数组中是否有数字7 ，若有则返回 true ，否则返回 false
解题算法： 线性查找，即遍历整个数组，遇到 7 则返回 true 。
自然是使用遍历的方法

### 最佳情况
第一个数字就是7，只需要找1次

### 最坏情况
所有数字都不是7，循环N次

### 平均情况
需要考虑`输入数据的分布情况`，计算`所有数据情况下的 平均 时间复杂度`；
例如本题目，需要考虑数组长度、数组元素的取值范围等；

大O是最常使用的时间复杂度评价渐进符号

## 常见种类
O(1) < O(logN) < O(N) < O(NlogN) < O(N^2) < O(2^N) < O(N!)

0(N), 表示循环运行次数与N大小呈线性关系

指数O(2^N)，常见于递归
阶乘O(N!)，常用递归实现

对数O(logN)，
对数阶与指数阶相反，指数阶为 “每轮分裂出两倍的情况” ，而对数阶是 “每轮排除一半的情况” 。
常见于`二分法`、`分治`

线性对数O(NlogN)
两层循环的时间复杂度分别是O(logN)、O(N)
常见于排序算法：`快速排序`、`归并排序`、`堆排序`


# 空间复杂度
* 输入空间： 
    存储输入数据所需的空间大小；
* 暂存空间： 
    算法运行过程中，存储所有中间变量和对象等数据所需的空间大小；
* 输出空间： 
    算法运行返回时，存储输出数据所需的空间大小；

通常 空间复杂度指的是：输入数据大小为N时，算法运行所使用的 `暂存空间 + 输出空间` 的 总体大小

算法所使用的内存空间分为三类：
* 指令空间
    程序指令所使用的内存空间

* 数据空间
    算法中使用的各种常量、变量、动态数组、动态对象等所使用的内存空间

* 栈帧空间
也就是函数调用栈

通常情况下，空间复杂度统计算法在 “最差情况” 下使用的空间大小，以体现算法运行所需预留的空间量

最差情况是指：
* 最差输入数据
* 最差运行点

常见种类：
O(1) < O(logN) < O(N) < O(N^2) < O(2^N)

线性O(N)
一维数组、链表、哈希表等

O(N^2)
矩阵

O(2^N)
二叉树、多叉树
高度为N的满二叉树的节点数量为2^N

O(logN)
常见于分治算法的栈帧空间累计、数据类型转换等
如：
* 快速排序
    平均空间复杂度为logN，最差空间复杂度为O(N)
* 数字转化为字符串

对于算法的性能，需要从时间和空间的使用情况来综合评价。
优良的算法应具备两个特性，即时间和空间复杂度皆较低。
而实际上，对于某个算法问题，同时优化时间复杂度和空间复杂度是非常困难的。
降低时间复杂度，往往是以提升空间复杂度为代价的，反之亦然




# 动态规划
包含`分治思想`、`空间换时间`、`最优解`

`「分治」`是算法中的一种基本思想，其通过将`原问题`分解为`子问题`，不断`递归`地将`子问题`分解为`更小的子问题`，并通过`组合子问题的解`来得到`原问题的解`。

类似于分治算法，`「动态规划」`也通过`组合子问题的解`得到原问题的解。
不同的是，适合用动态规划解决的问题具有`「重叠子问题」`和`「最优子结构」`两大特性。

## 重叠子问题
动态规划的子问题是有重叠的，即各个子问题中包含重复的更小子问题。若使用暴力法穷举，求解这些相同子问题会产生大量的重复计算，效率低下。

`动态规划在第一次求解某子问题时，会将子问题的解保存`；后续遇到重叠子问题时，则直接通过`查表`获取解，保证每个独立子问题只被计算一次，从而降低算法的时间复杂度。

## 最优子结构
如果一个问题的`最优解`可以由其`子问题的最优解`组合构成，并且这些子问题可以`独立求解`，那么称此问题具有`最优子结构`。

动态规划从基础问题的解开始，不断迭代组合、选择子问题的最优解，最终得到原问题最优解。

## 以斐波那契数列为例
递归本质上是基于分治思想的从顶至底的解法。借助记忆化递归思想，可应用动态规划从底至顶求取f(n) ，代码如下所示。
```cpp
// 求第 n 个斐波那契数
int fibonacci(int n) {
    if (n == 0)
        return 0;          // 若求 f(0) 则直接返回 0
    vector<int> dp(n + 1, 0);      // 初始化 dp 列表
    dp[1] = 1;                     // 初始化 f(0), f(1)
    for (int i = 2; i <= n; i++) { // 状态转移求取 f(2), f(3), ..., f(n) 
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];                  // 返回 f(n)
}
```
### 转移方程
```
f(n) = f(n-1) + f(n-2)
```
而f(n)只与f(n-1)和f(n-2)相关，其实只要用两个变量交替前进计算
空间复杂度降低到O(1)
```cpp
// 求第 n 个斐波那契数
int fibonacci(int n) {
    if (n == 0)
        return 0;           // 若求 f(0) 则直接返回 0
    int a = 0, b = 1;               // 初始化 f(0), f(1)
    for (int i = 2; i <= n; i++) {  // 状态转移求取 f(2), f(3), ..., f(n) 
        int tmp = a;
        a = b;
        b = tmp + b;
    }
    return b;                       // 返回 f(n)
}
```
`记忆化递归`和 `动态规划`的本质思想是一致的
记忆化递归是`从 顶 至 底`
动态规划是`从 底 至 顶`

















