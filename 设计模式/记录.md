						# 前言


写程序，对于大型程序尤为明显：需要考虑到复用性、扩展性、灵活性、可维护
并非简单地上手，面向过程就完事了
这必然涉及到面向对象的思想 --> 封装、继承、多态

解耦合 --> 业务逻辑和界面逻辑分开 --> 容易维护、扩展

eg 计算器这种小型程序可以单独写一个运算类，多平台需要运算都可以用到它

解耦合的程度需要注意：比如计算器的程序里面，本来只有加法，如果加一个开根，那就不需要加法的代码重复进行编译


简单工厂模式：
由于实例化谁、将来是否会增加实例化的对象，这是容易变化的，考虑用一个单独的类来做这个创造实例的过程，这就是工厂。
--> 根据运算符做不同的实例化，然后返回一个父类（指向基类）

UML类图：多看就熟悉了

组合关系中：二者（譬如翅膀和鸟）生命周期也是相同的







						# 第二章 策略模式
面向对象，并非类越多越好，类的划分只是为了封装，分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类。

简单工厂模式：面对商家促销问题，不是最好的八法，促销算法时常变动，每次维护或者扩展收费方式都要改动这个工厂。

策略模式：
定义了算法家族，分别封装，让他们之间可以相互替换。

把算法抽出来作为一个类






						# 第三章 单一职责原则







						# 第四章 开放封闭原则
The Open-Closed Principle
软件实体（类、模块、函数等等）应该可以扩展，但是不可以修改。

对于扩展开放、对于更改封闭
需求是必然不断变化的，设计要面对需求的改变保持相对稳定，不断迭代。
设计的时候，要考虑尽量要让类足够好，写好了就不修改了，如果有新需求，增加一些类就OK了，原来的代码能不动就不动。
猜测最有可能发生的变化种类，构造抽象来隔离那些变化
面对需求，对程序的改动是通过增加新代码达到的，而不是更改现有的代码。

拒绝不成熟的抽象和抽象本身一样重要。







						# 第六章 装饰器模式
把所需的功能按正确的顺序串联起来进行控制
装饰模式：动态地给一个对象添加一些额外的职责（装饰模式比生成子类更为灵活）







						# 第十五章 抽象工厂模式








						# reactor模式









						# 第二十一章 单例模式
单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点

让类自身负责保存它的唯一实例，这个类看可以保证没有其他实例可以被创建，并且它提供一个访问该实例的方法






						# 访问者(visitor)模式











