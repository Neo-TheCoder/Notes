# 前言

写程序，对于大型程序尤为明显：需要考虑到复用性、扩展性、灵活性、可维护
并非简单地上手，面向过程就完事了
这必然涉及到面向对象的思想 --> 封装、继承、多态
解耦合 --> 业务逻辑和界面逻辑分开 --> 容易维护、扩展
eg 计算器这种小型程序可以单独写一个运算类，多平台需要运算都可以用到它
解耦合的程度需要注意：比如计算器的程序里面，本来只有加法，如果加一个开根，那就不需要加法的代码重复进行编译

简单工厂模式：
由于实例化谁、将来是否会增加实例化的对象，这是容易变化的，考虑用一个单独的类来做这个创造实例的过程，这就是工厂。
--> 根据运算符做不同的实例化，然后返回一个父类（指向基类）

UML类图：多看就熟悉了
组合关系中：二者（譬如翅膀和鸟）生命周期也是相同的


# 第二章 策略模式
面向对象，并非类越多越好，类的划分只是为了`封装`，分类的基础是`抽象`，具有`相同属性和功能`的对象的抽象集合才是类。

简单工厂模式：面对商家促销问题，不是最好的八法，促销算法时常变动，每次维护或者扩展收费方式都要改动这个工厂。

策略模式：
定义了`算法家族`，`分别封装`，让他们之间可以相互替换。

把算法抽出来作为一个类

# 第三章 单一职责原则




# 第四章 开放封闭原则
The Open-Closed Principle
软件实体（类、模块、函数等等）应该可以扩展，但是不可以修改。

对于扩展开放、对于更改封闭
需求是必然不断变化的，设计要面对需求的改变保持相对稳定，不断迭代。
设计的时候，要考虑尽量要让类足够好，写好了就不修改了，如果有新需求，增加一些类就OK了，原来的代码能不动就不动。
猜测最有可能发生的变化种类，构造抽象来隔离那些变化
面对需求，对程序的改动是通过增加新代码达到的，而不是更改现有的代码。

拒绝不成熟的抽象和抽象本身一样重要。


# 第六章 装饰器模式
把所需的功能按正确的顺序串联起来进行控制
装饰模式：动态地给一个对象添加一些额外的职责（装饰模式比生成子类更为灵活）



# 第七章 代理模式
为其他对象提供一种代理以控制对这个对象的访问
`Client`、`RealSubject`、`Proxy`（共同父类`Subject`）

`追求者`给`被追求者`送礼物，是通过`代理`，所以`追求者`和`代理`具有相同的接口。

`追求者`和`代理`都继承同一套接口`GiveGit`。而`追求者`和`代理`都需要**实现**`送礼物`接口，而在`代理`的实现中，需要调用`追求者`的方法（`代理`持有`追求者`对象的引用）。


## 使用场景
1. 远程代理
为一个对象在不同的地址空间提供局部代表，隐藏一个对象存在于不同地址空间的事实

2. 虚拟代理
创建开销很大的对象，通过它来存放实例化需要很长时间的真实对象

3. 安全代理





















# 第十五章 抽象工厂模式




# reactor模式





# 第二十一章 单例模式
单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点

让类自身负责保存它的唯一实例，这个类看可以保证没有其他实例可以被创建，并且它提供一个访问该实例的方法



# 访问者(visitor)模式






# Builder模式
用于构建复杂对象，将对象的构建与表示分离，使得可以用相同的构建过程创建不同的表示
包括以下角色：
Director：根据特定的构建过程调用Builder的方法来构建对象，定义构建顺序，但不知道具体构建细节
Builder：抽象构建者，定义了创建产品的抽象接口，如创建部件，设置属性等
ConcreteBuilder：实现Builder接口，在其中实现具体方法，并保存最终构建出的产品
Product：由多个部件组成的复杂对象，包含了所需的所有属性和方法
该设计模式可将对象的构建过程各个部分解耦，使得构建算法独立于具体的部件组装过程，**使得可以调用不同的具体构建者，创建出不同类型的产品*
以下是Builder模式的基本流程：

使用具体构建者创建一个对象构建器（Builder）。
按照需要调用构建器的方法设置对象的各个部件（属性）。
调用构建器的构建方法，将部件组装成最终的产品。
将构建出的产品从构建者中获取，并进行后续的操作。

