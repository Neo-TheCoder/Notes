# GIT管理的基本结构
1. Working Tree 当前的工作区域
2. Index/Stage 暂存区
3. Repository 版本库，提交的历史（git commit提交的结果）
4. Remote Repository 远程版本库

# 版本管理的基本命令
`*git revert -n <commit_id>`
撤销该版本的修改，不会删除repo里的原有版本，而是会增加一个新版本
比如，我们 commit 了三个版本（版本一、版本二、 版本三），突然发现版本二不行（如：有 bug），想要撤销版本二，但又不想影响撤销版本三的提交，就可以用 git revert 命令来反做版本二，生成新的版本四，这个版本四里会保留版本三的东西，但撤销了版本二的东西。
当然，如果之前（版本三）和之后（版本二）版本有改到同一个地方可能会触发冲突，需要手动解决冲突。

`git rebase`
git rebase 的功能是完成变基的操作，常常用来进行对 commit 进行整理，如合并多个 commit。
常用的命令是 git rebase -i [startpoint] [endpoint] 
用来交互式整理指定范围的commit。

`git reset`
git reset 有三种模式，即：
* --soft
不删除工作空间改动代码，撤销 commit，不撤销 git add .
```sh
git reset --soft HEAD~1
```
表示撤销最后一次的 commit ，1 可以换成其他更早的数字  

* --mixed（默认）
撤销 commit、并撤销 git add. 操作、不撤销修改代码，也就是说，除了工作区，全部撤销

* --hard
    本地代码会直接变更为指定的提交版本，慎用
删除工作空间改动代码，撤销 commit，撤销 git add .
也就是说，工作区、暂存区、本地分支三大空间全部撤销
注意完成这个操作后，就恢复到了上一次的commit状态。
```sh
git reset --hard HEAD~1
```

# 常见场景
## 工作区的代码想撤销
`git checkout -- <file>`
撤销当前工作目录中指定文件的修改

## add 到暂存区的代码想撤销
`git reset HEAD`
将已经 add 到暂存区的代码撤销到工作区，即`add 操作的逆操作`

## 提交到本地仓库的代码想撤销
也就是撤销`git commit的操作`
可以利用：`git reset --hard <版本号>`命令来实现版本回退，该命令中的版本号有几种不同的写法：
1. 可以使用 HEAD^ 来描述版本，一个 ^ 表示前一个版本，两个 ^^ 表示前两个版本，以此类推；
2. 也可以使用数字来代替 ^，比如说前 100 个版本可以写作 HEAD~100；
3. 也可以直接写版本号，表示跳转到某一个版本处。每次提交后，都会生成一个哈希码作为版本号，所以这里可以直接填版本号，哈希码很长，但是不用全部输入，只需要输入前面几个字符即可。
**注意：此操作会直接将`工作区`，`暂存区`的当前内容`清空`，并撤回到指定回退版本的状态**

## 远程仓库的代码想撤销
**本地撤销后，push 到远程即可**。
可能会报错远程分支比当前本地分支超前，可以通过该 -f 参数强制 push 到远程。

## 版本回退误操作的补救
有时可能发生一些意外，特别是 git reset --hard 这个死亡操作，更是可能产生严重后果。
如果发现 git reset --hard 误操作了，在某些情况下是可以还原的：
1. 想还原被回退了的那些 commits 的内容，比较简单；
2. 想还原被 add 但是没有 commit 的内容，比较复杂；
3. 想还原没有 add 的内容，别做梦了，基本不可能。 首先的首先，切记，还原操作之前，先把当前的内容做好备份！


# `git branch -vv`


# `git rebase`
rebase，变基，可以直接理解为`改变基底`。
feature分支是基于master分支的B拉出来的分支，feature的基底是B。而master在B之后有新的提交，就相当于此时要用master上新的提交来作为feature分支的新基底。
实际操作为把B之后feature的提交先暂存下来，然后删掉原来这些提交，再找到master的最新提交位置，把存下来的提交再接上去（接上去是逐个和新基底处理冲突的过程），如此feature分支的基底就相当于变成了M而不是原来的B了。
（`注意，如果master上在B以后没有新提交，那么就还是用原来的B作为基，rebase操作相当于无效，此时和git merge就基本没区别了，差异只在于git merge会多一条记录Merge操作的提交记录`）

上面的例子可抽象为如下实际工作场景：
远程库上有一个master分支目前开发到B了，
张三从B拉了代码到本地的feature分支进行开发，目前提交了两次，开发到D了；
李四也从B拉到本地的master分支，他提交到了M，然后合到远程库的master上了。
此时张三想从远程库master拉下最新代码，于是他在feature分支上执行了`git pull origin master:feature --rebase`（注意要加–rebase参数），即把远程库master分支给rebase下来，由于李四更早开发完，此时远程master上是李四的最新内容，rebase后再看张三的历史提交记录，就相当于是张三是基于李四的最新提交M进行的开发了。
（但实际上张三更早拉代码下来，李四拉的晚但提交早）






