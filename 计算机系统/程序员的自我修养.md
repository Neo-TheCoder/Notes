

### 1.4.2 设备驱动
考虑一个读取文件的操作：
文件系统保存了这些文件的存储结构，负责维护这些数据结构，并且保证磁盘中的扇区能够有效地组织和利用。
那么当我们在 Linux 操作系统中，要读取这个文件的前 4096 个字节时，我们会使用一个`read`的系统调用来实现。
文件系统收到`read`请求之后，判断出文件的前4096个字节位于磁盘的 1000 号逻辑扇区 ~ 1007 号逻辑扇区。
然后`文件系统`就向`硬盘驱动`发出一个请求：`读取逻辑扇区为 1000 号开始的 8 个扇区`，`磁盘驱动程序`收到这个请求以后就向`硬盘`发出`硬件命令`。

**向硬件发送 I/O 命令的方式有很多种，其中最为常见的一种就是通过`读写I/0 端口寄存器`来实现**。
在 x86 平台上，共有65536 个硬件端口寄存器，`不同的硬件`被分配到了`不同的 I/0 端口地址`。
CPU 提供了两条专门的指令`in`和`out`来实现对硬件端口的读和写。

对 IDE 接口（`Integrated Drive Electronics接口`）来说，它有两个通道，分别为 IDE0 和IDE1，每个通道上可以连接两个设备，分别为 Master 和 Slave，一个PC中最多可以有4个IDE设备。
假设我们的文件位于IDE0的Master硬盘上，这也是正常情况下硬盘所在的位置。
在 PC 中，IDE0 通道的I/O端口地址是`0x1F0 ~ 0x1F7`及`0x376 ~ 0x377`。
通过读写这些端口地址就能与IDE 硬盘进行通信。
这些端口的作用和操作方式十分复杂,我们以实现读取 1000 号逻辑扇区开始的8个扇区为例：
- 第 0x1F3 ~ 0x1F64 个字节的端口地址是用来写入LBA地址（`Logic Block Address`）的，那么1000号逻辑扇区的LBA地址为0x000003E8，所以我们需要往 0x1F3、0xlF4 写入0x00，往0x1F5 写入0x03，往0x1F6写入0xE8。
- 0x1F2 这个地址用来写入命令`所需要读写的扇区数`。比加读取8个扇区即写入8。
- 0x1F7 这个地址用来写入要执行的操作的`命令码`，对于读取操作来说，命令字为 0x20
所以我们要执行的指令为:
```sh
out 0x1F3, 0x00
out 0x1F4, 0x00
out 0x1F5, 0x03
out 0x1F6, 0xE8
out 0x1F2, 0x08
out 0x1F7, 0x20
```

在硬盘收到这个命令以后，它就会执行相应的操作，并且将数据读取到事先设置好的内存地址中(这个内存地址也是通过类似的命令方式设置的)。
当然这里的例子中只是最简单的情况，实际情况比这个复杂得多，驱动程序须要考虑硬件的状态(是否忙碌或读取错误)，调度和分配各个请求以达到最高的性能等。






### 1.5.3 分页

在页映射模式下，CPU 发出的是`Virtual Address`，即我们的程序看到的是虚拟地址。
经过`MMU转换`以就变成了`Physical Address`。
一般MMU都集成在CPU内部了，不会以独立的部件存在。









### 1.6.1 线程基础


#### 什么是线程
线程(Thread)，有时被称为`轻量级进程`(Lightweight Process,LWP)，是程序执行流的最小单元。
一个标准的线程由`线程 ID`、`当前指令指针(PC)`、`寄存器集合`和`堆栈`组成。
通常意义上，一个进程由一个到多个线程组成，各个线程之间共享一些资源：`程序的内存空间(包括代码段、数据段、堆等)`及`一些进程级的资源(如打开文件和信号)`。

#### 线程的访问权限
线程的访问非常自由，它可以访问进程内存里的所有数据，甚至包括其他线程的堆栈(如果它知道其他线程的堆栈地址，那么这就是很少见的情况)，但实际运用中**线程也拥有自己的私有存储空间**，包括以下几方面：
* 栈(尽管并非完全无法被其他线程访问，但一般情况下仍然可以认为是私有的数据)。
* 线程局部存储(Thread Local StorageTLS)。
    线程局部存储是某些操作系统为线程单独提供的私有空间，但通常只具有很有限的容量。
* 寄存器 (包括PC 寄存器)，寄存器是执行流的基本数据，因此为线程私有从 C 程序员的角度来看，数据在线程之间是否私有如表 1-1 所示。


|  线程私有   | 线程之间共享(进程所有)  |
|  ----  | ----  |
| 局部变量  | 全局变量 |
| 函数的参数 | 堆上的数据 |
| TLS数据 | 函数里的静态变量 |
|  | 程序代码(任何线程都有权利读取并执行任何代码) |
|  | 打开的文件(A线程打开的文件可以由B线程读写) |





### 1.6.2 线程安全
#### 竞争与原子操作
多线程不加锁执行++操作：
很明显，**自增(++)操作在多线程环境下会出现错误，是因为这个操作被编译为汇编代码之后不止一条指令，因此在执行的时候可能执行了一半就被调度系统打断，去执行别的代码**。
我们把单指令的操作称为原子的 (Atomic)，因为无论如何，单条指令的执行是不会被打断的。
为了避免出错，很多体系结构都提供了一些常用操作的`原子指令`，例如 i386 就有一条 inc 指令可以直接增加一个内存单元值，可以避免出现上例中的错误情况。

##### 互斥量 (Mutex)
和二元信号量很类似，资源仅同时允许一个线程访问，但和信号量不同的是，信号量在整个系统可以被任意线程获取并释放，也就是说，同一个信号量可以被系统中的一个线程获取之后由另一个线程释放。
而互斥量则要求哪个线程获取了互斥量，哪个线程就要负责释放这个锁，其他线程越俎代庖去释放互斥量是无效的。

##### 临界区 (Critical Section)
是比互斥量更加严格的同步手段。
在术语中，**把临界区的锁的获取称为进入临界区，而把锁的释放称为离开临界区**。
临界区和互斥量与信号量的区别在于：
互斥量和信号量在系统的任何进程里都是可见的，也就是说，一个进程创建了一个互斥量或信号量，另一个进程试图去获取该锁是合法的。
然而，临界区的作用范围仪限于本进程其他的进程无法获取该锁。
除此之外，临界区具有和互斥量相同的性质。

##### 读写锁 (Read-Write Lok)
致力于一种更加特定的场合的同步。
对于一段数据，多个线程同时读取总是没有问题的，但假设操作都不是原子型，只要有任何一个线程试图对这个数据进行修改，就必须使用同步手段来避免出错。
如果我们使用上述信号量、互斥量或临界区中的任何一种来进行同步，尽管可以保证程序正确，但对于读取频繁，而仅仅偶尔写入的情况，会显得非常低效。
读写锁可以避免这个问题。
对于同一个锁，读写锁有两种获取方式共享的(Shared)或独占的(Exclusive)。
当锁处于自由的状态时，试图以任何一种方式获取锁都能成功，并将锁置于对应的状态。
如果锁处于共享状态，其他线程以共享的方式获取锁仍然会成功，此时这个锁分配给了多个线程。
然而，如果其他线程试图以独占的方式获取已经处于共享状态的锁，那么它将必须等待锁被所有的线程释放。
相应地，处于独占状态的锁将阻止任何其他线程获取该锁，不论它们试图以哪种方式获取。

##### 条件变量 (Condition Variable) 
作为一种同步手段，作用类似于一个栅栏。
对于条件变量，线程可以有两种操作，首先线程可以等待条件变量，一个条件变量可以被多个线程等待。
其次，线程可以唤醒条件变量，此时某个或所有等待此条件变量的线程都会被唤醒并继续支持。
也就是说，使用条件变量可以让许多线程一起等待某个事件的发生，当事件发生时(条件变量被唤醒)，所有的线程可以一起恢复执行。


#### 可重入与线程安全
##### `可重入`
**一个函数被重入，表示这个函数没有执行完成，由于外部因素或内部调用，又一次进入该函数执行**。
一个函数要被重入，只有两种情况:
1. 多个线程同时执行这个函数。
2. 函数自身 (可能是经过多层调用之后) 调用自身

PS：若一个程序或子程序（或函数）可以“在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错”，也算是可重入。

一个函数被称为可重入的，表明该函数被重入之后不会产生任何不良后果。
举个例子：
如下面这个 sqr函数就是可重入的:
```cpp
int sqr(int x) {
    return x * x;
}
```
**一个函数要成为可重入的，必须具有如下几个特点**:
* 不使用任何(局部)静态或全局的非 const 变量。
* 不返回任何(局部)静态或全局的非const变量的指针。
* 仅依赖于调用方提供的参数。
* 不依赖任何单个资源的锁(mutex等)。
* 不调用任何不可重入的函数。

**可重入是并发安全的强力保障，一个可重入的函数可以在多线程环境下放心使用**

可以通过`volatile`关键字防止编译器过度优化（生成乱序代码）。
volatile基本可以做到两件事情:
1. 阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回。
2. 阻止编译器调整操作 volatile 变量的指令顺序。
但是无法阻止CPU动态调度换序指令。


一个函数被称为线程安全的，当且仅当被多个并发线程反复地调用时，它会一直产生正确的结果。
一个线程安全的函数可以被多个线程同时调用，即使调用使用共享数据，因为对共享数据的所有引用都是串行的
一个可重入函数也可以被多个线程同时调用，但前提是每个调用都使用自己的数据。

`线程安全`仅关心函数的实现，而不影响其外部接口。形参都是拷贝，不含别的全局资源，就是线程安全了，甚至不一定要加锁。



！！！**`可重入函数`未必是`线程安全`的；`线程安全函数`未必是`可重入`的**。
`可重入而非线程安全`
例如，一个函数打开某个文件并读入数据。
这个函数是可重入的，因为它的多个实例同时执行不会造成冲突；但它不是线程安全的，因为在它读入文件时可能有别的线程正在修改该文件，为了线程安全必须对文件加“同步锁”。
此处强调的是，一个函数同一时刻（被多个线程）多次执行也没事，但是另外一个函数可能访问和它有关的资源，读入可能有误。

`线程安全而非可重入`
另一个例子，函数在它的函数体内部访问共享资源使用了加锁、解锁操作，所以它是线程安全的，但是却未必可重入。
因为若该函数一个实例运行到已经执行加锁但未执行解锁时被停下来，系统又启动该函数的另外一个实例，则新的实例在加锁处将转入等待。
如果该函数是一个中断处理服务，在中断处理时又发生新的中断将导致资源死锁。`fprintf函数`就是`线程安全但不可重入`。

判断一个函数是不是可重入函数，关键在与:
是否能能够在被中断后，处理完中断后恢复运行得到正确的结果。
在Linux中可以指执行完信号处理函数结果正确。
如果函数对异步信号处理程序的重入是安全的，那么就可以说函数是”异步-信号安全”的。
**可重入函数与是否使用锁无关，而线程安全大多需要锁机制来保证线程安全**。



### 2.1.1 预编译
一个包含hello world的源代码文件：`hello.c`和相关的头文件`stdio.h`被预编译器预编译成一个`.i`文件。对于C++而言，预编译后的文件扩展名是`.ii`。

#### 预编译过程：
处理那些源代码文件中，以`#`开始的预编译指令：`#include`、`#define`
主要处理规则如下:
* 将所有的`#define`删除，并且展开所有的宏定义。
* 处理所有`条件预编译指令`，比如“#if”、“ #ifdef”、“#elif”、“#else”、“#endif”
* 处理`#include`预编译指令，将被包含的文件插入到该预编译指令的位置。注意，这个过程是`递归`进行的，也就是说被包含的文件可能还包含其他文件。
* 删除所有的`注释`“//”和“/**/”。
* 添加`行号`和`文件名标识`，比如`#2“hello.c”2`，以便于编译时编译器产生调试用的行号信息及用于编译时产生`编译错误`或`警告`时能够显示行号。
* 保留所有的`#pragma`编译器指令，因为编译器须要使用它们。
经过预编译后的文件不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也已经被插入到.i文件中。



# 第七章 动态链接
## why need？
节省内存和磁盘  便于程序发布（无需每次更新时发布整个程序）
减少物理页面的换入换出
增加兼容性，一个程序在不同平台运行时，如果需要实现`printf()`功能，则平台提供动态链接库，实现`printf()`即可

## 问题
由于缺少有效的共享库版本管理机制，新旧模块间存在接口不兼容问题（windows dll）

从本质上讲，普通可执行程序和动态链接库中都包含指令和数据，这一点没有区别。
在使用动态链接库的情况下，程序本身被分为了**程序主要模块(Program1)**和**动态链接库(Lib.so)**，但实际上它们都可以看作是整个程序的一个模块，所以当我们提到程序模块时可以指程序主模块也可以指动态链接库。
在 Linux中，常用的C语言库的运行库 glibc，它的动态链接形式的版本保存在`Лib`目录下，文件名叫做`1ibc.so`。
整个系统只保留一份C语言库的动态链接文件“libc.so”
而所有的C语言编写的、动态链接的程序都可以在运行时使用它。当程序被装载的时候，系统的动态链接器会将程序所需要的所有动态链接库(最基本的就是libc.so)装载到进程的地址空间,并且将程序中所有未决议的符号绑定到相应的动态链接库中,并进行重定位工作。
程序与libc.so之间真正的链接工作是由`动态链接器`完成的，而不是由我们前面看到过的静态链接器ld完成的。也就是说，动态链接是把链接这个过程从本来的程序装载前被推迟到了装载的时候。可能有人会问，这样的做法的确很灵活，但是程序每次被装载时都要进行重新进行链接，是不是很慢？的确，动态链接会导致程序在性能的一些损失，但是对动态链接的链接过程可以进行优化，比如我们后面要介绍的`延迟绑定(LazyBinding)`等方法，可以使得动态链接的性能损失尽可能地减小。
据估算，动态链接与静态链接相比，性能损失大约在5%以下。当然经过实践的证明，这点性能损失用来换取程序在空间上的节省和程序构建和升级时的灵活性，是相当值得的。

## 7.3 地址无关代码
### 7.3.1 固定装载地址的困扰
通过上一节的介绍我们已经基本了解了动态链接的概念，同时，我们也得到了一个问题，那就是：**共享对象在被装载时，如何确定它在进程虚拟地址空间中的位置？**
为了实现动态链接，我们首先会遇到的问题就是共享对象地址的冲突问题。
让我们先来回顾一下第2章提到的，程序模块的指令和数据中可能会包含一些绝对地址的引用，`我们在链接产生输出文件的时候，就要假设模块被装载的目标地址`。
很明显，在动态链接的情况下，如果不同的模块目标装载地址都一样是不行的。
而对于单个程序来讲,我们可以手工指定各个模块的地址，比如把0x1000到0x2000 分配给模块 A，把地址 0x2000到0x3000分配给模块B。
但是，如果某个块被多个程序使用，甚至多个块被多个程序使用，那么管理这些模块的地址将是一件无比繁琐的事情。比如一个很简单的情况，一个人制作了一个程序，该程序需要用到模块 B，但是不需要用到模块 A，所以他以为地址 0x1000到0x2000 是空闲的，于是分配给了另外一个模块C。这样C和原先的模块 A的目标地址就冲突了，任何人以后将不能在同一个程序里面使用模块A和C。
想象一个有着成千上万个并且由不同公司和个人开发的共享对象的系统中,采用这种手工分配的方式几乎不可行。
不幸的是，早期的确有些系统采用了这样的做法，这种做法叫做静态共享库(Static Shared Library)，请注意，它跟静态库(Static Library)有很明显的区别。
`静态共享库`的做法就是将程序的各种模块统一交给操作系统来管理，操作系统在某个特定的地址划分出一些地址块，为那些已知的模块预留足够的空间。
静态共享库的目标地址导致了很多问题，除了上面提到的地址冲突的问题，静态共享库的升级也很成问题，因为升级后的共享库必须保持共享库中全局函数和变量地址的不变，如果应用程序在链接时已经绑定了这些地址，一旦更改，就必须重新链接应用程序，否则会引起应用程序的崩溃。
即使升级静态共享库后保持原来的函数和变最地址不变，只是增加了一些全局函数或变量，也会受到限制，因为静态共享库被分配到的虚拟地址空间有限，不能增长太多，否则可能会超出被分配的空间。种种限制和弊端导致了静态共享库的方式在现在的支持动态链接的系统中已经很少见，而彻底被动态链接取代。
我们只有在一些不支持动态链接的旧系统中还能看到静态共享库的踪影。目前知道的使用静态共享库的旧系统有：
* UNIX System Y Release 3.2(COFF format)。
* 旧的 Linux systems(a.out format)。
* BSD/OS derivative of 4.4BSD(a.out and ELF formats.)。
为了解决这个模块装载地址固定的问题，我们设想是否可以让共享对象在任意地址加载？
    这个问题另一种表述方法就是:共享对象在编译时不能假设自己在进程虚拟地址空间中的位置。
    与此不同的是，可执行文件基本可以确定自己在进程虚拟空间中的起始位置，因为可执行文件往往是第一个被加载的文件，它可以选择一个固定空闲的地址，比如Linux下般都是 0x08040000，Windows下一般都是 0x0040000。

### 7.3.2 装载时重定位
为了能够使共享对象在任意地址装载，我们首先能想到的方法就是静态链接中的`重定位`。
这个想法的基本思路就是，在链接时，对所有绝对地址的引用不作重定位，而把这一步推迟到装载时再完成。
一旦模块装载地址确定，即目标地址确定，那么系统就对程序中所有的绝对地址引用进行重定位。
假设函数`foobar`相对于代码段的起始地址是`0x100`，当模块被装载到`0x10000000`时，我们假设代码段位于模块的最开始，即代码段的装载地址也是`0x10000000`，那么我们就可以确定`foobar`的地址`0x10000100`。
这时候，系统遍历模块中的重定位表，把所有对foobar的地址引用都重定位至0x10000100。
事实上，类似的方法在很早以前就存在。早在没有虚拟存储概念的情况下，程序是直接被装载进物理内存的。
当同时有多个程序运行的时候，操作系统根据当时内存空闲情况，动态分配一块大小合适的物理内存给程序，所以程序被装载的地址是不确定的。
系统在装载程序的时候 需要对程序的指令和数据中对绝对地址的引用进行重定位。
但这种重定位比前面提到过的静态链接中的重定位要简单得多，因为`整个程序是按照一个整体被加载的，程序中指令和数据的相对位置是不会改变的`。
比如一个程序在编译时假设被装载的目标地址为0x1000，但是在装载时操作系统发现0x1000这个地址已经被别的程序使用了，从0x4000开始有一块足够大的空间可以容纳该程序，那么该程序就可以被装载至0x4000，程序指令或数据中的所有绝对引用只要都加上0x3000的偏移量就可以了。
我们前面在静态链接时提到过重定位，那时的重定位叫做`链接时重定位(LinkTime Relocation)`，而现在这种情况经常被称为`装载时重定位(LoadTime Relocation)`，在Windows中，这种装载时重定位又被叫做基址重置(Rebasing)，我们在后面将会有专门章节分析基址重置。
这种情况与我们碰到的问题很相似,都是 程序模块 在编译时 目标地址不确定 而需要在装载时将模块重定位。
但是装载时重定位的方法并不适合用来解决上面的共享对象中所存在的问题。
可以想象，动态链接模块被装载映射至虚拟空间后，指令部分是在多个进程之间共享的,由于装载时重定位的方法需要修改指令,所以没有办法做到同一份指令被多个进程共享，因为指令被重定位后对于每个进程来讲是不同的（因为虚拟地址的设定，进程空间相互隔离，无法直接拿到物理内存）。
当然，动态连接库中的`可修改数据部分`对于不同的进程来说有多个副本，所以它们可以采用装载时重定位的方法来解决。
Linux和GCC支持这种装载时重定位的方法，我们前面在产生共享对象时，使用了两个GCC参数“-shared”和“-fPIC”，如果只使用“-shared”，那么输出的共享对象就是使用装载时重定位的方法。

### 7.3.3 地址无关代码
那么什么是`“-PIC”`呢?使用这个参数会有什么效果呢?
装载时重定位是解决动态模块中有绝对地址引用的办法之一,但是它有一个很大的缺点是指令部分无法在多个进程之间共享，这样就失去了动态链接节省内存的一大优势。我们还需要有一种更好的方法解决共享对象指令中对绝对地址的重定位问题。
其实我们的目的很简单，`希望 程序模块中 共享的指令部分 在装载时 不需要因为装载地址的改变而改变`，所以实现的基本想法就是把 指令中 那些需要被修改的部分 分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。
这种方案就是目前被称为`地址无关代码(PiC, Position-independent Code)`的技术。
对于现代的机器来说，产生地址无关的代码并不麻烦。
我们先来分析模块中各种类型的地址引用方式。
这里 我们把 共享对象模块 中的 `地址引用` 按照是否为跨模块分成两类:
    `模块内部引用` 和 `模块外部引用`:
按照不同的引用方式又可以分为`指令引用`和`数据访问`，
这样我们就得到了如图 7-4 中的4种情况。
* 第一种是模块内部的函数调用、跳转等。
* 第二种是模块内部的数据访问，比如模块中定义的全局变量、静态变量。
* 第三种是模块外部的函数调用、跳转等。
* 第四种是模块外部的数据访问，比如其他模块中定义的全局变量，
```c
static int a;
extern int b;
extern void ext();

void bar() {
    a = 1;  // 2    模块内 数据访问
    b = 2;  // 4    模块外 数据访问
}

void foo() {
    bar();  // 1    模块内 跳转
    ext();  // 3    模块外 跳转
}
```
当编译器在编译pic.c时，它实际上并不能确定`变量b`和函数`ext()`是模块外部的还是模块内部的，因为它们有可能被定义在同一个共享对象的其他目标文件中。
**由于没法确定，编译器只能把它们都当作模块外部的函数和变量来处理**。
MSVC 编译器提供了declspec(dllimport)编译器扩展来表示一个符号是模块内部的还是模块外部的。

#### 类型1  模块内部调用或跳转
对于同一个模块的被调用函数和调用者，相对位置是固定的，比较简单，就是相对地址/寄存器的调用，指令不需要重定位

#### 类型2  模块内部数据访问
接着来看看第二种类型，模块内部的数据访问。
很明显，指令中不能直接包含数据的`绝对地址`，那么唯一的办法就是`相对寻址`。
我们知道，一个模块前面一般是若干个页的代码，后面紧跟着若干个页的数据，这些页之间的相对位置是固定的，也就是说，**任何一条指令与它需要访问的模块内部数据之间的相对位置是固定的**,那么只需要相对于当前指令加上固定的偏移量就可以访问模块内部数据了。
现代的体系结构中，数据的相对寻址往往没有相对与当前指令地址(PC)的寻址方式，所以ELF用了一个很巧妙的办法来得到`当前的PC值`，然后再加上一个偏移量就可以达到访问相应变量的目的了。
##### 如何得到PC
先调一个函数`get_pc_thunk.cx`，把返回地址的值放到ecx寄存器：把call的下一条指令的地址放到ecx寄存器
（当处理器执行call指令后，下一条指令（`add $0x118c, %ecx`）的地址 会被压到栈顶，而esp寄存器始终指向栈顶，当`_i686.get_pc_thunk.cx`执行`mov (%esp), %ecx`，返回地址就被赋值到ecx寄存器了）
该函数拿到`call xxx`的下一条指令的地址。模块装载地址 + 当前指令地址 + 偏移量（编译时肯定可以计算）= 变量地址（模块基址是不确定的，可能被加载到内存任意地方）。
`.text`和`.data`排布是固定的

#### 类型3  模块间数据访问
模块间的数据访问比模块内部稍微府烦一点，因为模块间的数据访问目标地址要等到`装载时`才决定，比如上面例子中的变量b，已被定义在其他模块中，并且该地址在装载时才能确定。
要使得代码地址无关，基本的思想就是把跟地址相关的部分放到数据段里面。
很明显，这些其他模块的全局变量的地址是跟模块装载地址有关的。
ELF的做法是在数据段里面建立一个`指向这些变量的指针数组`，也被称为`全局偏移表（GlobalOffset Table）`，当代码需要引用该全局变量时，可以通过GOT中相对应的项间接引用，这个表的表项由链接器在装载模块的时候对变量地址进行查找，从而填充。
既然编译时可以确定模块内部变量相对于当前指令的偏移，那么GOT相对于当前指令的偏移也可以确定。

#### 类型4  模块间调用、跳转
全局偏移表，保存目标函数地址

#### `-fpic和-fPIC`
以上参数可以使GCC产生地址无关代码。
小写的参数，产生的代码小且快。
由于地址无关代码都是和硬件平台相关的，不同的平台有着不同的实现，小写的参数在某些平台有所限制（全局符号的数量/代码长度）。

















