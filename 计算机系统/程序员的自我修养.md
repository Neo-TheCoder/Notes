

### 1.4.2 设备驱动
考虑一个读取文件的操作：
文件系统保存了这些文件的存储结构，负责维护这些数据结构，并且保证磁盘中的扇区能够有效地组织和利用。
那么当我们在 Linux 操作系统中，要读取这个文件的前 4096 个字节时，我们会使用一个`read`的系统调用来实现。
文件系统收到`read`请求之后，判断出文件的前4096个字节位于磁盘的 1000 号逻辑扇区 ~ 1007 号逻辑扇区。
然后`文件系统`就向`硬盘驱动`发出一个请求：`读取逻辑扇区为 1000 号开始的 8 个扇区`，`磁盘驱动程序`收到这个请求以后就向`硬盘`发出`硬件命令`。

**向硬件发送 I/O 命令的方式有很多种，其中最为常见的一种就是通过`读写I/0 端口寄存器`来实现**。
在 x86 平台上，共有65536 个硬件端口寄存器，`不同的硬件`被分配到了`不同的 I/0 端口地址`。
CPU 提供了两条专门的指令`in`和`out`来实现对硬件端口的读和写。

对 IDE 接口（`Integrated Drive Electronics接口`）来说，它有两个通道，分别为 IDE0 和IDE1，每个通道上可以连接两个设备，分别为 Master 和 Slave，一个PC中最多可以有4个IDE设备。
假设我们的文件位于IDE0的Master硬盘上，这也是正常情况下硬盘所在的位置。
在 PC 中，IDE0 通道的I/O端口地址是`0x1F0 ~ 0x1F7`及`0x376 ~ 0x377`。
通过读写这些端口地址就能与IDE 硬盘进行通信。
这些端口的作用和操作方式十分复杂,我们以实现读取 1000 号逻辑扇区开始的8个扇区为例：
- 第 0x1F3 ~ 0x1F64 个字节的端口地址是用来写入LBA地址（`Logic Block Address`）的，那么1000号逻辑扇区的LBA地址为0x000003E8，所以我们需要往 0x1F3、0xlF4 写入0x00，往0x1F5 写入0x03，往0x1F6写入0xE8。
- 0x1F2 这个地址用来写入命令`所需要读写的扇区数`。比加读取8个扇区即写入8。
- 0x1F7 这个地址用来写入要执行的操作的`命令码`，对于读取操作来说，命令字为 0x20
所以我们要执行的指令为:
```sh
out 0x1F3, 0x00
out 0x1F4, 0x00
out 0x1F5, 0x03
out 0x1F6, 0xE8
out 0x1F2, 0x08
out 0x1F7, 0x20
```

在硬盘收到这个命令以后，它就会执行相应的操作，并且将数据读取到事先设置好的内存地址中(这个内存地址也是通过类似的命令方式设置的)。
当然这里的例子中只是最简单的情况，实际情况比这个复杂得多，驱动程序须要考虑硬件的状态(是否忙碌或读取错误)，调度和分配各个请求以达到最高的性能等。






### 1.5.3 分页

在页映射模式下，CPU 发出的是`Virtual Address`，即我们的程序看到的是虚拟地址。
经过`MMU转换`以就变成了`Physical Address`。
一般MMU都集成在CPU内部了，不会以独立的部件存在。











