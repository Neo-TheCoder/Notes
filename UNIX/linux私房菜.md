


# 第二章 主机规划与磁盘分区
### 2.1.3 各硬件设备在Linux中的文件名
在Linux系统中，每个设备都被当成一个文件来对待
例如：SATA接口的硬盘的文件名称即为/dev/sd\[a-d]
虚拟机内使用/dev/vd\[a-p]

## 2.2 磁盘分区
### 2.2.1 磁盘连接的方式与设备文件名的关系
Linux是使用**侦测到的顺序**来决定设备文件名，并非与实际插槽代号有关

一个硬盘有多个盘片（受体积和成本限制，一般在5片以内），每个盘片包含两个**盘面**，每个盘面对应一个读/写磁头。
盘片的编号自下向上从0开始，如最下边的盘片有0面和1面，再上一个盘片就编号为2面和3面。
一个盘面上，**磁道**是一圈圈的同心圆（从最外层开始编号为0），每个磁道上的一段弧，称为一个**扇区**。扇区是磁盘的最小组成单元（每个扇区通常是4096Byte）
具有相同编号的磁道形成一个圆柱（类似于卷筒纸芯的形状），称之为**柱面**，整个磁盘的柱面数和一个盘面上的磁道数自然是相等的
并且每个盘面都有自己的磁头，因此盘面数等于总的磁头数
磁盘容量计算：存储容量 ＝ 磁头数 × 磁道(柱面)数 × 每道扇区数 × 每扇区字节数
PS：新的硬盘数据的密度都一致，这样磁道的周长越长，扇区就越多，存储的数据量就越大。

**块**是操作系统中最小的逻辑存储单位。操作系统与磁盘打交道的最小单位是磁盘块。通俗的来讲，在Windows下如NTFS等文件系统中叫做簇；在Linux下如Ext4等文件系统中叫做块（block）。
每个簇或者块可以包括2、4、8、16、32、64…2的n次方个扇区。
操作系统与内存操作，是虚拟一个页的概念来作为最小单位。

扇区 <= 块/簇 <= page

整个磁盘的第一个扇区最为重要，因为记录了整个磁盘的重要信息（称为**MBR格式**：Master Boot Record）
但是由于近年来磁盘的容量不断扩大，造成读写上的一些困扰， 甚至有些大于2TB以上的磁盘分区已经让某些操作系统无法存取。因此后来又多了一个新的磁盘分区格式，称为**GPT（GUID partition table）**
硬盘分区后才能有效使用



# 第五章 Linux的文件权限与目录配置
Linux的特色就是**多用户多任务环境**
Linux一般将文件可存取的身份分为三个类别：
1. owner
2. group
3. others（非本群组外的其他人）
三个类别各自具有`read/write/execute`权限

## 5.1 使用者与群组
### 1 文件拥有者

### 2 群组
使得文件能够某些群组的成员访问，其余人不能访问，而一个成员可以同时属于多个群组
多个用户虽然在同一群组内，但是我们可以设置“权限”， 好让某些使用者个人的信息不被群组的拥有者查询，实现“私人空间”。 而设置群组共享，则可使得资源共享。
而root什么都能访问

Linux中，系统上的账号、root的相关信息，都记录在`/etc/passwd`，Linux所有的群组名称都记录在`/etc/group`，个人密码：`/etc/shadow`

## 5.2 Linux文件权限概念
### 5.2.1 Linux文件属性
```sh
drwxrwxrwx  4 test test 4096 Dec 26 10:09 .
drwxrwxrwx 10 test test 4096 Dec 26 17:51 ..
drwxrwxrwx  3 test test 4096 Dec 26 17:43 apd
drwxrwxrwx  2 test test 4096 Dec 26 16:28 data
-rwxrwxrwx  1 test test  692 Sep 27 13:45 someip_event_method_field.xml
```
#### 第一栏
文件属性：
`- rwx rwx ---`
1. 第一个字符表示文件的类型：
    d：目录
    -：文件
    l：链接文件
    b：设备文件中的可随机存取设备
    c：设备文件中的一次性读取设备（键盘、鼠标）

2. 第一组rwx表示：**文件拥有者**可具备的权限
3. 第二组rwx表示：加入此群组的账号的权限
4. 第三组rwx表示：非本人、且没有加入本群组的账号的权限

#### 第二栏
表示有多少文件名链接到此节点（i-node）
每个文件都会将他的权限与属性记录到文件系统的i-node中，不过，我们使用的目录树却是使用文件名来记录， 因此每个文件名就会链接到一个i-node。这个属性记录的，就是有多少不同的文件名链接到相同的一个i-node号码。 

#### 第三栏
表示这个文件（或目录）的拥有者账号

#### 第四栏
表示这个文件的所属群组

#### 第五、六栏
大小，单位为Byte
文件创建日期/最近修改日期

PS：对于目录这种文件而言，没有x（执行权限）就无法进入，因为无法`cd`


### 5.2.2 如何改变文件属性与权限
`chgrp`：change group
改变文件所属群组

`chown`
改变文件拥有者
```sh
sudo chown bin initial-setup-ks.cfg # 将文件拥有者改为bin账号
sudo chown root:root initial-setup-ks.cfg # 修改文件拥有者、群组，中间用冒号隔开
```
**使用场景**
`cp`文件给别人时：
```sh
[root@study ~]# cp .bashrc .bashrc_test
[root@study ~]# ls -al .bashrc*
-rw-r--r--. 1 root root 176 Dec 29 2013 .bashrc
-rw-r--r--. 1 root root 176 Jun 3 00:04 .bashrc_test # 复制时，新文件的属性没变
```

`chmod`
改变文件的权限（SUID、SGID、SBIT等等）
```sh
[root@study ~]# chmod [-R] xyz 文件或目录
选项与参数：
xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。
-R : 进行递回（recursive）的持续变更，亦即连同次目录下的所有文件都会变更

# 数字方式
chmod 644 .bashrc

#字符方式
chmod u=rwx,go=rx .bashrc

# 去掉所有人的可执行权限
chmod a-x .bashrc
```

### 5.2.3 目录与文件之权限意义
#### 对于文件
文件是实际含有数据的地方，包括一般文本文件、数据库内容档、二进制可可执行文件（binary program）等等。 因此，权限对于文件来说，他的意义是这样的：
1. r （read）：
    可读取此一文件的实际内容，如读取文本文件的文字内容等；
2. w （write）：
    可以编辑、新增或者是修改该文件的内容（但**不含删除**该文件）；
3. x （eXecute）：
该文件具有可以被系统执行的权限。

#### 对于目录
目录主要的内容在记录文件名清单
1. r （read contents in directory）：
    表示具有读取目录结构清单的权限，所以当你具有读取（r）一个目录的权限时，表示你可以查询该目录下的文件名数据。
2. w （modify contents of directory）：
    表示你具有修改该目录结构清单的权限：
        创建新的文件与目录；
        删除已经存在的文件与目录（不论该文件的权限为何！）
        将已存在的文件或目录进行更名；
        搬移该目录内的文件、目录位置。
3. x （access directory）：
    **目录的x**代表的是使用者**能否进入该目录成为工作目录**（即当前目录）的用途

对一般文件而言，rwx主要是针对“文件的内容”来设计权限；
对目录来说，rwx则是针对“目录内的文件名列表”来设计权限。


### 5.2.4 Linux文件种类与扩展名
任何设备在Linux下面都是**文件**

#### 正规文件（regular file）
`ls -al`所显示出来的属性：第一个字符为`-`

##### 纯文本文件（ASCII）：
这是Linux系统中最多的一种文件类型，称为纯文本文件
举例来说，你可以下达`cat ~/.bashrc`就可以看到该文件的内容。

##### 二进制档（binary）：
系统其实仅认识且可以执行二进制文件（binary file）。
Linux中的可执行文件（scripts, 文字体批处理文件不算）就是这种格式。
举例来说，刚刚下达的指令`cat`就是一个binary file。

##### 数据格式文件（data）：
有些程序在运行的过程当中会读取某些特定格式的文件，
那些**特定格式**的文件可以被称为数据文件（data file）。
举例来说，Linux在使用者登陆时，都会将登录的数据记录在`/var/log/wtmp`那个文件内，该文件是一个data file，他能够通过`last`这个指令读出来！ 但是使用cat时，会读出乱码。因为他是属于一种特殊格式的文件。


#### 目录（directory）
`d`

#### 链接文件（link）
类似Windows系统下面的**快捷方式**
第一个属性为`l`

#### 设备与设备文件（device）
与系统周边及储存等相关的一些文件， 通常都集中在`/dev`这个目录之下。通常又分为两种：
1. 区块（block）设备文件
就是一些储存数据， 以提供系统随机存取的周边设备（如：硬盘与软盘）
你可以随机的在硬盘的不同区块读写，这种设备就是区块设备

2. 字符（character）设备文件
一些序列埠的周边设备（如键盘、鼠标等等）
特色就是**一次性读取**的，不能够截断输出
举例来说，你不可能让鼠标“跳到”另一个画面，而是“连续性滑动”到另一个地方啊！

#### 数据接口文件（sockets）
这种类型的文件通常被用在网络上的数据承接
我们可以启动一个程序来监听用户端的要求， 而用户端就可以通过这个socket来进行数据的沟通。
常在`/run`或`/tmp`这些个目录中看到这种文件类型

#### 数据输送档（FIFO, pipe）
FIFO也是一种特殊的文件类型，他主要的目的在解决多个程序同时存取一个文件所造成的错误问题

PS：一个Linux文件能不能被执行，与他的第一栏的十个属性有关， 与文件名根本一点关系也没有。并且，具有“可执行的权限”以及“具有可执行的程序码”是两回事。








# 第十九章 开机流程、模块管理与Loader
核心得要**侦测硬件**并**载入适当的驱动程序**后，接下来则必须要调用程序来准备好系统运行的环境，以让使用者能够顺利的操作整部主机系统。

## 19.1 Linux的开机流程分析
### 19.1.1 开机流程一览
目前各大Linux发行版的主流开机管理程序（Boot Loader）是grub2。
按下电源键后，计算机硬件会主动地**读取BIOS（Basic Input Output System）或UEFI BIOS来载入硬件信息**及进行**硬件系统的自我测试**，然后系统就会主动**读取第一个可开机的设备**（由BIOS设置），然后就可以**读入开机管理程序**了。
**boot loader**：可以**指定使用哪个核心文件来开机，并实际载入核心到内存中解压缩和执行**。核心运行时会**侦测所有硬件信息与载入适当的驱动程序使得整部主机开始运行**，然后操作系统就在PC上跑起来了。此时，Linux才会调用外部程序开始准备软件执行的环境，并实际载入所有系统运行所需的软件程序。最后系统就会等待用户的登录与操作。

#### 系统的开机过程
1. 载入 BIOS 的硬件信息与进行自我测试，并依据设置取得第一个可开机的设备；
2. 读取并执行第一个开机设备内MBR（Master Boot Record, 主要开机记录区）的 boot Loader （亦即是 grub2, spfdisk 等程序）；
3. 依据boot loader的设置载入Kernel，Kernel会开始侦测硬件与载入驱动程序；
4. 在硬件驱动成功后，Kernel会主动调用 **systemd** 程序，并以 default.target 流程开机；
    systemd 执行 sysinit.target 初始化系统及 basic.target 准备操作系统；
    systemd 启动 multi-user.target 下的本机与服务器服务；
    systemd 执行 multi-user.target 下的 /etc/rc.d/rc.local 文件；
    systemd 执行 multi-user.target 下的 getty.target 及登陆服务；
    systemd 执行 graphical 需要的服务

PS：MBR是磁盘最前面可安装boot loader的部分

### 19.1.2 BIOS,boot loader与kernel载入
在个人计算机架构下，你想要启动整部系统首先就得要让系统去载入BIOS（Basic Input Output System），并**通过BIOS程序去载入CMOS的信息**，并且借由CMOS内的设置值取得主机的各项硬件设置，例如：CPU与周边设备的沟通频率啊、开机设备的搜寻顺序啊、硬盘的大小与类型啊、系统时间啊、各周边总线的是否启动Plug and Play（PnP, 随插即用设备）啊、各周边设备的I/O位址啊、以及与CPU沟通的IRQ岔断等等的信息。








