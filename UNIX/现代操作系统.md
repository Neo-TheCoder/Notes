
# 第十章 UNIX
### 10.3.5 启动Linux系统
1. BIOS加电自检（POST），对硬件进行检测和初始化（因为OS的启动可能依赖于磁盘访问、屏幕、键盘等硬件设备）

2. 启动磁盘的**第一个扇区**（主引导记录MBR），被读取到固定的内存区域，运行，
在主引导记录中，有一个很小的程序（只有512字节），运行时从启动设备（如SATA磁盘、SCSI磁盘）调入一个名为**boot**的独立程序，它将自己复制到高地址的内存，**释放低地址的内存**
复制完毕，boot程序**读取启动设备的根目录**，那就必须理解文件系统和目录格式，这个工作交由**引导程序**（如GRUB：多系统启动管理器来完成）
Intel的LILO引导程序不依赖于任何特定的文件系统，而是需要一个块映射图和低层地址，从而找到需要被加载的扇区
然后boot**读入操作系统内核，把控制交给内核**，系统内核从此开始运行。
内核的启动代码是用和平台相关的汇编写成的，主要工作：创建内核堆栈、识别CPU类型、计算可用内存、禁用中断、启动内存管理单元
然后开始执行操作系统的主要部分（C语言写的），分配内核数据结构（大部分的大小是固定的，但是比如页面缓存和特殊的页表结构是依赖于可用内存的大小）
然后系统开始自动配置，探测哪些设备确实存在，如果被探测设备响应，该设备就被加入已连接设备。注意：Linux系统的设备驱动程序不需要静态链接至内核，而是可以被动态加载

当所有硬件都配置好了，就开始运行进程0，建立其堆栈，并运行，它做的都是初始化操作：配置实时时钟、挂载根文件系统、创建init进程（进程1）、以及页面守护进程（进程2）
init进程会检测标志以确定是为单用户还是多用户服务。
    对于单用户，init进程调用fork函数创建一个shell进程，并等待其结束
    对于多用户，init进程调用fork函数创建一个运行系统初始化shell脚本（/etc/rc）的进程：可以进行文件系统一致性检测、挂载附加文件系统、开启守护进程，然后从/etc/ttys中（记录所有的终端和他们的属性）读取数据，对于每一个启用的终端，这个进程调用fork函数创建一个自身的副本，进行内部处理，并运行一个名为getty的程序（为每条连线设置传输速率和其他属性），然后终端的屏幕上输出：login:，等待用户从键盘输入用户名，输入后，登录程序/bin/login开始运行（getty被login程序替换），它要求用户输入密码，并把密码加密，与保存在密码文件/etc/passwd的加密密码对比，如果正确，login程序就以用户shell程序替换自身，等待第一个命令
    当用户输入cp f1 f2命令时，shell程序调用fork创建一个子进程，并使得这个子进程运行cp程序，然后shell程序被阻塞，等待子进程结束



## 10.4 Linux中的内存管理
每个Linux进程都有一个地址空间，逻辑上分为三段：代码段、数据段、堆栈段
![](./现代操作系统/进程虚拟地址.png)


### 代码段
包含形成可执行代码的机器指令，由编译器和汇编器产生，代码段是只读的


















