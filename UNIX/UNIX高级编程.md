
# 第一章 UNIX基础知识
OS为运行的程序提供服务
典型的服务：
执行新程序、打开文件、读文件、分配存储区、获得当前时间

## 1.2 UNIX体系结构
UNIX操作系统的体系结构
**内核**：控制计算机硬件资源，提供程序运行环境
***系统调用***就是内核的接口。

应用程序既可以使用公用函数库，又可以使用系统调用。
shell是特殊的应用程序，为运行其他程序提供接口。

Linux是GNU操作系统使用的内核，因此可以称这种操作系统为GNU/Linux操作系统。


## 1.4 文件和目录
目录是一个包含**目录项**的文件。
每个目录项都包含一个文件名，同时还包含说明该文件属性（是普通文件还是目录、文件大小、所有者、权限、最后修改时间）的信息。


## 1.5 输入和输出
### 1.5.1 文件描述符
小的非负整数，内核用以标识一个特定进程正在访问的文件
当内核打开或创建一个新文件时，都会返回一个文件描述符，读写文件时可用。


### 1.5.2 标准输入、标准输出和标准错误
每当允许一个程序，所有shell都为其打开3个文件描述符：
标准输入、标准输出、标准错误
不做特殊处理则3个描述符都连接向终端
```shell
ls > file.list
# 使得描述符重定向到某个文件
```

### 1.5.3 不带缓冲的I/O函数
open read write lseek close
都会使用文件描述符

### 1.5.4 标准I/O函数
为那些不带缓冲的I/O函数提供一个带缓冲的接口
比如printf


## 1.6 程序和进程
### 1 程序
是一个存储在磁盘上某个目录中的可执行文件、内核使用exec函数，将程序读入内存，并执行程序

### 2 进程和进程ID
程序的`执行实例`被称为`进程`(process)，某些OS用`任务task`表示正在被执行的程序
UNIX系统确保每个进程都有一个唯一的标识符

### 3 进程控制
fork exec waitpid

### 4 线程和线程ID

通常一个进程只有一个控制线程thread――――某一时刻执行的一租机器指令
一个进程内的所有线程共享同一地址空间、文件描述符、栈以及进程相关的属性
线程ID只在所属的进程内起作用

## 1.7 出错处理
整型变量errno记录错误类型
```c
#include<errno.h>
extern int errno;
```
多线程环境中每个线程都有属于自己的局部errno


## 1.8 用户标识
### 1 用户ID
0标识root用户

### 2 组ID
用户组

### 3 附属组ID



## 1.9 信号
用于通知进程发生了某种情况
例如除数为0，则需要把SIGFPE的信号发给该异常。
进程对异常的处理：
1、忽略
2、默认方式：终止
3、捕捉，处理


## 1.10 时间值
1、日历时间
2、进程时间
    UNIX系统为一个进程维护3个进程时间值
    时钟时间
    用户CPU时间：执行用户指令所用的时间量
    系统CPU时间：为该进程执行内核程序所经历的时间


## 1.11 系统调用和库函数
通用库函数可能调用一个或多个内核的系统调用 并非内核的入口点
例如prinf函数会调用write系统调用以输出一个字符串
malloc调用sbrk

进程控制系统调用fork、exec wait通常直接由用户应用程序直接调用


# 第三章 文件IO
UNIX系统中的大多文件IO只用到:
open、read、write、lseek、close
这些函数都是不带缓冲的I/O(unbuffered I/O),意思是每个read和write都调用内核中的一个系统调用
本章涉及:多个进程间如何共享文件 以及涉及到的内核有关的数据结构

## 3.2 文件描述符
对于内核,所有打开的文件都通过文件描述符引用(一对一的标识打开的文件,用于read,write的参数)
UNIX系统shell把文件描述符0与进程的标准输入关联,即符号常量**STDIN_FILENO** 1--> 标准输出**STDOUT_FILENO**    2--> 标准错误**STDERR_FILENO**
文件描述符的变化范围:0 ~ OPEN_MAX - 1

## 3.3 函数open和openat
```cpp
#include<fcntl.h>
int open(const char* path, int oflag, ...);
int openat(int fd, const char* path, int oflag, ...);   // 用于相对路径
// 成功返回对应文件描述符 失败返回-1
```

***TOCTTOU: time of check to time of use***
如果有两个基于文件的函数调用,第二个依赖第一个的结果,这个程序就是脆弱的 因为两个调用**不是原子操作** 在两个函数调用之间文件可能改变

## 3.4 函数creat
创建新文件

## 3.5 函数close
关闭一个文件会释放该进程加在该文件上的所有记录锁
当一个进程终止,内核自动关闭所有它打开的文件

## 3.6 函数lseek
每个打开文件都维护一个"当前文件偏移量",记录从文件开始处的字节数
默认为0
```cpp
off_t currpos = lseek(fd, 0, SEE_CUR);
// 用于确定打开文件的当前偏移量
```
如果文件描述符指向一个管道 FIFO socket,lseek返回-1
文件偏移量可以大于文件的当前长度,对其下一次写将加长该文件,在文件中构成一个空洞(位于文件中但没有写过的字节都被读为0)
空洞不要求在磁盘上占用存储区

## 3.7 函数read
```cpp
#include <unistd.h>
ssize_t read(int fd, void* buf, size_t nbytes);
// 成功则返回读到的字节数
```
实际读到的字节数少于要求的字节数的情况，比如:
* 提前读到结尾
* 从终端设备读时，通常一次最多读一行
* 从网络读时，网络中的缓冲机制可能造成返回值小于所要求读的字节数
* 当从`管道或FIFO`读时，如若管道包含的字节少于所需的数量，那么 read 将只返回`实际可用的字节数`。
* 当从某些`面向记录`的设备(如磁带)读时，一次最多返回一个记录
* 当一信号造成`中断`，而`已经读了部分数据量`时。
读操作从文件的`当前偏移量`处开始，在成功返回之前，该偏移量将增加`实际读到的字节数`
(某些情况下，读操作可能会被中断信号提前结束)

POSIX.1 从几个方面对 read 函数的原型做了更改。
经典的原型定义是:
```cpp
int read(int fd, char *buf, unsigned nbytes);
```
首先，为了与`ISOC`一致，第2个参数由`char *`改为`void *`。
在ISOC中，类型`void*`用于表示通用指针。
其次，返回值必须是一个带符号整型(`ssize_t`)，以保证能够返回`正整数字节数`、`0`(表示文件尾端)或`-1`(出错)。
最后，第3个参数在历史上是一个无符号整型，这允许一个 16 位的实现一次读或写的数据可以多达 65534 个字节。
在1990 POSIX1标准中，引入了新的基本系统数据类型
`ssize_t`以提供带符号的返回值，不带符号的`size_t`则用于第3个参数(见2.5.2节中的`SSIZE_MAX常量`)。




## 3.8 函数write
```cpp
#include <unistd.h>
ssize_t write(int fd, void* buf, size_t nbytes);
// 成功则返回已写的字节数
```
其返回值通常与参数nbytes 的值相同，否则表示出错。
`write`出错的一个常见原因是`磁盘已写满`，
或者超过了一个`给定进程的文件长度限制`(见7.11 节及习题10.11)
对于`普通文件`，`写操作`从文件的`当前偏移量处`开始。
如果在打开该文件时，指定了`OAPPEND`选项，则在每次写操作之前，将文件偏移量设置在`文件的当前结尾处`。
在一次成功写之后，该文件偏移量增加实际写的字节数。


## 3.9 I/O的效率
使用`read`和`write`复制一个文件
```cpp
// 将标准输入复制到标准输出
#include "apue.h"
#define BUFFSIZE 4096
int main(void) {
    int n;
    char buf[BUFFSIZE];
    while (( n = read(STDIN_FILENO，buf，BUFFSIZE )) > 0)
    if (write(STDOUT_FILENO, buf, n) != n)
        err_sys("write error");
    if (n < 0)
        err_sys("read error");
    exit(0);
}
```
关于该程序应注意以下几点。
它从`标准输入`读，写至`标准输出`(二者当然也被抽象成文件了)，这就假定在执行本程序之前，这些标准输入、输出已由shell安排好(在执行程序之前，用户可以通过shell（如bash、zsh等）来设置程序的标准输入和标准输出)。
确实，所有常用的`UNIX 系统` `shell`都提供一种方法，它`在标准输入上``打开一个文件`用于读(标准输入的内容)，`在标准输出上``创建(或重写)`（标准输出的内容）一个文件。
这使得程序不必打开输入和输出文件，并允许用户利用`shell`的`IO重定向功能`。
考虑到`进程终止时`，`UNIX系统内核`会`关闭进程的所有打开的文件描述符`，所以此程序并不关闭输入和输出文件。
对UNIX系统内核而言，文本文件和二进制代码文件并无区别，所以本程序对这两种文件都有效。
我们还没有回答的一个问题是如何选取`BUFESIZE`值。
在回答此问题之前，让我们先用各种不同的`BUFESIZE`值来运行此程序。
图3-6 显示了用20种不同的缓冲区长度读`516581760`字节的文件所得到的结果。
用图 3-5 的程序读文件，其标准输出被重新定向到`/dev/nu11`上。
此测试所用的文件系统是`Linux ext4`文件系统，其磁盘块长度为`4096字节`
(磁盘块长度由`st_blksize`表示在4.12节中说明其值为`4096`)。
这也证明了图 3-6 中系统 CPU 时间的几个最小值差不多出现在`BUFFSIZE`为4096及以后的位置，
继续增加缓冲区长度对此时间几乎没有影响。

PS: `stdin`和`stdout`
在Linux中，标准输入（stdin）是一个文件描述符，通常用来表示程序接收输入的地方。
标准输入通常与终端键盘输入相关联，即程序从标准输入读取数据时，实际上是从用户在键盘上输入的数据中读取。标准输入的文件描述符为0。
标准输出（stdout）是Linux系统中的另一个文件描述符，通常用于表示程序输出的地方。
当程序产生输出时，输出通常会被发送到标准输出，从而显示在终端上。标准输出的文件描述符为1

大多数`文件系统`为改善性能都采用某种`预读 (read ahead)`技术
当检测到正进行顺序读取时，系统就试图`读入比应用所要求的更多数据`，并假想应用很快就会读这些数据。
预读的效果可以从图3-6中看出，缓冲区长度小至`32字节`时的时钟时间与拥有较大缓冲区长度时的时钟时间几乎一样。
我们以后还将回到这一实例上。
3.14 节将用此说明同步写的效果，5.8 节将比较不带缓冲的I/O时间与标准I/O库所用的时间。

应当了解，在什么时间对实施文件读、写操作的程序进行性能度量。
操作系统试图用高速缓存技术将相关文件放置在`主存`中，
所以如若重复度量程序性能，那么后续运行该程序所得到的计时很可能好于第一次。
其原因是，第一次运行使得`文件`进入`系统高速缓存`，后续各次运行一般从`系统高速缓存`访问文件，
无需读、写磁盘。
(incore这个词的意思是在主存中，早期计算机的主存是用铁氧体磁心(ferrite core)做的，这也是`“core dump`”这个词的由来：程序的`主存镜像`存放在`磁盘的一个文件`中以便测试诊断)。
在图 3-6 所示的测试教据中，不同缓冲区长度的各次运行使用不同的文件副本，所以后一次运行不会在前一次运行的高速缓存中找到它需要的数据。
这些文件都足够大，不可能全部保留在高速缓存中(测试系统配置了6GB RAM)。





## 3.10 文件共享
内核使用3种数据结构表示打开文件:
1. 每个进程有一个记录项:打开文件描述符表,持有每个文件描述符对应文件表项的指针
2. 内核为所有文件维护一个文件表,每一项包括
    文件状态标志(读\写\同步\非阻塞) --> 用于指定该文件表项的**任何进程**中的所有描述符,而文件描述符局限于一个进程
    当前文件偏移量
    指向该文件v节点表项的指针
3. 每个打开文件(或设备)都有一个v节点
    v节点:包含文件类型和对此文件进程各种操作函数的指针 此外 还包含该文件的i节点(i node索引节点 --> ***虚拟文件系统***)
    这些信息在打开文件时从磁盘读入内存
    i节点:包含问年所有者 文件长度 指向文件实际数据块在磁盘上所在位置的指针

如果两个独立进程各自打开一个文件,那么这两个进程表项(假设文件描述符分别为3, 4)指向**两个文件表项**(见图),它们指向同一个V节点表项
毕竟每个进程都需要拥有自己对该文件的当前偏移量
但也可能有多个文件描述符指向同一文件表项 --> dup函数 / fork父子进程共享


## 3.11 原子操作
### 1. 追加到一个文件

举例:
AB进程对同一文件追加,
可能存在这种情况:   
    A先定位(lseek)，
    B定位，写
    A再写, A就把B写的内容覆盖了（因为多次定位之间信息不同步）
追加的write操作是先定位到文件尾端，再写，本质上是两个分开的函数调用，应该要合成原子操作
`任何要求多于一个函数调用的操作都不是原子操作`，因为`两个调用之间,内核可能挂起进程`
对于以上情况,内核提供`原子操作`:
    打开文件时设置`O_APPEND`标志,这样`内核在每次写操作之前`，都将进程的`当前偏移量`设置到`结尾`，不用每个进程调用`lseek`

### 3.11.2 函数pread和pwrite
pread 等价于 lseek read
但无法中断定位和读操作 并且 不更新当前文件偏移量

### 3.11.3 创建一个文件
同理 open和creat不是原子操作

## 3.12 函数dup和dup2
用于复制现有的文件描述符
目的是共享同一文件状态标志,以及当前文件偏移量

```c
    dup(fd);
    // 等价于:
    fcntl(fd, F_DUPFD, 0);

    dup2(fd, fd2);
    // 等价于:
    close(fd2); // 若fd2已打开,则先关闭
    fcntl(fd, F_DUPFD, fd2);
    // 但是dup2是原子操作
```


## 3.13 函数`sync`、`fsync`和`fdatasync`
UNIX内核中设有缓冲区高速缓存或页高速缓存
大多`磁盘I/O`通过`缓冲区`进行
### `延迟写`
向文件写入数据时,内核先将数据复制到`缓冲区`,然后排入`队列`,`晚点再写`入磁盘
当内核需要`重用缓冲区`来存放其他磁盘块数据时,会把所有`延迟写数据块``写入磁盘`
为了保证`磁盘上实际文件系统`和`缓冲区内容`的一致性,提供三个`sync函数`

### `sync`
(异步)
只将所有`修改过的块缓冲区`排入写队列,然后直接返回,
不等待实际磁盘操作结束
通常，名为`update的系统守护进程`周期性调用(一般每隔30秒)`sync`，从而保证`定期flush`内核的块缓冲区

### `fsync`
(同步)
只对由fd指定的`一个文件`起作用，等待写磁盘操作结束才返回
fsync可用于`数据库`这样的应用程序,确保`修改过的块``立即写到磁盘`

### `fdatasync`
相比fsync只影响文件的`数据部分`，而sync除了数据，还`同步更新文件的属性`


## 3.14 函数fcntl
改变已打开文件的属性
```c
int fcntl(int fd, int cmd, ...);
// cmd有11个
```
有5个功能:
复制已有的描述符 获取/设置文件描述符标志 获取/设置文件状态标志 获取/设置异步I/O所有权 获取/设置记录锁


## 3.15 函数ioctl
I/O操作的杂物箱


## 3.16 /dev/fd
该目录的目录项时名为0,1,2等的文件
打开文件/dev/fd/n等价于复制描述符n
主要由shell使用




# 第四章 文件和目录
## 4.2 函数`stat`、`fstat`、`fstatat`和`lstat`
```c
#include <sys/stat.h>
int stat(const char *restrict pathname, struct stat *restrict bu);
int fstat(int fd, struct stat *bu);
int stat(const char *restrict pathname, struct stat *restrict buf);
int fstatat(int fd, const char *restrict palame, struct stat *restrict buf, int flag);
```
所有4个函数的返回值:
    若成功，返回0;若出错，返回-1




### `stat`
一旦给出`pathname`，stat函数将返回与此`命名文件`有关的`信息结构`。

### `fstat`
已在描述符fd上打开文件的有关信息。

### `fstatat`
`fstatat`函数为一个`相对于当前打开目录`(由fd参数指向)的路径名返回文件统计信息
flag参数控制着是否跟随着一个符号链接
当`AT_SYMLINK NOFOLLOW`标志被设置时，fstatat不会跟随符号链接，而是返回符号链接本身的信息。
否则，在默认情况下，返回的是符号链接所指向的实际文件的信息。
如果fd参数的值是`ATFDCWD`，并且pathname 参数是一个相对路径名
fstatat会计算相对于当前目录的pathname参数。
如果pathname 是一个绝对路径d参数就会被忽略。
这两种情况下，根据 flag 的取值，fstatat 的作用就跟 stat 或lstat--样


### `lstat`
`lstat`函数类似于`stat`，
但是当命名的文件是一个符号链接时，`lstat`返回`该符号链接`的有关信息，而不是由该符号链接引用的文件的信息。


第2个参数 bu是一个指针，它指向一个我们必须提供的结构。函数来填充由 buf指向的结
构。
结构的实际定义可能随具体实现有所不同，但其基本形式是:
```cpp
#ifdef __USE_LARGEFILE64
/* Note stat64 has the same shape as stat for x86-64.  */
struct stat64
  {
    __dev_t st_dev;             /* Device.  */
# ifdef __x86_64__
    __ino64_t st_ino;           /* File serial number.  */
    __nlink_t st_nlink;         /* Link count.  */
    __mode_t st_mode;           /* File mode.  */
# else
    unsigned int __pad1;
    __ino_t __st_ino;                   /* 32bit file serial number.    */
    __mode_t st_mode;                   /* File mode.  */
    __nlink_t st_nlink;                 /* Link count.  */
# endif
    __uid_t st_uid;             /* User ID of the file's owner. */
    __gid_t st_gid;             /* Group ID of the file's group.*/
# ifdef __x86_64__
    int __pad0;
    __dev_t st_rdev;            /* Device number, if device.  */
    __off_t st_size;            /* Size of file, in bytes.  */
# else
    __dev_t st_rdev;                    /* Device number, if device.  */
    unsigned int __pad2;
    __off64_t st_size;                  /* Size of file, in bytes.  */
# endif
    __blksize_t st_blksize;     /* Optimal block size for I/O.  */
    __blkcnt64_t st_blocks;     /* Nr. 512-byte blocks allocated.  */
# ifdef __USE_XOPEN2K8
    /* Nanosecond resolution timestamps are stored in a format
       equivalent to 'struct timespec'.  This is the type used
       whenever possible but the Unix namespace rules do not allow the
       identifier 'timespec' to appear in the <sys/stat.h> header.
       Therefore we have to handle the use of this header in strictly
       standard-compliant sources special.  */
    struct timespec st_atim;            /* Time of last access.  */
    struct timespec st_mtim;            /* Time of last modification.  */
    struct timespec st_ctim;            /* Time of last status change.  */
# else
    __time_t st_atime;                  /* Time of last access.  */
    __syscall_ulong_t st_atimensec;     /* Nscecs of last access.  */
    __time_t st_mtime;                  /* Time of last modification.  */
    __syscall_ulong_t st_mtimensec;     /* Nsecs of last modification.  */
    __time_t st_ctime;                  /* Time of last status change.  */
    __syscall_ulong_t st_ctimensec;     /* Nsecs of last status change.  */
# endif
# ifdef __x86_64__
    __syscall_slong_t __glibc_reserved[3];
# else
    __ino64_t st_ino;                   /* File serial number.          */
# endif
  };
#endif
```
注意，`stat`结构中的大多数成员都是基本系统数据类型(见2.8 节)我们将说明此结构的每个成员以了解文件属性。
使用 stat 函数最多的地方可能就是`ls -l`，用其可以获得有关一个文件的所有信息。

注意到：
```c
    struct timespec st_atim;            /* Time of last access.  */
    // 最近打开文件的时间，读一次这个文件的内容，这个时间就会更新。比如对这个文件运用 more、cat等命令。但是ls、stat命令都不会修改文件的访问时间。

    struct timespec st_mtim;            /* Time of last modification.  */
    // 最近修改文件内容的时间 ,修改时间，修改时间是文件内容最后一次被修改时间 比如：vi后保存文件。ls -l列出的时间就是这个时间。

    struct timespec st_ctim;            /* Time of last status change.  */
    // 最近改动Inode的时间，状态改动时间。是该文件的i节点最后一次被修改的时间 通过chmod、chown命令修改一次文件属性，这个时间就会更新。

```




## 4.3 文件类型
至此我们已经介绍了两种不同的文件类型: `普通文件`和`目录`。
UNIX 系统的大多数文件是普通文件或目录，但是也有另外一些文件类型。
文件类型包括如下几种
1. `普通文件(regular file)`
这是最常用的文类型，这种文件含了某种形式的数据。
至于这种数据是文本还是二进制数据，对于 UNIX 内核而言并无区别。
`对普通文件内容的解释由处理该文件的应用程序进行`。

一个值得注意的例外是`二进制可执行文件`。
为了执行程序，内核必须理解其格式。
所有二进制可执行文件都遵循一种标准化的格式，这种格式使内核能够确定程序文本和数据的加载位置。

2. `目录文件(directory fle)`
这种文件含了`其他文件的名字`以及`指向与这些文件有关信息的指针`。
对一个目录文件具有`读权限`的任一进程都可以读该目录的内容，但`只有内核`可以直接`写目录文件`。
进程必须使用本章介绍的函数才能更改目录

3. `块特殊文件 (block special file)`
这种类型的文件提供对`设备(如磁盘)带缓冲的访问`，每次访问以`固定长度`为单位进行
注意，FreeBSD不再支持块特殊文件。对设备的所有访问需要通过字符特殊文件进行。

4. `字符特殊文件 (character special file)`
这种类型的文件提供`对设备不带缓冲的访问`，`每次访问长度可变`。
系统中的`所有设备`要么是`字符特殊文件`，要么是`块特殊文件`。

5. `FIFO`
这种类型的文件用于`进程间通信`，有时也称为`命名管道(namedpipe)`
15.5节将对其进行说明。

6. `套接字 (socket)`
这种类型的文件用于`进程间的网络通信`。
套接字也可用于在一台宿主机上进程之间的非网络通信。
第 16 章将用套接字进行进程间的通信。

7. `符号链接(symbolic link)`
这种类型的文件指向另一个文件。
4.17 节将更多地描述符号链接。

文件类型信息包含在`stat结构`的`st_mode成员`中。
可以用图4-1中的宏确定文件类型。
这些宏的参数都是 stat 结构中的 st mode 成员。



## 4.4 设置用户ID和设置组ID
与一个`进程`相关联的ID有6个或更多

### 指示`我们实际上是谁`
`实际用户ID`
`实际组ID`

用于`文件访问权限`检查
`有效用户ID`
`有效组ID`
`附属组ID`

由`exec函数`保存
`保存的设置用户ID`
`保存的设置组ID`

`实际用户 ID`和`实际组 ID`标识我们究竟是谁。
这两个字段在登录时取自口令文件中的`登录项`。
通常，在一个登录会话期间这些值并不改变，但是超级用户进程有方法改变它们，8.11节将说明这些方法。
`有效用户ID、有效组ID以及附属组ID`决定了我们的`文件访问权限`，下一节将对此进行说明 (我们已在1.8 节中说明了附属组ID)
`保存的设置用户ID`和`保存的设置组ID`在执行一个程序时包含了`有效用户ID`和`有效组ID`的`副本`，在811 节中说明`setuid`函数时，将说明这两个保存值的作用。

通常，`有效用户ID`等于`实际用户ID`，`有效组ID`等于`实际组ID`。
每个文件有一个`所有者`和`组所有者`，所有者由 stat 结构中的`st_id`指定，组所有者则由`st_gid`指定。
当执行一个程序文件时，进程的有效用户ID通常就是实际用户ID，有效组ID通常是实际组ID。
- 但是**可以在`文件模式字 (st_mode)`中设置一个特殊标志，其含义是`“当执行此文件时，将进程的有效用户ID 设置为文件所有者的用户 ID (suid)”(那么就可以访问该可执行文件的所有者才能访问的资源了，而这些资源时机用户可能无法访问)`**。
- **与此相类似，`在文模式字中可以设置另一位，它将执行此文件的进程的有效组为文件的所有者(st_gid)`**。
在文件模式字中的这两位被称为`设置用户ID (set-user-ID)位`和`设置组ID (set-group-ID)位`
例如，若文件所有者是超级用户，而且设置了该文件的设置用户 ID 位，那么当该程序文件由一个进程执行时，该进程具有超级用户权限。
不管执行此文件的进程的实际用户ID是什么，都会是这样。
例如，UNIX 系统程序`passwd(1)`允许任一用户改变其口令，该程序是一个`设置用户ID程序`(即 设置用户ID位被置位了，运行时该进程的有效用户ID为root)。
因为该程序应能将用户的新口令写入口令文件中(一般是`/etc/passwd或/etc/shadow`)，而只有超级用户才具有对该文件的写权限，所以需要使用设置用户ID功能。
因为运行设置用户 ID 程序的进程通常会得到额外的权限，所以编写这种程序时要特别谨慎。
第 8 章将更详细地讨论这种类型的程序。
再回到`stat`函数，设置用户位及设置组ID位都含在文件的st_mode值中。
这两位可分别用常量`S_ISUID`和`S_ISGID`测试。




## 4.5 文件访问权限
`st_mode`值也包含了对文件的`访问权限位`。
当提及文件时，指的是前面所提到的任何类型的文件。
所有文件类型(目录字符特别文件等)都有访问权限(access permission)。
很多人认为只有普通文件有访问权限，这是一种误解。
每个文件有9个访问权限位，可将它们分成3类，见图4-6。
|  st_mode屏蔽   | 含义 |
|  ----  | ----  |
| S_IRUSR  | 用户读 |
| S_IWUSR  | 用户写 |
| S_IXUSR  | 用户执行 |
|  ----  | ----  |
| S_IRGRP  | 组读 |
| S_IWGRP  | 组写 | 
| S_IxGRP  | 组执行 |
|  ----  | ----  |
| S_IROTH  | 其他读 |
| S_IWOTH  | 其他写 |
| S_IXOTH  | 其他执行 |


该命令允许我们用`u`表示用户(所有者)，用`g`表示组，用`o`表示其他。
上图中的3类访问权限(即`读、写及执行`)以各种方式由不同的函数使用。
我们将这些不同的使用方式汇总在下面。
当说明相关函数时，再进一步讨论。
* 第一个规则是，我们用名字打开任一类型的文件时，对该名字中包含的每一个目录，包括它可能隐含的当前工作目录都应具有执行权限。
这就是为什么对于目录，`其执行权限位`常被称为`搜索位`的原因。
例如，为了打开文件`/usr/include/stdio.h`，需要对目录`/、/usr 和/usr/inciude`具有`执行权限`。
然后，需要具有对`文件本身`的适当权限，这取决于以何种模式打开它(`只读、读-写等`)。
如果当前目录是`/usr/include`，那么为了打开文件stdio.h，需要对当前目录有执行权限。
这是隐含当前目录的一个示例。
打开`stdio.h`文件与打开`./stdio.h`作用相同。

注意，对于`目录`的`读权限`和`执行权限`的意义是不相同的。
`读权限`允许我们`读目录`，获得在该目录中`所有文件名`的列表。
当一个目录是我们要访问文件的路径名的一个组成部分时，
对该`目录`的`执行权限`使我们可`通过该目录`(也就是`搜索该目录，寻找一个特定的文件名`)。
引用`隐含目录`的另一个例子是，如果`PATH环境变量`(8.10节将对其进说明)指定了一个我们不具有执行权限的目录，那么shell绝不会在该目录下找到可执行文件，因为该目录文件没有执行权限，查找的时候被跳过了。
* 对于一个`文件`的`读权限`决定了我们是否能够`打开现有文件`进行`读操作`。
    这与`open`函数的`O_RDONLY`和`O_RDWR`标志相关。
* 对于一个文件的`写权限`决定了我们是否能够`打开现有文件`进行`写操作`。
    这与`open`函数的`O_WRONLY`和`O_RDWR`标志相关。
* 为了在`open`函数中对一个文件指定`O_TRUNC`标志，必须对该文件具有`写权限`
* 为了在一个`目录`中`创建一个新文件`，必须对该目录具有`写权限`和`执行权限`。
* 为了`删除`一个现有文件，必须对包含该文件的`目录`具有`写权限`和`执行权限`。
**对该文件本身则不需要有`读、写`权限**。
* 如果用7个`exec`函数(见8.10 节)中的任何一个执行某个文件，都必须对该文件具有`执行权限`。
该文件还必须是一个`普通文件`。

进程每次`打开、创建或删除`一个文件时，内核就进行`文件访问权限测试`，
而这种测试可能涉及`文件的所有者`(`st_uid`和`st_gid`)，`进程的有效ID`(有效用户ID和有效组)以及`进程的附属组ID`(若支持的话)。注意到，这里的内核测试不涉及进程的实际用户ID。
两个所有者ID是文件的性质，而两个`有效ID`和`附属组ID`则是进程的性质。
`内核进行的测试`具体如下：
1. 若进程的`有效用户ID`是0(`超级用户`)，则允许访问。
    这给予了`超级用户`对整个文件系统进行处理的最充分的自由。
2. 若进程的`有效用户ID`等于`文件的所有者ID`(也就是进程拥有此文件)
    适当的访问权限位被设置，则允许访问，
    否则拒绝访问。
    `适当的访问权限位`指的是：
    - 若进程为`读`而打开该文件，则`用户读位`应为1
    - 若进程为`写`而打开该文件，则`用户写位`应为1
    - 若进程将`执行`该文件，则`用户执行位`应为1。
3. 若`进程`的`有效组ID`或`进程的附属组ID`之一等于`文件的组ID`，
    那么如果`组适当的访问权限位`被设置，则允许访问
    否则拒绝访问。
4. `其他用户`适当的访问权限位被设置，则允许访问;
否则拒绝访问。
按顺序执行这 4 步。
注意，
如果`进程拥有此文件`(第2步)，则按`用户访问权限` 批准或拒绝 该进程对文件的访问一一`不查看组访问权限`。
类似地，若进程并不拥有该文件。但进程属于某个适当的组，则按`组访问权限` 批准或拒绝 该进程对文件的访问――――`不查看其他用户的访问权限`。



---
PS:
Linux的文件和目录的权限，只有RWX三种。
**`r`(Read，读取)：**
- 对文件而言，具有读取文件内容的权限；
- 对目录来说，具有浏览目录的权限。
**`w`(Write,写入)：**
- 对文件而言，具有新增,修改,删除文件内容的权限；
- 对目录来说，具有新建，删除，修改，移动目录内文件的权限。
**`x`(eXecute，执行)：**
- 对文件而言，具有执行文件的权限；
- 对`目录`了来说该用户具有`进入目录`的权限。

1. `目录`的`只读访问`不允许使用`cd进入目录`，必须要有`执行`的权限才能进入。
2. **只有执行权限只能进入目录，不能看到目录下的内容**，要想看到目录下的文件名和目录名，需要可读权限。
3. 一个`文件`能不能被`删除`，主要看该文件所在的`目录`对`用户`是否具有`写权限`，如果目录对用户没有写权限，则该目录下的所有文件都不能被删除，文件所有者除外
4. `目录`的`w`位不设置，即使你拥有目录中某文件的`w权限`也不能写该文件
    新建`文件``默认权限777`，新建`目录``默认权限666`。
    在unix或者linux中，每创建一个文件或者目录时，这个文件或者目录都具有一个默认的权限，比如目录755，文件644，这些默认权限是通过“umask”权限掩码控制的。
    一般默认的umask值为022，其最终效果就是新创建的目录权限为755，文件权限为644。
    所以只要修改了用户的umask值，就可以控制默认权限。
---



## 4.6 新文件和目录的所有权
在第3章中讲用`open`，`creat`创建新文件时，
我们并没有说明赋予新文件的用户ID和组ID是什么。
4.21 节将说明`mkdir`，此时就会了解如何建一个新目录。
关于新目录的所有权规则与本节将说明的新文件所有权规则相同。
`新文件`的`用户ID`设置为`进程的有效用户ID`。
关于`组 ID`，POSIX.1允许实现选择下列之一作为新文件的组ID。
1. 新文件的组ID可以是进程的有效组ID
2. 新文件的组ID可是它所在目录的组ID
使用 POSIX1所许的第二个选项(承目录的组ID)使得在某个目录下创建的文件和目录
都具有该目录的组ID。
于是文件和目录的组所有权从该点向下传递。
例如在 Linux 的`/var/mail`目录中就使用了这种方法。



## 4.7 函数`access`和`faccessat`
正如前面所说，当用`open 函数`打开一个文件时，
内核以`进程`的`有效用户ID`和`有效组ID`为基础执行其访问权限测试。
有时，进程也希望按其`实际用户 ID`和`实际组ID`来测试其访问能力。
例如，当一个进程使用`设置用户 ID`或`设置组ID`能作为另一个用户(或组)运行时，就可能会有这种需要。

即使一个进程可能已经通过`设置用户ID`以超级用户权限运行，它仍可能想验证其实际用户能否访问一个给定的文件。
`access`和`faccessat`函数是按`实际用户ID`和`实际组ID`进行访问权限测试的。
(该测试也分成 4 步，这与 4. 节中所述的一样，但将有效改为实际。)

```cpp
#include <unistd.h>
int access(const char *pathname，int mode);
int faccessat(int fd, const char *pathname, int mode, int flag);
// 两个函数的返回值:成功，返回 0;出错，返回-1
```

`faccessat`函数与`access`函数在下面两种情况下是相同的:
* 一种是`pathname`参数为绝对路径，
* 另一种是fd参数取值为`AT_FDCWD`，而pathname参数为相对路径。
否则，`faccessat`计算相对于`打开目录`(由fd参数指向)的pathname
`flag`参数可以用于改变 faccessat 的行为:
如果`flag`设置为`AT_EACCESS`，访问检查用的是调用进程的有效用户ID和有效组 D，而不是实际用户ID 和实际组ID

如果一个程序里把命令行参数传进来的文件，分别进行`access`和`faccessat`判断
而这个可执行文件被如此设置：
```sh
-rwsrwxr-x 1 root ...
# 也就是说，进程运行时，有效用户ID为root，而实际用户ID仍然是普通用户
```
`access`会失败，`open`会成功




## 4.12 文件长度
`stat`结构成员`st_size`表示以`字节`为单位的文件的长度。
此字段只对`普通文件`、`目录文件`和`符号链接`有意义。
FreeBSD8.0、Mac OS X 10.6.8、和 Solaris 10对管道也定义了文件长度，它表示可从该管道中读到的宇节数，我们将在 15.2 中讨论管道。
* 对于`普通文件`，
    其文件长度可以是0，在开始读这种文件时，将得到文件结束(end-of-file)指示
* 对于`目录`，
    文件长度通常是一个数(如16或512)的整倍数，我们将在4.22节中说明读目录操作
* 对于`符号链接`，
    文件长度是在文件名中的`实际字节数`。
    例如，在下面的例子中，文件长度7就是路径名usr/lib的长度:
```sh
    7 Sep 25 07:14 1ib -> usr/lib
    lrwxrwxrwx 1 root
```
注意，因为`符号链接文件`长度总是由`st_size`指示，
所以它并不包含通常C语言用作名字结尾的`null字节`。
现今，大多数现代的UNIX系统提供字段`st_blksize`和`st_blocks`。
``st_blksize``是对`文件 I/O`较合适的块长度，
`st_blocks`是所分配的`实际512字节块`块数。
回忆 3.9 节，其中提到了当我们将`st_blksize`用于读操作时，读一个文件所需的时间量最少。
为了提高效率，标准I/O库(我们将在第5章中说明)也试图一次读、写`st_blksize`个字节。
***应当了解的是，不同的 UNIX 版本其 st_blocks 所用的单位可能不是 512 字节的块。使用此值并不是可移植的。***

### 文件中的空洞
在 3.6 节中，我们提及：普通文件可以包含空洞。
在图 3-2 程序中示了这一点。
空洞是由`所设置的偏移量`超过`文件尾端`，并`写入了某些数据`后造成的。
(也就是说，文件在逻辑上很大，但是实际占据的磁盘空间不大，实现方式比如：在文件中将指针移动到一个偏移量，然后写入数据，前面的部分会被文件系统填充为0，而不分配实际的磁盘空间，这种技术可以用于创建稀疏文件)

作为一个例子，考虑下列情况:
```sh
$ 1s -l core
-rw-r--r-- 1 sar 8483248 Nov 18 12:18 core
$ du -s core
272 core
```
文件 core 的长度稍稍超过`8MB`，可是 du 命令报告该文件`所使用的磁盘空间总量`是272个`512字节块`(即139264 字节 = `0.13MB`)。
很明显，此文件中有很多空洞。
在很多BSD类系统上，du 命今报告的是1024字节块的块数，Slaris 报告的是512 字节块的块数。
在 Linux 上，报告的块数单位取决于是否设置了环境变量`POSIXLY_CORRECT`。
当设置了该环境变量，du 命令报告的是 1024 字节块的块数
没有设置该环境变量时，du 命令报告的是512 字节块的块数。

正如我们在3.6 节中提及的，对没有写过的字节位置，read 函数读到的字节是0。
如果执行下面的命令，可以看出正常的IO操作读整个文件长度:
```sh
$ wc -c coze    # 计算文件中的字符数
8483248 core
```
如果使用实用程序(如`cat(1)`)复制这个文件，那么所有这些空洞都会被填满，其中所有实际数据字节皆填写为 0。
```sh
$ cat core > core.copy
$ ls -l core*
-rw-rw-r-- 1 sar 8483248 Nov 18 12:18 core
-rw-rw-r-- 1 sar 8483248 Nov 18 12:18 core.copy
$ du -s cora*
272 core
16592 core.copy

```
从中可见，新文件所用的实际字节数是`8 495 104`( `512 x 16592` )
此长度与`ls`报告的长度不同(略微大一些)，
其原因是，`文件系统`使用了`若干块`以存放指向`实际数据块`的`各个指针`。




## 4.14 文件系统
为了说明`文件链接`的概念，先要介绍 UNIX 文件系统的基本结构。
同时，了解`i节点`和`指向i节点的目录项`之间的区别也是很有益的
目前，正在使用的`UNIX文件系统`有多种实现。
- 例如，`Solaris`支持多种`不同类型的磁盘文件系统`
- 传统的`基于BSD`(BSD也是一种类UNIX操作系统，全称Berkeley Software Distribution，提起BSD通常指的是UNIX操作系统中的一个分支的总称)的UNIX文件系统(称为`UFS`)，
`读、写DOS格式软盘`的文件系统(称为`PCES`)，
以及`读CD`的文件系统(称为`HSFS`)。

在图2-20中，我们已经看到了不同类型文件系统的一个区别。
`UFS`是以`Berkeley快速文件系统`为基础的。
本节讨论该文件系统。

每一种文件系统类型都有它各自的特征，有些特征可能是混淆不清的。
例如，大部分UNIX文件系统支持大小写敏感的文件名。
因此，如果创建了一个名为 file.txt 的文件以及另外一个名为 file.TXT 的文件，就是创建了两个不同的文件。
在 Mac OSX上，HES 文件系统是大小写保留的，并且是大小写不敏感比较的。
因此，如果创建了一个名为 file.txt 的文件，当你再创建名为 file.TXT 的文件时，就会覆盖原来的 file.txt 文件。
但是，保存在文件系统中的是文件创建时的文件名(即 file.txt，因为是大小写保留的)。
事实上，在“f，i，l, e, ., t, x, t”这个序列中的大写或小写字母的排列都会在搜索这个文件时得到匹配(大小写不敏感比较)。
因此，除了file.txt和file,TXT，我们还可以用File.txt、fILE.tXt以及 EiLe.TxT 等名字来访问该文件。
我们可以把`一个磁盘`分成`一个或多个分区`。
`每个分区`可以包含一个`文件系统`
`i节点`是`固定长度`的`记录项`，它包含`有关文件的大部分信息`。

------
PS: 关于`文件系统`
文件储存在硬盘上，硬盘的最小存储单位叫做`"扇区"（Sector）`。
每个扇区储存512字节（相当于0.5KB）。
操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是`一次性连续读取多个扇区`，即一次性读取一个`"块"`（block）。
这种由多个扇区组成的"块"，是`文件存取的最小单位`。
"块"的大小，最常见的是`4KB`，即连续八个sector组成一个`block`。
文件数据都储存在"块"中，
那么很显然，我们还必须找到一个地方储存`文件的元信息`：比如文件的`创建者`、文件的`创建日期`、文件的`大小`等等。
这种储存文件元信息的区域就叫做`inode`，中文译名为`"索引节点"`。

inode的内容
* 文件的`字节数`
* 文件拥有者的`User ID`
* 文件的`Group ID`
* 文件的`读、写、执行权限`
* 文件的`时间戳`，共有三个：
    `ctime`指`inode上一次变动`的时间，
    `mtime`指`文件内容上一次变动`的时间，
    `atime`指`文件上一次打开`的时间。
* `链接数`，
    即有多少文件名指向这个inode
* `文件数据block`的`位置`
```sh
# stat server.cpp
  File: server.cpp
  Size: 1711            Blocks: 8          IO Block: 4096   regular file
Device: 805h/2053d      Inode: 8434379     Links: 1
Access: (0664/-rw-rw-r--)  Uid: ( 1000/ linearx)   Gid: ( 1000/ linearx)
Access: 2024-06-14 11:33:12.767349263 +0800
Modify: 2024-05-07 16:36:39.947582529 +0800
Change: 2024-05-09 13:59:58.658852261 +0800
 Birth: -
```
总之，除了文件名以外的所有文件信息，都存在inode之中。至于为什么没有文件名，下文会有详细解释。

inode也会消耗硬盘空间，
所以`硬盘格式化`的时候，`操作系统`自动将硬盘分成两个区域：
* 一个是`数据区`，存放`文件数据`；
* 另一个是`inode区`（inode table），存放inode所包含的信息。

`每个inode节点`的大小，一般是`128字节`或`256字节`。
`inode节点的总数`，在格式化时就给定，是这样估算的：一般是每1KB或每2KB就设置一个`inode`。
假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。
由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件。

每个inode都有一个号码，`操作系统用inode号码来识别不同的文件`。
这里值得重复一遍，Unix/Linux系统内部不使用文件名，而使用`inode号码`来识别文件。
对于系统来说，文件名只是inode号码便于识别的别称或者绰号。
表面上，用户通过文件名，`打开文件`。
实际上，系统内部这个过程分成三步：
* 首先，系统找到这个`文件名对应的inode号码`；
* 其次，通过inode号码，获取`inode信息`；
* 最后，根据inode信息，找到`文件数据所在的block`，读出数据。
使用`ls -i`命令，可以看到文件名对应的inode号码

`目录文件`
Unix/Linux系统中，目录（directory）也是一种文件。
打开目录，实际上就是打开目录文件。
目录文件的结构非常简单，就是一系列`目录项（dirent）`的`列表`。
每个`目录项`，由两部分组成：
* 所包含文件的`文件名`，
* 以及该文件名对应的`inode号码`。
ls命令只列出目录文件中的所有文件名：

`目录文件`的`读权限（r）`和`写权限（w）`，都是针对`目录文件本身`。
由于目录文件内只有`文件名`和`inode号码`，所以如果只有`读权限`，只能获取`文件名`，无法获取其他信息，
因为其他信息都储存在inode节点中，而`读取inode节点内的信息`需要目录文件的`执行权限（x）`。

`硬链接`
一般情况下，文件名和inode号码是"一一对应"关系，每个inode号码对应一个文件名。
但是，Unix/Linux系统允许，`多个文件名指向同一个inode号码`。
这意味着，可以用不同的文件名访问同样的内容；
对文件内容进行修改，会影响到所有文件名；
但是，删除一个文件名，不影响另一个文件名的访问。
这种情况就被称为`"硬链接"`（hard link）。
ln命令可以创建硬链接：
```sh
　　ln 源文件 目标文件
```
运行上面这条命令以后，源文件与目标文件的inode号码相同，都指向同一个inode。
inode信息中有一项叫做`"链接数"`，记录指向`该inode的文件名总数`，这时就会增加1。
反过来，删除一个文件名，就会使得inode节点中的"链接数"减1。
当这个值`减到0`，表明没有文件名指向这个inode，系统就会回收这个`inode号码`，以及其所对应block区域。

这里顺便说一下`目录文件的"链接数"`。
创建目录时，默认会生成两个`目录项`：`"."和".."`。
* `.`
    前者的inode号码就是`当前目录`的inode号码，等同于当前目录的"硬链接"；
* `..`
    后者的inode号码就是`当前目录的父目录`的inode号码，等同于父目录的"硬链接"。
    所以，`任何一个目录的"硬链接"总数，总是等于2加上它的子目录总数（含隐藏目录）`。

注意：`硬链接相比软连接，没有产生新的inode`


`软连接`
除了硬链接以外，还有一种特殊情况。
`文件A`和`文件B`的`inode号码`虽然不一样，但是`文件A的内容是文件B的路径`。
读取文件A时，系统会自动将访问者导向文件B。
因此，无论打开哪一个文件，最终读取的都是文件B。
这时，文件A就称为文件B的"软链接"（soft link）或者"符号链接（symbolic link）。
这意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错："No such file or directory"。
这是软链接与硬链接最大的不同：`文件A指向文件B的文件名`，而不是文件B的inode号码，`文件B的inode"链接数"不会因此发生变化`。
`ln -s`命令可以创建软链接。
```sh
　　ln -s 源文文件或目录 目标文件或目录
```

`inode的特殊作用`
由于inode号码与文件名分离，这种机制导致了一些Unix/Linux系统特有的现象。
1. 有时，文件名包含特殊字符，无法正常删除。
    这时，直接删除inode节点，就能起到删除文件的作用。
2. 移动文件或重命名文件，只是改变文件名，不影响inode号码。
3. 打开一个文件以后，系统就以inode号码来识别这个文件，不再考虑文件名。
    因此，通常来说，系统无法从inode号码得知文件名（文件名由目录项持有）。

第3点使得软件更新变得简单，可以在不关闭软件的情况下进行更新，不需要重启。
因为系统通过inode号码，识别运行中的文件，不通过文件名。
更新的时候，新版文件以同样的文件名，生成一个新的inode，不会影响到运行中的文件。
等到下一次运行这个软件的时候，文件名就自动指向新版文件，旧版文件的inode则被回收。

------




## 4.19 文件的时间
| 字段 | 说明 | 例子 | ls(1) |
|  ----  | ----  | ---- | ---- |
| `st_atim` | 文件数据的`最后访问`时间 | `read` | -u |
| `st_mtim` | 文件数据的`最后修改`时间 | `write` | 默认 |
| `st_ctim` | i节点状态的`最后更改`时间 | `chmod、chown` | -c |

注意，`修改时间`(st_mtim)和`状态更改时间`(st_ctim)之间的区别。
`修改时间`是文件内容最后一次被修改的时间。
`状态更改时间`是该文件的`inode`最后一次被修改的时间。
在本章中我们已说明了很多影响到i节点的操作，如`更改文件的访问权限、更改用户ID、更改链接数等`，
但它们并没有更改文件的实际内容。
因为i节点中的所有信息都是与文件的实际内容分开存放的，所以，除了要记录文件数据修改时间以外，还需要记录状态更改时间，也就是更改i节点中信息的时间。
注意，系统并不维护对一个i节点的最后一次访问时间，所以access和stat函数并不更改这3个时间中的任一个。
系统管理员常常使用访问时间来删除在一定时间范围内没有被访问过的文件。
典型的例子是删除在过去一周内没有被访问过的名为a.out或core的文件。
find(1)命令常被用来进行这种类型的操作修改时间和状态更改时间可被用来归档那些内容已经被修改或i节点已经被更改的文件






















# 第七章 进程环境

## 7.2 main函数
```c
int main(int argc,char *argv[]);
// argc是命令行参数的数目
// atgv是指向各个参数的各个指针构成的数组
```
内核执行C程序时，调用**exec函数**，在调用main前先调用一个特殊的启动例程（是一个特殊的函数，处理一些准备工作），可执行文件将此启动例程指定为程序的起始地址（是由链接器设置的）
启动例程从内核取得命令行参数和环境变量值
（PS：
### 启动例程的操作：
#### 设置堆栈：
启动例程会设置程序的堆栈指针，确保程序能够正确地使用堆栈空间。
#### 初始化运行时库：
启动例程会初始化程序所需的运行时库，例如C语言的标准库。这可能包括初始化全局变量、静态变量和其他运行时数据结构。
#### 获取命令行参数和环境变量：
启动例程会从操作系统获取命令行参数和环境变量的值，并将它们传递给main函数。这样，程序就可以根据需要使用这些参数和变量。
#### 调用main函数：
最后，启动例程会调用程序的main函数，开始程序的正式执行。
）

## 7.3 进程终止
### 正常终止
1. main返回
2. 调用`exit`
3. 调用`_exit`或`_Exit`
4. 最后一个线程从其启动例程返回
5. 从最后一个线程调用`pthread_exit`

### 异常终止有3种
6. 调用abort
7. 接到一个信号
8. 最后一个线程对取消请求做出响应

退出函数（用于正常终止一个程序：`_exit`和`_Exit`立即进入内核，`exit`先执行一些`清理处理`，然后返回内核）
```cpp
#include<stdlib.h> // ISO C
void exit(int status); // 会执行一个标准I/O库的清理关闭处理，对所有打开流调用fclose函数（导致输出缓冲中的所有数据都冲洗到文件上），再返回内核
void _Exit(int status);

#include<unistd.h> // POSIX.1
void _exit(int status);
```
三个函数都带一个入参：**终止状态**
只有main返回一个整型并且main执行到最后一条语句时返回（隐式返回），那么这个进程的终止状态是0，要不然进程的终止状态就是未定义的

## 7.4 命令行参数
执行程序时可以将命令行参数传递给程序，这是UNIX shell的常规操作

## 7.5 环境表
```cpp
extern char **environ;
// 该全局变量包含了环境表这一字符指针数组的地址
```

```shell
# 环境字符串
HOME=/home/sar\0
```
大多数UNIX系统支持main函数带三个参数，第三个参数就是环境表地址
而IOS C规定main函数只有两个参数（毕竟第三个参数相比全局environ没好到哪里去，POSIX1也规定使用全局的而不是用第三个入参，通常使用getenv和putenv函数来访问特定的环境变量）


## 7.6 C程序的存储空间布局
C程序的**逻辑布局**一直由以下几部分组成：
（**从低地址到高地址**）
### 正文段
CPU执行的机器指令部分。正文段是可共享的（在存储中只需有一个副本）、只读的

### 初始化数据段
通常称**数据段**，包含了程序中需明确地赋初值的变量，比如C程序中任何函数之外的定义：
```c
int maxcount = 99;
```
此变量按照初值的设定放在初始化数据段中

### 未初始化数据段
通常称**bss段（block started by symbol）**。
在程序开始执行前，内核将此段中的数据初始化为0或空指针
```c
long sum[1000];
```
函数外部未定义的声明

### 堆
通常在堆中进行动态存储分配
由于历史惯例，堆位于未初始化数据段和栈之间

### 栈
自动变量以及每次函数调用时所需保存的信息都存放在栈中。
每次函数调用时，其返回地址以及调用者的环境信息（如某些机器寄存器的值）都存放在栈中。然后，最近被调用的函数在栈上为其自动和临时变量分配存储空间，
（以这种方式使用栈，C递归函数就可以工作。递归函数每次调用自身时，用一个新的栈帧）

（PS：可执行文件中，还有若干其他类型的段，比如：包含符号表的段、包含调试信息的段、包含动态共享库链接表的段，这些部分并不装载到进程执行的程序映像中
而且显然，未初始化数据段的内容不会包含在磁盘程序文件中，毕竟内核在程序开始运行前，未初始化数据段的内容都是设置为0。
真正需要存放在磁盘程序文件中的段只有正文段和初始化数据段。
）

## 7.7 共享库
动态链接的方法使得程序与共享库函数相链接，减少了每个可执行文件的长度，不过增加了运行时间开销（在该程序第一次被执行时，或者每个共享库函数第一次被调用时），还有一个好处就是使用库函数的新版本代替老版本不需要对使用该库的程序重新编译。

## 7.8 存储空间分配
```cpp
// ISO的三个用于存储空间动态分配的函数
#include<stdlib.h>
1. malloc
分配指定字节数的存储区（其中的初始值不确定）
void *malloc(size_t size);

2. calloc
为指定数量、指定长度的对象分配存储空间（！！！空间中的每一位都初始化为0）
void *calloc(size_t nobj, size_t size);

3. realloc
增加或减少以前分配区的长度（初始值不确定）
void *realloc(void* ptr, size_t newsize);
常用于增加以前分配的存储区的长度
比如原先有个数组长度为512，在运行时填充，发现原存储区不够用，就可以调用该函数扩充响应存储空间而不需移动原先的内容
当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，以便在尾端提供增加的存储区，而新增区域内的初始值则不确定。

```
这三个函数返回的指针必然是适当对齐的，使其可用于任何数据对象。
比如，如果系统要求`最严苛的对齐要求`是：double必须在8的倍数地址单元处开始，那么这三个函数返回的指针都是这样对齐的。

realloc 函数使我们可以增、减以前分配的存区的长度(常见的用法是增加该区)。
例如，如果先为一个数组分配存储空间，该数组长度为 512，然后在运行时填充它，但运行一段时间后发现该数组原先的长度不够用，此时就可调用 realloc 扩充应存储空间。
* 如果在该存储区后有足够的空间可供扩充，则可在原存储区位置上向高地址方向扩充，无需移动任何原先的内容，并返回与传给它相同的指针值。
* 如果在原存储区后没有足够的空间，则 realloc 分配另个足够大的存储区，将现存的 512 个元素数组的内容复制到新分配的存储区。
然后，释放原存储区，返回新分配区的指针。
因为这种存储区可能会移动位置，所以不应当使任何指针指在该区中

这些分配例程通常用`sbrk(2)`系统调用实现。
该系统调用扩充(或缩小)进程的堆(见图7-6)
malloc和free的一个样例实现请见 Kernighan 和 Ritchie[1988]的8.7节
虽然 sbrk 可以扩充或缩小进程的存储空间，但是大多数 malloc 和 free 的实现都不减小进程的存储空间。
**释放的空间可供以后再分配，但将它们保持在malloc池中而不返回给内核。**
大多数实现所分配的存储空间比所要求的要稍大一些，`额外的空间用来记录管理信息一一分配块的长度、指向下一个分配块的指针等`。
**这就意味着，如果超过一个已分配区的尾端或者在已分配区起始位置之前进行写操作，则会改写另一块的管理记录信息。**
这种类型的错误是灾难性的，但是因为这种错误不会很快就暴露出来，所以也就很难发现。
在动态分配的缓冲区前或后进行写操作，破坏的可能不仅仅是该区的管理记录信息。
在动态分配的缓冲区前后的存储空间很可能用于其他动态分配的对象。
这些对象与破坏它们的代码可能无关，这造成寻求信息破坏的源头更加困难。
其他可能产生的致命性的错误是:释放一个已经释放了的块，调用 free 时所用的指针不是3个al1oc函数的返回值等。
如若一个进程调用malloc 函数，但却忘记调用 free 函数，那么该进程占用的存储空间就会连续增加，这被称为`泄漏(leakage)`
如果不调用 free 函数释放不再使用的空间，那么进程地址空间长度就会慢慢增加，直至不再有空闲空间。此时，由于过度的换页开销，会造成性能下降。








## 7.9 环境变量
POSIX.1定义了一些经典的环境变量，XSI扩展又定义了另一些



# 第八章 进程控制
***关于UNIX系统的进程控制，包括创建新进程、执行程序和进程控制终止***

## 8.2 进程标识
每个进程都有**唯一**标识：**进程ID**。进程ID是可复用的，大多数UNIX系统实用延迟复用算法，避免新进程被误认为是同一ID的某个已终止的进程。
系统中有一些专用进程：
**ID为0的进程**
通常是调度进程，又称为交换进程（swapper），该进程是内核的一部分，并不执行任何磁盘上的程序，也被称为系统进程。
**ID为1的进程**
通常是init进程，在自举过程中由内核调用。该进程的程序文件在早期UNIX版本中是`etc/init`，在较新版本中是`/sbin/init`。它负责**在自举内核后启动一个UNIX系统**。
init通常读取与系统有关的初始化文件（/etc/rc*文件或/etc/inittab文件，以及在/etc/init.d中的文件），并将系统引导到一个状态（比如多用户）
**init进程绝不会终止**，它是一个普通的用户进程（不是像交换进程那样的内核中的系统进程），但是可以以超级用户特权运行，它是所有孤儿进程的父进程。
每个UNIX系统实现都有一套提供操作系统服务的内核进程，某些UNIX的虚拟存储器实现中，进程ID 2是page守护进程，此进程负责支持虚拟存储器系统的分页操作。

## 8.3 函数`fork`
```cpp
#include<unistd.h>
pid_t fork(void);   // 子进程返回0，父进程返回子进程ID，若出错则返回-1
```
**`fork`函数被调用一次，却返回两次**
之所以将子进程ID返回给父进程，是因为一个进程的子进程可以有多个，并且没有一个函数使一个进程可以获得其所有子进程的进程ID。
之所以fork使子进程得到返回值0，是因为一个进程只会有一个父进程，所以子进程总是可以用`getppid`来获得父进程的进程ID（而不可能是0，已经被内核交换进程使用了）

**子进程和父进程继续执行fork调用之后的指令**。子进程可获得父进程数据空间、堆和栈的**副本**，而父子进程真正共享的是**正文段**。
由于在fork之后经常伴随着`exec`（因此复制整个空间是不必要的，新程序会替换原来的程序，完全的复制是没必要的），所以现在的很多实现并不执行一个父进程数据段、栈和堆的完全副本，而是使用**写时复制（Copy On Write）**技术。这些区域由父进程和子进程共享，而且内核将它们的访问权限改变为只读，**如果父进程或者子进程试图修改这些区域，则内核只为修改区域的那块内存制作一个副本，通常是虚拟存储系统中的一个页**（也就是有必要的情况下才执行拷贝）

一般来说，在调用`fork`后，是父进程先执行还是子进程先执行是不确定的，这取决于内核使用的调度算法（可以通过进程间通信来实现父子进程的相互同步）。

**文件共享**
在重定向父进程的标准输出时，子进程的标准输出也被重定向，因为fork的一个特性是父进程的所有打开文件描述符都被复制到子进程中，即：父子进程的每个相同的打开描述符共享一个文件表项。
**父子进程共享一个文件偏移量**

### 使`fork`失败的原因
1. 系统中进程过多
2. 该实际用户ID的进程总数超过了系统限制（`CHILD_MAX`规定了每个实际用户ID在任一时刻可拥有的最大进程数）

### `fork`有两种用法
1. 一个父进程希望复制自己，使得父子进程同时执行不同的代码段
常用于网络服务进程：父进程等待客户端的服务请求，当请求到达，父进程调用fork，使子进程处理此请求，而父进程继续等待下一个服务请求

2. 一个进程要执行一个不同的程序
shell就是如此，子进程从`fork`返回后立刻调用`exec`（某些操作系统将这种`fork`之后立马执行`exec`组合成一个操作：`spawn`，而UNIX系统将二者分开，因为很多时候要单独使用fork，并且还能使得子进程在`fork`和`exec`之间可以更改自己的属性：比如I/O重定向、用户ID、信号安排等）



## 8.4 函数vfork
`vfork`会创建一个新进程，该新进程的目的是`exec`一个新程序（shell的基本部分就是利用它）
### 相比`fork`，`vfork`的区别

#### 创建的子进程不会将父进程的地址空间完全复制到子进程中
因为子进程会立即调用`exec`（或`exit`），也就不会引用到该地址空间。在子进程调用`exec`或`exit`之前，**它在父进程的空间中运行**（这种优化使得在某些UNIX系统中提高了效率）。
但如果子进程修改数据（除了用于存放`vfork`返回值的变量）、进行函数调用、或者没有调用`exec`或`exit`就返回，则会导致未知结果。
写时复制技术可以提高`fork`之后跟随`exec`操作的效率，而直接不复制数据，在父进程的空间运行自然是更快。

#### vfork保证子进程先运行
在调用`exec`或`exit`之后父进程才可能被调度运行（内核使得父进程处于休眠状态），当子进程调用这两个函数中的任意一个时，父进程会恢复运行。
如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。

PS：`_exit`相比`exit`不执行标准I/O缓冲区的`flush`。大多数`exit`的现代实现都不去管流的关闭了，因为进程即将终止时，自有内核去关闭在进程中已经打开的文件描述符，没必要在库中去写关闭流的逻辑了。



## 8.5 函数exit
### 进程5种正常终止
1. `main`函数内执行`return`，等效于调用`exit`

2. 调用`exit`函数（由ISO C定义），包含如下操作：
    调用各种终止处理程序（这些程序在调用atexit函数时登记）、关闭所有标准I/O流
    而ISO C并不处理文件描述符、多进程以及作业控制，所以这一定义对于UNIX系统是不完整的

3. 调用_exit或_Exit函数，ISO C定义_Exit目的是为进程提供一种无需运行终止处理程序或信号处理程序而终止的办法
    在UNIX系统中，_exit和_Exit是同义的（不做清理操作），不冲洗标准I/O流，`_exit`由`exit`调用，处理UNIX系统特定的细节，`_exit`是由POSIX.1说明的。
    大多数UNIX系统中，`exit(3)`是标准C库中的一个函数（包含清理操作），而`_exit(2)`是一个系统调用

4. 进程的最后一个线程在其启动例程中执行return。而该线程的返回值不用作进程的返回值，当最后一个线程从其启动例程返回时，该进程以终止状态0返回。

5. 进程的最后一个线程调用pthread_exit函数。进程终止状态为0.

### 进程3种异常终止
1. 调用abort，产生SIGABRT信号，是2的特例

2. 当进程接收到某些信号时。信号可由**进程自身、其他进程或内核产生**
    比如进程如果引用地址空间之外的存储单元、或者除以0，内核就会为进程产生相应的信号

3. 最后一个线程对“取消”请求作出相应。
    默认情况下，“取消”以延迟方式发生，一个线程要求取消另一个线程，若干时间后，目标线程终止。

**不管进程如何终止，最后都会执行内核中的同一段代码：为相应进程关闭所有打开的描述符，释放所使用的存储器**

对于以上任意的终止情形，需要有机制实现终止进程通知其父进程它是如何终止的。
对于三大终止函数（exit、_exit、_Exit），实现方式是：将`退出状态`作为参数传递给函数
而异常终止情况下，内核产生一个指示其异常终止原因的`终止状态`，而终止进程的父进程都能用`wait`或`waitpid`取得终止子进程的`终止状态`
PS：在进程最后调用`_exit`时，内核将`退出状态`转换成`终止状态`。这里的`退出状态`指的是进程调用`_exit`时传递给内核的`退出状态参数`。
而`终止状态`是内核中用于表示进程终止原因的一种状态。
然后，内核会将进程的状态从"运行"状态转换为"终止"状态。这个终止状态包含了进程的退出状态参数以及其他一些信息，例如进程的终止原因（正常退出、异常终止等）。
**终止状态的保存和传递对于父进程来说是很重要的**。父进程可以通过调用`wait`或`waitpid`系统调用来等待子进程的终止，并获取子进程的终止状态。这样，父进程就可以根据子进程的终止状态来判断子进程的执行结果或处理其他相关的操作。

如果父进程在子进程之前终止，则子进程的父进程改变为init进程（或者说被init进程收养）。操作过程大致是：在一个进程终止时，内核逐个检查所有活动进程，以判断它是否是正要终止进程的子进程，如果是，则该进程的父进程ID更改为1（init进程），保证每个子进程都有一个父进程。

#### 如果子进程在父进程之前终止，父进程如何在检查时得到子进程的终止状态呢？
若子进程完全消失，则进程在准备好检查子进程是否终止时是无法获取终止状态的。
内核为每个终止子进程保存了一些信息（比如：进程ID、终止状态、该进程使用的CPU时间总量），所以当父进程调用`wait()`、或者`waitpid()`时，可以得到这些信息
内核可以释放终止进程所使用的所有存储区、关闭所有打开文件
在UNIX中，一个已经终止，但是其父进程尚未对其进行善后处理（获取终止子进程的有关信息、释放它仍然占用的资源）的进程被称为僵尸进程（zombie~）。ps(1)命令将僵尸进程的状态打印为Z。
如果编写一个长期运行的程序，fork了很多子进程，除非进程等待取得子进程的**终止状态**，这些子进程终止后都会变成僵尸进程。

PS：
**僵尸进程**（Zombie Process）是指一个子进程在终止后，其父进程没有及时调用`wait`或`waitpid`等系统调用来获取子进程的终止状态，**导致子进程的进程描述符仍然存在于系统进程表中，但是已经没有运行的代码。僵尸进程不会占用系统资源，但是会占用进程表中的一个位置**。
**孤儿进程**（Orphan Process）是指一个父进程在子进程终止之前就已经退出或终止，而子进程还在运行。这种情况下，子进程会被称为孤儿进程。孤儿进程会被init进程（进程ID为1）接管，init进程会成为孤儿进程的新父进程，并负责回收子进程的资源。


#### 一个由init抚养的进程终止时会怎样？
init被编写成：无论何时只要有一个子进程终止，inir就会调用一个`wait`取得其终止状态，避免系统中塞满了僵尸进程。



## 8.6 函数wait和waitpid
当一个进程正常或异常终止时，内核就向其父进程发送`SIGCHLD`信号（意味着子进程状态改变）。因为**子进程的终止属于异步事件**，所以这种由内核发向父进程的通知对于父进程来说也是异步的。
父进程收到该信号时，可以忽略，或者提供对应的信号处理函数。

### 调用wait或waitpid的进程
1. 如果其所有子进程都还在运行，则阻塞
2. 如果一个子进程已终止，正等待父进程获取其`终止状态`，则取得该子进程的终止状态立即返回
3. 如果没有任何子进程，则立即出错返回
（如果进程由于接收到`SIGCHLD`信号而调用wait，希望wait立即返回，只不过实际情况难以预测，进程可能阻塞）

```cpp
#include <sys/wait.h>
// 以下两函数若成功，则返回进程ID，若出错，则返回0或-1
// status是一个指向整型变量的指针，用于存储子进程的终止状态。

pid_t wait(int *statloc);
// 使得调用进程（调用wait的线程）一直阻塞直到有一个子进程终止（具体是哪个子进程终止了，可以通过返回值得知）

pid_t waitpid(pid_t pid, int *statloc, int options);
/*
    waitpid不等待在其调用后的第一个终止子进程
    可通过options控制要等待的进程
*/
```
以上两函数返回的整型状态字是由实现定义的（**某些位表示退出状态（正常返回），其他位表示信号编号（异常返回），有一位指示是否产生core文件**）
POSIX.1规定，终止状态用定义在`<sys/wait.h>`中的宏来查看
有四个互斥的宏可用于取得进程终止原因：
`WIFEXITED`
    若正常终止子进程返回的状态，则为真
    可执行WEXITSTATUS，获取子进程传送给exit或_exit参数的低8位
`WIFSIGNALED`
    若为异常终止子进程返回的状态，则为真
    可执行WTERMSIG，获取使子进程终止的信号编号
`WIFSTOPPED`
    若为当前暂停子进程返回的状态，则为真
    可执行WSTOPSIG，获取使子进程暂停的信号编号
`WIFCONTINUED`
    若在作业控制暂停后已经继续的子进程返回可状态，则为真


#### 双重fork
在双重fork()的过程中，父进程首先调用一次`fork()`，创建一个子进程。然后，子进程再调用一次`fork()`，创建一个孙子进程。此时，子进程退出，孙子进程成为一个孤儿进程，即它的父进程已经退出，它被init进程接管。
孙子进程不再与父进程有任何关联，它可以独立运行，不受父进程的影响。这在一些特殊的场景下非常有用，比如在创建守护进程时，需要让子进程成为孤儿进程，以避免父进程在后续操作中对它的影响。
需要注意的是，双重fork()的过程中，每次调用fork()都会创建一个新的进程，因此需要注意进程的资源消耗和管理。同时，孙子进程需要自己处理一些父进程通常会处理的任务，比如打开文件、设置信号处理等。

## 8.7 函数waitid
```cpp
#include <sys/wait.h>
int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options)；
// 成功返回0，失败返回-1
```

## 8.9 竞争条件



## 8.10 函数exec
调用`fork`函数创建新的子进程后，子进程往往要调用`exec`函数以执行另一个程序
当进程调用一种（共有7种）`exec`函数时（而不创建新进程，所以进程ID不会改变），该进程执行的程序完全替换为新程序，从main函数开始执行
**`exec`只是用磁盘上的一个新程序替换了当前进程的正文段、数据段、堆段、栈段**
**所有的`exec`函数使得UNIX系统进程控制原语更加完善，用`fork`可以创建新进程，用`exec`可以执行新的程序，`exit`和`wait`函数处理终止和等待终止，这些就是必需的基本进程控制原语**

```cpp
#include<unistd.h>
int execl(const char* pathname, const char* arg0, ...); // 路径名 并且命令行参数一个个地传递
...
int execlp(const char* filename, const char* arg0, ...);    // 文件名
/*
若包含/，则视为路径名，否则就按照PATH环境变量，在所指定的各目录种搜寻可执行文件
若找到一个可执行文件，但不是由链接编辑器产生的机器可执行文件，则认为该文件是一个shell脚本，尝试调用/bin/sh，将该filename作为shell的输入
*/

int execve(const char* pathname, char *const argv[], char *const envp[]);   // 是内核的系统调用，另外6个最终都会调用它

int fexecve(int fd, char *const argv[], char* const envp[]);    // 文件描述符 接收命令行参数数组
/*
 依赖调用进程来完成寻找可执行文件的操作，调用进程可使用文件描述符验证所需的文件，并无竞争地执行该文件（要不然拥有特权的恶意用户就可以在找到文件位置并验证之后，但在调用进程执行该文件之前替换可执行文件）
本质上是使用/proc把文件描述符参数转换成路径名
*/


// 以上函数成功不返回，失败返回-1
```
PS：
`/proc`是一个特殊的虚拟文件系统，它在Linux系统中扮演着重要的角色。它提供了一种访问和操作内核数据结构的接口，以及获取系统和进程信息的途径。
在`/proc`文件系统中，每个运行的进程都有一个对应的目录，以进程ID（PID）命名。例如，进程ID为123的进程将在`/proc/123`目录下有一个对应的目录。这些目录中包含了与该进程相关的信息，如进程状态、命令行参数、打开的文件、内存映射、网络状态等。
除了进程目录外，`/proc`文件系统还包含了其他一些特殊的文件和目录，用于提供系统级别的信息。例如：
- `/proc/cpuinfo`：包含有关CPU的信息。
- `/proc/meminfo`：包含有关内存的信息。
- `/proc/filesystems`：列出当前支持的文件系统。
- `/proc/sys`：包含一些系统参数和配置项。
通过读取和解析`/proc`文件系统中的文件，可以获取有关系统和进程的各种信息，这对于系统监控、性能分析、调试和诊断非常有用。
需要注意的是，`/proc`文件系统中的文件和目录并不是实际的磁盘上的文件，而是内核在运行时动态生成的。因此，对`/proc`文件系统的读取和操作实际上是在与内核进行交互。


`PATH`变量包含了一张目录表（称为路径前缀，目录之间用冒号隔开）：
```shell
PATH=/bin:/usr/bin:/usr/local/bin:.
# 最后的.表示当前目录
```
以e结尾的exec函数接收环境变量表，其余函数调用进程中的environ变量为新程序复制现有的环境
通常，一个进程允许将其环境传播给其子进程，有时进程想为子进程指定某一个确定的环境：例如初始化一个新登录的shell时，login程序通常创建一个只定义少数几个变量的特殊环境，可以设置一个shell启动文件

执行`exec`后，新程序继承了一些属性（进程ID、父进程ID、实际用户ID、进程组、工作目录、根目录、文件锁等）



## 8.11 更改用户ID和更改组ID
UNIX系统中，**特权（改变当前日期的表示）**和**访问控制（读写权限）**是基于**用户ID**和**组ID**的。
设计应用时，一般使用**最小特权**模型，我们的程序应该只有为完成给定任务所需的最小特权（以未预料的方式使用特权会造成安全性风险）。
```c
#include<unistd.h>
int setuid(uid_t uid);  // 设置实际用户ID、有效用户ID

int setgid(gid_t gid);  // 设置实际组ID、有效组ID
```

每个进程在UNIX系统中都有三种用户ID：
1. `实际用户ID`（real user ID）：表示启动进程的用户的ID。

2. `有效用户ID`（effective user ID）：用于确定进程对文件和系统资源的访问权限。
当进程尝试访问资源时，内核会使用有效用户ID来检查权限。

3. `保存的用户ID`（saved user ID）：用于特权操作时保存先前的有效用户ID。
用于保存之前的`有效用户ID`，以便在需要时恢复。通常在执行特权操作时使用，执行完后可以恢复之前的`有效用户ID`。

### 更改用户ID的规则（对组ID同样适用）
1. 若进程具有超级用户特权，则`setuid`将`实际用户ID`、`有效用户ID`、`保存的设置用户ID`（`saved set-user-ID`）设置为`uid`，使得进程能够执行一些UID为`uid`的用户才能执行的操作

2. 若进程没有超级用户特权，但是`uid`等于`实际用户ID`或`保存的设置用户ID`，则`setuid`只将`有效用户ID`设置为`uid`

3. 若都不满足，则errno设置为EPERM，返回-1

关于内核所维护的3个用户ID：
1. 只有超级用户进程可以更改`实际用户ID`
`实际用户ID`是在用户登录时，由`login(1)`程序设置的，并且决不会改变，因为`login`是一个超级用户进程，当它调用`setuid`时，设置所有的3个用户ID

2. 仅当对程序文件设置了`设置用户ID位`时，`exec`才设置`有效用户ID`

3. `保存的设置用户ID`是由`exec`复制`有效用户ID`而得到的。
若设置了文件的`设置用户ID位`，则在`exec`根据文件的用户ID设置了进程的`有效用户ID`后，这个副本就被保存了。





## 8.15 用户标识
任一进程都可以得到`实际用户ID`、`有效用户ID`、`组ID`
`getpwuid()`或`getuid()`可以获得运行该程序用户的登录名




## 8.16 进程调度
UNIX历史上提供对进程基于**调度优先级**的**粗粒度**控制
**调度策略**和**调度优先级**是由内核确定的，进程可以通过调整nice值（）选择以更低优先级运行（nice越大，降低对CPU的占有，说明这个进程很nice），只有特权进程允许提高调度权限
POSIX实时扩展增加了多个调度类别以进一步细调
进程的优先级可以`get`、`set`
PS：即便两进程nice值相同，占用CPU的百分比也不一定完全相同，因为进程调度不精确






# 第九章 进程关系


## 9.8 作业控制
PS：
在UNIX系统中，作业（**即进程组**）是指在一个shell会话中由一个或多个进程组成的一组任务。一个作业可以由一个或多个进程组成，这些进程可以是前台进程或后台进程。
前台进程是指当前正在运行的进程，它会占用终端并接收用户输入。当一个作业中有多个前台进程时，它们共享同一个终端。
后台进程是指在后台运行的进程，它不会占用终端并且不会接收用户输入。当一个作业中有多个后台进程时，它们可以并行运行。
在UNIX系统中，可以使用作业控制命令来管理作业。常用的作业控制命令包括：
- jobs：列出当前会话中的所有作业。
- fg：将一个作业中的前台进程切换到前台运行。
- bg：将一个作业中的后台进程切换到后台运行。
- Ctrl-Z：将一个作业中的前台进程挂起，并将其切换到后台运行。
作业控制命令可以帮助用户管理多个进程的运行，提高工作效率。

**作业控制**允许在一个终端上启动多个作业（进程组），它控制哪一个作业可访问该终端以及哪些作业在后台运行。
作业控制要求以下三种形式的支持：
1. 支持作业控制的shell
2. 内核中的终端驱动程序必须支持作业控制
3. 内核必须提供对某些作业控制信号的支持






# 第十章 信号
## 10.1 引言
信号是软件中断，信号提供了一种处理异步事件的方法：比如用户在中断键入中断键，就会通过信号机制停止一个程序，或及早终止管道中的下一个程序。
POSIX.1对可靠信号例程做了标准化（UNIX系统的早期版本就已提供信号机制，但是信号模型并不可靠，信号可能丢失）。

## 10.2 信号概念
每个信号都有一个名字，都是以'SIG'开头。
例如：
`SIGABRT`（夭折信号，进程调用abort时产生）、`SIGALRM`（闹钟信号，alarm函数设定的定时器超时后产生）
信号都被定义为正整数常量（定义在内核的头文件，然后在用提供给用户的头文件去包含它）
不存在编号为0的信号，kill函数对信号编号0有特殊应用（又被称为空信号）

### 可以产生信号的条件
1. Ctrl + C，Delete键都可以产生中断信号（`SIGINT`）
2. 硬件异常产生信号：除数为0、无效的内存引用（对应`SIGSEGV`信号）等。
    通常由硬件检测到这些条件，并通知内核，然后内核根据情况产生适当的信号。
3. 进程调用kill(2)函数可以将任意信号发送给另一个进程或进程组。
    接收信号进程和发送信号进程的所有者必须相同 / 发送信号进程的所有者必须是超级用户
4. 用户可用kill(1)命令将信号发送给其他进程
 常用于终止一个失控的后台进程
5. 当检测到某种**软件条件**已经发生，并应将其通知有关进程时也产生信号，例如`SIGURG`（在网络连接上传来带外的数据），`SIGPIPE`（在管道的读进程已终止后，一个进程写此管道）以及SIGALRM

信号是**异步事件**的经典实例，毕竟产生信号的事件对于进程而言是随机的，进程不能简单地测试一个变量（如error）来判断是否发生了一个信号，而是必须告诉内核：在此信号发生时，请执行以下操作。

### 对信号的处理方法
1. 忽略
    **`SIGKILL`和`SIGSTOP`是例外，不可忽略**，它们向内核和超级用户提供了使进程终止或停止的可靠方法，如果忽略某些由硬件异常产生的信号（非法内存引用或除数为0），则进程运行行为是未定义

2. 捕捉
    `通知内核在某种信号发生时，调用一个用户函数，从而执行用户对这种事件希望进行的处理`
    例如：命令解释器程序：
        当用户键盘产生中断信号时，该命令解释器理论上应该回到主循环，终止当前命令，
        如果能够捕捉到`SIGCHLD`信号，则表示一个子进程已经终止，那么`该信号的捕捉函数`就可以调用`waitpid`以取得`该子进程的进程ID以及它的终止状态`

`SIGKILL`和`SIGSTOP`是例外，不可捕捉

3. 执行系统默认动作
默认动作一般是终止该进程
默认动作如果是`终止 + core`，则意味着`在进程当前工作目录的core文件中 复制了该进程的内存映像`（可以使用core文件检查进程终止时的状态）。


## 10.3 函数signal
```cpp
#include<signal.h>
void (*signal(int signo, void (*func)(int)))(int);
// signo 信号名、func的值是接到此信号后要调用的函数的地址（如果其值为SIG_IGN，则向内核表示忽略此信号；如果其值为SIG_DFL，则表示执行系统默认动作）
```
如果指定函数地址，则调用对应函数，这种处理被称为**信号处理程序**/**信号捕捉函数**
signal函数原型说明该函数要求两个入参，返回值是一个函数指针，它指向的函数返回值是void类型，有一个int入参（它的意义是指向之前的信号处理程序函数）。
```cpp
typedef void Sigfunc(int);
Sigfunc *signal(int, Sigfunc*);
```

kill(1)命令，用于发送一个信号给一个进程或者进程组（是否终止取决于信号的类型，以及进程是否捕捉该信号）
```shell
kill -USR1 7216
# 表示给7216号进程发SIGUSR1信号

kill 7216
# 表示给7216号进程发SIGTERM信号，假设该进程不捕捉SIGTERM信号，而对该信号的系统默认动作是终止，于是进程就终止
```

### 1. 程序启动时
执行程序时，一般所有信号都被设置为默认动作，除非调用exec的进程忽略该信号。
`exec函数`将原先设置为要捕捉的信号都更改为默认动作，其他的信号状态不变。
(一个进程原先要捕提的信号，当其执行一个新程序后就不能再捕捉了，`因为信号捕捉函数的地址很可能在所执行的新程序文件中已无意义`，
这是因为当进程执行一个新程序时，它的地址空间会被重新分配，原先注册的信号处理函数的地址可能已经失效，因此进程不能再捕捉原先要捕获的信号。)

（PS：当我们说一个进程执行一个新程序时，意味着该进程正在运行的程序（也称为进程的映像）被替换为另一个程序的映像。
这通常是通过调用exec系列函数来实现的，如`execve`、`execvp`等。
在UNIX系统中，每个进程都有一个当前运行的程序映像，它包含了程序的代码、数据和其他相关资源。
**当进程执行一个新程序时，操作系统会将新程序的映像加载到进程的地址空间中，取代原先的程序映像。**这样，进程就开始执行新程序的代码，并使用新程序的数据和资源。
执行新程序的原因可能是进程需要切换到另一个功能或逻辑，或者是通过调用另一个程序来完成某个任务。例如，一个shell进程可以通过执行用户输入的命令来启动不同的程序，每次执行新的命令时，就会执行一个新的程序。
需要注意的是，当进程执行一个新程序时，它的状态和上下文信息可能会发生变化。
例如，`进程的打开文件描述符、环境变量、命令行参数等可能会被重置或改变`。
因此，在执行新程序之前，进程通常会保存必要的状态信息，以便在需要时进行恢复。
总之，当进程执行一个新程序时，它的当前运行的程序映像会被替换为另一个程序的映像，进程开始执行新程序的代码，并使用新程序的数据和资源。**这是进程切换到不同功能或任务的一种常见方式。**）


一个具体例子是：一个交互 shell 如何处理针对后台进程的中断和退出信号。对于一个非作业控制 shell，当在后台执行一个进程时，例如:
```sh
cc main.c &
```
shel1 自动将后台进程对中断和退出信号的处理方式设置为忽略。
于是，当按下中断字符时就不会影响到后台进程。
如果没有做这样的处理，那么当按下中断字符时，它不但终止前台进程，也终止所有后台进程。
很多捕捉这两个信号的交互程序具有下列形式的代码:
```c
void siq_int(int), sig_quit(int);
if (signal(SIGINT, SIG_IGN) != SIG_IGN) // 返回SIG_IGN则表示忽略此信号
    signal(SIGINT, sig_int);    // 设置信号处理程序
if (signal(SIGQUIT, SIG_IGN) != SIG_IGN)
    signal(SIGQuIT， siq_quit);
```
这样处理后，仅当SIGINT 和 SIGOUIT 当前未被忽略时，进程才会捕捉它们。
从 signa1 的这两个调用中也可以看到这种函数的限制：
    不改变信号的处理方式就不能确定信号的当前处理方式。
    我们将在本章的稍后部分说明使用 sigaction 函数可以确定一个信号的处理方式，而无需改变它。

### 2. 进程创建时
`当一个进程调用 fork 时，其子进程继承父进程的信号处理方式`。
因为子进程在开始时复制了父进程内存映像，所以信号捕捉函数的地址在子进程中是有意义的。





# 第十一章 线程
## 11.2 线程概念
### 多线程好处
1. 为`每种事件类型`分配`单独的处理线程`，可以简化异步事件的代码，每个线程在进行事件处理时可采用`同步编程模式`
2. `多进程`必须使用OS提供的复杂机制才能实现`内存`和`文件描述符`的`共享`，而多线程自动可以访问相同的存储地址空间和文件描述符
3. 有些`问题``分解`后可以提高整个程序的吞吐量，单线程进程要处理多任务必须把任务`串行化`，而多线程时，相互独立的任务可以交叉运行
4. 交互的程序可以使用多线程来改善响应时间，多线程可以把业务逻辑区分

即便是单处理器，多线程编程模型也是有益的，
不管处理器数量，程序都可以使用线程来简化，而且多线程可以实现部分地阻塞，改善响应时间和吞吐量

### `每个线程``执行环境`必需的信息
- 线程ID、
- 一组寄存器值、
- 栈、
- 调度优先级、
- 策略、
- 信号屏蔽字、
- errno变量、
- 线程私有数据
**一个进程的所有信息对该进程的所有线程都是共享的，包括可执行程序的代码、程序的全局内存和堆内存、栈以及文件描述符。**


## 11.3 线程标识
线程ID只有**在所属的进程上下文中才有意义**
```cpp
#include<pthread.h>
int pthread_equal(pthread_t tid1, pthread_t tid2);
// 线程ID是用pthread_t来表示的，不像进程ID是个非负整数
```

## 11.4 线程创建
传统UNIX进程模型中，每个进程只有一个控制线程
```cpp
#include<pthread.h>
int pthread_create(pthread_t *restrict tidp, const pthread_attr_t *restrict attr, void *(*start_rtn)(void*), void *restrict arg);
/*
    当pthread_create成功返回，新创建线程的线程ID会被设置成tidp指向的内存单元
    attr参数用于指定线程属性
    start_rtn是函数指针，表示传递给新线程的入口函数
    arg是传递给新线程入口函数的参数
*/
```
线程创建时不保证哪个线程会先运行，新线程会继承调用线程的浮点环境和信号屏蔽字，清除挂起信号集
pthread调用失败时返回错误码，而不像其他POSIX函数一样设置errno，每个线程提供errno的副本，对于线程而言，从函数中返回错误码更为清洗整洁，这样可以不依赖随着函数执行而不断变化的全局状态，从而把错误范围限制在引起出错的函数中


## 11.5 线程终止
如果进程中的任意线程调用了exit、_Exit或_exit，那么整个进程就会终止。类似地，如果默认动作是终止进程，那么发送到线程的信号就会终止整个进程

### 线程的三种退出方式（不终止整个进程）
1. 简单地从启动例程中返回，返回值是线程的退出码
2. 被同一进程中的其他线程取消
3. 线程调用`pthread_exit`
```cpp
#include<pthread.h>
void pthread_exit(void *rval_ptr);
// rval_ptr可传递参数
```

```cpp
#include<pthread.h>
int pthread_join(pthread_t thread, void **rval_ptr);
// 使得调用线程一直阻塞，直到指定线程调用pthread_exit、从启动例程中返回或被取消
// 如果线程简单地从启动例程中返回，rval_ptr就包含返回码，该函数可用于获得入参线程的退出状态
```
注意：以上无参类型指针rval_ptr可以传递的值不止一个，**可以传递复杂的结构体信息（前提是是其内存在调用者完成调用后仍然有效）**
例如：如果在调用线程的栈上分配了那么一个结构，那么其他的线程在使用这个结构时内存内容可能已经改变了。
又如，线程在自己的栈上分配了一个结构，然后把指向这个结构的指针传给pthread_exit（让其返回出去），那么调用pthread_join的线程试图使用该结构时，这个栈有可能已经被撤销，这块内存也已另作他用。

```cpp
#include<pthread.h>
int pthread_cancel(pthread_t tid);
// 线程调用该函数可以请求取消同一进程中的其他线程，该函数不等待线程终止，仅仅提出请求
```
线程可以安排它退出时需要调用的函数（常常被称为线程清理处理程序，thread cleanup handler）
一个线程可以建立多个清理处理程序，处理程序记录在栈中，也就是说，它们的执行顺序与注册顺序**相反**
```cpp
#include<pthread.h>
void pthread_cleanup_push(void(*rtn)(void*), void *arg);
void pthread_cleanup_pop(int execute);
```
对于以下操作，清理函数rtn是由`pthread_cleanup_push函数`调度的，调用时只有一个参数arg：
1. 调用`pthread_exit`时
2. 响应取消请求时
3. 用非零execute参数调用`pthread_cleanup_pop`时
    如果executr参数设置为0，清理函数将不被调用



## 11.6 线程同步
当多个控制线程共享相同的内存时，需要确保每个线程看到的数据一致。若临界资源不会被其他线程读取和修改，自然就不存在一致性问题。
**但若一个线程可以修改的变量，其他线程也可以读取或修改时，就需要线程同步，确保多线程访问变量的存储内容时不会访问到无效的值**

那么线程必须使用**线程锁**
考虑变量增量操作的细节情况：
1. 从内存单元读取数据到寄存器
2. 在寄存器中对变量做增量操作
3. 把新的值写回内存
如果两线程几乎在同一时刻对同一个变量做增量操作而不同步的话，结果就是随机的（考虑以上操作的排列组合），可能是加一次，可能是加两次。
如果修改是原子操作（比如如果增量操作只要一个存储器周期，就不存在竞争，因为最小粒度就是到一个存储器周期了，不会被打断），则不存在竞争


### 11.6.1 互斥量
`pthread`提供互斥接口，确保线程的互斥操作。
**互斥量**本质上是一把锁，在访问共享资源前对互斥量进行加锁（其他线程如果想再次加锁，就会被阻塞，直到互斥锁被释放），在访问完成后释放互斥量（解锁）。
如果互斥量释放时，有一个以上的线程阻塞，那么所有该锁上的阻塞线程都会变成可运行状态，而其中第一个变为可运行状态的线程就可以对互斥量加锁，其他线程仍然会被阻塞。

只有将所有线程都设计成遵循相同数据访问规则，互斥的机制才能正常工作

```cpp
// UNIX中的互斥量
#include<pthread.h>
int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);
// 使用互斥量之前必须初始化

int pthread_mutex_destroy(pthread_mutex *mutex);
// 如果互斥量是通过调用malloc函数动态分配的，则需要调用这个destroy函数

int pthread_mutex_lock(pthread_mutex_t *mutex);

int pthread_mutex_trylock(pthread_mutex_t *mutex);
// “尝试”对互斥量加锁，如果能锁住才锁

int pthread_mutex_unlock(pthread_mutex_t *mutex);
```


### 11.6.2 避免死锁
死锁的经典场景之一：
**循环等待**：使用多个互斥量，如果允许一个线程一直占有第一个，而在试图锁住第二个时阻塞了，而拥有第二个互斥量的线程也在试图锁住第一个
解决办法：**控制互斥量加锁的顺序**

### 11.6.3 函数pthread_mutex_timedlock
可以绑定线程阻塞时间，**防止永久的阻塞**
```cpp
#include<pthread.h>
int pthread_mutex_timedlock(pthread_mutex_t *restrict mutex, const struct timespec *restrict tsptr);
// 当达到超时时间，该函数不会对互斥量加锁，而是返回错误码：ETIMEDOUT
```

### 11.6.4 读写锁
相比互斥锁，允许更高的并行性。
读写锁有3种状态：
1. 读模式下加锁状态
2. 写模式下加锁状态
3. 不加锁状态
一次只有一个线程可以占有写模式的读写锁
多线程可以同时占有读模式的读写锁
当读写锁是写加锁状态时，在这个锁被解锁之前，所有试图对这个锁加锁的线程都会被阻塞
当读写锁在读加锁状态时，所有试图以读模式对它进行加锁的线程都可以得到访问权，但是任何希望以写模式对此锁进行加锁的线程都会阻塞，直到所有的线程释放它们的读锁为止。
虽然各操作系统对读写锁的实现各不相同，但当读写锁处于读模式锁住的状态，而这时有一个线程试图以写模式获取锁时，读写锁通常会阻寒随后的读模式锁请求。这样可以避免读模式锁长期占用，而等待的写模式锁请求一直得不到满足。
读写锁非常适合于**对数据结构读的次数远大于写的情况**。当读写锁在写模式下时，它所保护的数据结构就可以被安全地修改，因为一次只有一个线程可以在写模式下拥有这个锁。当读写锁在读模式下时只要线程先获取了读模式下的读写锁，该锁所保护的数据结构就可以被多个获得读模式锁的线程读取。
读写锁也叫做共享互斥锁 (***shared-exclusive lock***)。当读写锁是读模式锁住时，就可以说成是以共享模式锁住的。当它是写模式锁住的时候，就可以说成是以互斥模式锁住的。
与互斥量相比，读写锁在使用之前必须初始化，在释放它们底层的内存之前必须销毁。
```cpp
#include<pthread.h>
int pthread_mutex_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);   // 读写锁需要调用该函数初始化

int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);   // 释放内存前要调用该函数做清理工作

int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
// rd: read, 在读模式下锁定读写锁

int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
// wr: write, 在写模式下锁定读写锁

int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
// 解锁

// 各种实现可能对共享模式下可获取的读写锁的次数进行限制
```

### 11.6.5 带有超时的读写锁
使得获取读写锁时避免陷入永久阻塞

### 11.6.6 条件变量
条件变量与互斥量一起使用时，允许线程以无竞争的方式等待特定的条件发生
**条件本身是由互斥量保护的**
线程要改变条件状态之前，**必须锁住互斥量**，那么对于其他线程而言，没获取到互斥量旧不会察觉到条件状态的改变，因为互斥量必须在锁定后才能计算条件
```cpp
#include<pthread.h>
int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);
// 将互斥量作为参数传入，从而对条件进行保护
int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict tsptr);
// 多了个超时时间的设定
```
调用者把锁住的互斥量传给函数，函数接着把调用线程放到等待条件的线程列表上，**对互斥量解锁**
（目的是：关闭条件检查和线程进入休眠状态等待条件改变这两个操作之间的时间通道）
当`pthread_cond_wait`返回时，**互斥量再次被锁住**

```cpp
#include <pthread.h>

struct msg {
struct msg *m_next;
};

struct msg *workq;  // 工作队列

pthread_cond_t qready = PTHREAD_COND_INITIALIZER;
pthread_mutex_t qlock = PTHREAD_MUTEX_INITIALIZER;

// 消费者
void process_msg(void)
{
    struct msg *mp;
    for (;;) {
        pthread_mutex_lock(&qlock);
        while (workq == NULL)
            pthread_cond_wait(&qready, &qlock); // 阻塞
        mp = workq;
        workq = mp->m_next; // 链表节点后移
        pthread_mutex_unlock(&qlock);
        /* now process the message mp */
    }
}

// 生产者
void enqueue_msg(struct msg *mp)
{
    pthread_mutex_lock(&qlock);
    mp->m_next = workq; // 新加入的节点添加到队列头部
    workq = mp; // 只有对消息队列的改动操作，才需要互斥量的保护
    pthread_mutex_unlock(&qlock);
    pthread_cond_signal(&qready);
    /*
        给等待线程发信号不需要占有互斥量：
        只要线程在调用pthread_cond_signal函数之前把消息从队列中拖出，消费者线程就可以在生产者线程释放互斥量后完成这部分工作，因为根本就不用阻塞了
    */
}
```
在消费者线程中使用了一个while循环来检查队列是否为空，而不是使用if语句。
使用`while`的话，从`pthread_cond_wait`返回还会检测队列是否为空(因为在while循环里面，只有不满足条件才会跳出循环)，发现队列为空，然后继续返回等待。但是使用`if`的话，代码逻辑都往下执行了，就虚假唤醒了。
生产者提前释放锁的意义是，让消费者更快地进入逻辑



### 11.6.7 自旋锁
类似互斥量，但不是通过休眠使进程阻塞，而是在获取锁之前一直处于**忙等（自旋）阻塞状态**
常用的情况：锁被持有的**时间短**，而且线程并**不希望在重新调度上花费太多的成本**（代价就是一定程度上的CPU资源的浪费，当线程自旋等待锁变为可用时，CPU不能做其他的事情）

通常作为底层原语用于实现其他类型的锁
自旋锁在**非抢占式内核（无法被中断）**中非常有用，除了提供互斥机制外，还会阻塞中断，使得中断处理程序不会让系统陷入死锁状态，因为中断处理程序要获取已被加锁的自旋锁（中断实质也是一种抢占）。
在这种类型的内核中，中断处理程序不能休眠（休眠了的话，就会被操作系统调度走，破坏了非抢占性），因此它们能用的同步原语只能是自旋锁
当一个线程或中断处理程序获取了自旋锁时，它会**阻塞其他中断的发生**。这是为了避免中断处理程序尝试获取已被加锁的自旋锁，从而导致系统陷入死锁状态。
通过阻塞中断，自旋锁确保了中断处理程序不会与其他线程或中断处理程序发生竞争，从而保证了系统的正确性和稳定性。

但是自旋锁在用户层没什么用，除非允许在**不允许抢占的实时调度类**中。
运行在分时调度类中的用户层线程在两种情况下可以被取消调度：
1. 当它们的**时间片到期**了
2. 具有**更高调度优先级**的线程就绪，变成可运行时
在这些情况下，如果线程拥有自旋锁，它就会进入休眠状态，阻塞在锁上的其他线程自旋的时间，可能比预期的时间更长

如果线程在用户层拥有自旋锁，并且其他线程正在自旋等待该锁，那么线程将进入休眠状态，阻塞在自旋锁上的其他线程将会继续自旋等待。**由于用户层线程的调度是由操作系统的调度器控制的（非实时性调度系统，存在其他调度策略，想象中的一直忙等于是无法实现），而不是自旋锁本身，因此自旋锁无法阻止线程被调度器挂起**。
这就意味着，如果线程拥有自旋锁并且在用户层中运行，当线程被挂起时，其他线程在自旋等待该锁的时间可能会比预期的更长。因为自旋锁只适用于在不允许抢占的实时调度类中，这些调度类中的线程不会被调度器抢占，因此可以安全地自旋等待锁的释放。

由于很多互斥量的实现很高效，甚至相比自旋锁的性能基本是相同的
实际上，有些互斥量的实现在试图获取互斥量的时候会**自旋一小段时间**，只有在自旋计数达到某一阈值，才会休眠
```cpp
#include<pthread.h>
int pthread_spin_init(pthread_spinlock_t *lock, int pshared);
/*
    其中的pshared是自旋锁特有的，该属性只在支持线程进程共享同步选项的平台（只在Single UNIX Specification是强制的）才用得到
    pshared表明进程共享属性，表明自旋锁是如何获取的
    如果设为PTHREAD_PROCESS_SHARED，则自旋锁能被可以访问锁底层内存的线程所获取，即便那些线程属于不同进程
    如果设为PTHREAD_PROCESS_PRIVATE，自旋锁只能被初始化该锁的进程内部的线程所访问
*/

int pthread_spin_destroy(pthread_spinlock_t *lock);
```

**不要调用在持有自旋锁情况下可能会进入休眠状态的函数，它们会浪费CPU资源，因为其他线程需要获取自旋锁需要等待时间就相应地延长了**



## 11.6.8 屏障
是**用户协调多个线程并行工作的同步机制**
屏障允许每个线程等待，直到所有的合作线程都到达某一点，然后从该点继续执行
`pthread_join`就是一种屏障：允许一个线程等待 直到另一个线程退出
屏障在广义上，允许**任意数量**的线程等待，直到所有的线程完成处理工作，而线程达到屏障后可以继续工作
经典示例：
多线程实现堆排序，n个工作线程和主线程都执行`pthread_barrier_wait`，使得最后主线程将结果合并



# 第十二章 线程控制
## 12.3 线程属性
设计了一些函数来管理线程的属性对象
```cpp
#include<pthread.h>

int pthread_attr_init(pthread_attr_t *attr);    // pthread_attr_t包含线程属性默认值
int pthread_attr_destroy(pthread_attr_t *attr);
```





## 12.4 同步属性














# 第十五章 进程间通信


## 15.6 XSI IPC
3种IPC被称为**XSI IPC**：消息队列、信号量、共享存储，三者有相似之处
（其实现源自于UNIX系统的System V版本，最终在POSIX标准上得以规定）

### 15.6.1 标识符和键
每个内核中的IPC结构（消息队列、信号量、共享内存）都是通过**标识符**（非负整数，相比文件描述符而言，是比较大的整数）来引用
例如，要向一个消息队列发送消息或者从一个消息队列取消息，只需要知道其队列标识符。
当一个IPC结构被创建，然后又被删除时，与这种结构相关的标识符连续加1，这样的操作会1直到达到一个整型数的最大正值，之后再回到0。
标识符时IPC对象的内部名，还需要一个外部名字（称之为key）来使得多个合作进程能够再同一IPC对象上汇聚。
在通过mssget、semget、shmget创建IPC结构时，都应指定一个键（是基本系统数据类型key_t,在<sys/types.h>被定义为长整型），它由内核变换成标识符

#### 使client进程和server进程能够再同一IPC对象上汇聚
1. server指定键**IPC_PRIVATE**（使用IPC_PRIVATE创建的IPC对象, key值属性为0，和IPC对象的编号就没有了对应关系，用于有亲缘关系的进程。可用于父进程子关系，父进程通过它创建的IPC结构返回的标识符可供fork后的子进程使用）创建一个新IPC结构，将返回的标识符放在文件等地以便client进程取用
2. 在一个公用头文件中定义一个client和server都认可的键，然后server通过此键创建一个新的IPC结构（但是该键可能已经和一个IPC结构相结合）
3. client和server进程认同同一个路径名和项目ID（0 ~ 255），然后调用ftok将这两个值变换为一个键，然后使用方法2

### 15.6.2 权限结构
每个XSI IPC结构关联一个ipc_perm结构，规定了权限和所有者。

### 15.6.3 结构限制
三者都有内置限制，但大多可以通过重新配置内核来改变

### 15.6.4 优点和缺点
#### 缺点
1. IPC结构是在系统范围内起作用的，**没有引用计数**
例如：如果进程创建了一个消息队列，并往队列放了几则消息，然后终止，这个消息队列及其内容都不会删除（除非被某个进程删除），如果是管道的话，当最后一个引用管道的进程终止时，管道就会被删除。如果是FIFO（有名管道），当最后一个引用FIFO的进程终止时，虽然FIFO的名字还会保存在系统中，但是其中的数据会被删除。

2. 这些IPC结构在文件系统中没有名字
因而无法使用文件操作（ls、rm、chmod），内核因此增加了十几个全新的系统调用（msgget、semop、shmat）
因为这些IPC不存在文件描述符，所以不能使用多路转换I/O函数（select、poll），因而很难一次使用两个及以上的XSI IPC结构。


#### 优点
可靠（因为范围在一台主机）、流控制的（如果系统资源（缓冲区）短缺，活接收进程不能再接收更多消息，则发送进程休眠，当流控制条件消失时，发送进程自动唤醒）、面向记录的
而UNIX流套接字可以做到：IPC设施能自动地为每个客户进程创建一个到服务器进程的唯一连接




## 15.7 消息队列
本质上是**消息的链表**，存储在内核中，由消息队列的标识符标识
`msgget`用于 创建一个 新队列 或 打开一个 现有队列
`msgsnd`用于将 新消息 添加到 队列尾端
`msgrcv`用于 从队列中 取消息。
每个队列都有一个`msqid_ds`结构与其关联，用于表示队列的当前状态

```cpp
#include<sys/msg.h>
int msgget(key_t key, int flag);    // 创建新队列或者打开现有的。若成功，则返回消息队列ID，若出错，则返回-1
```

## 15.8 信号量
是一个计数器，用于为多个进程提供对共享数据的访问
### 进程为了获得共享资源的经典场景：
1. 测试控制该资源的信号量
2. 若其为正，则进程可以使用该资源，并将信号量值 - 1
3. 否则，若此时信号量值为0，则进程进入休眠状态，直到信号量 > 0，进程被唤醒后，回到（1）
当进程使用完共享资源，信号量 + 1
（其中信号量的测试以及减1操作应当是**原子操作**，它是在内核中实现的）

常用的信号量形式称为**二元信号量**，控制单个资源，初始值为1（可以是任意正值，表示有多少个共享资源单位以供共享使用）
XSI信号量更为复杂，有以下特性：
1. 信号量不是单个非负值，而必须是含有一个或多个信号量值的集合，创建信号量时，要指定集合中的信号量个数
2. 信号量的创建独立于初始化，也就是说不能原子地创建一个信号量集合，并为他们赋初值
3. 进程终止时可能没有释放分配给它的信号量（undo功能用于处理这种情况）



## 15.9 共享存储
数据不用在client、server进程之间复制，速度最快
需要注意多进程访问同一个存储区的同步问题（通常用信号量、记录锁、互斥量控制）


```cpp
int shmget(key_t key,size_t size,int flag);
// 返回一个共享存储标识符
// 若成功则返回共享存储的ID
// size是共享内存段的长度 通常为系统页长的整数倍
```





共享存储区的位置，在栈空间（位于较高地址的位置）之下
高地址首先是命令行参数和环境变量，然后是栈空间、共享存储、堆区、未初始化的数据、已初始化的数据、地址最低的区域是正文
图15-32 在基于Intel的Linux系统上的存储区布局







# 第16章 网络IPC





## 16.2 套接字描述符
```c++
#include<sys/socket.h>
int socket(int domain, int type, int protocol);
// 若成功，则返回文件（套接字）描述符
// 第一个参数填写: AF_UNIX
```



# 第17章 高级进程间通信
## 17.1 引言
UNIX域套接字（Unix Domain Socket），用于IPC通信

## 17.2 UNIX域套接字
相比传统的网络套接字效率更高，UNIX domain socket仅复制数据，并不执行协议处理：添加或删除网络报头、计算校验和、 产生顺序号、发送确认报文等操作
UNIX域套接字提供**流**和**数据报**两种接口，它就像是**套接字和管道的混合**
是**可靠的**、不会丢失报文、也不会出错
一对相互连接的UNIX域套接字可以起到**全双工管道**的作用

```cpp
#include <sys/socket.h>
int socketpair(int domain, int type, int protocol, int sockfd[2]);  // 可用于创建一对无名的、相互连接的UNIX域套接字
```

### 经典案例
借助UNIX域套接字轮询XSI消息队列
**套接字和文件描述符相关**



### 补充
创建`UDS`这种socket时，指定参数family为：`AF_UNIX`。
server端的标识不再是ip和端口，而是一个路径（`/tmp/xxx`）。

#### 连接过程
相比inet的socket连接过程简单多了。
`client`端会先创建一个自己用的socket，然后调用`connect`和服务器建立连接，建立好后，就放到服务器正在监听的socket的接收队列中。此时，`server`就能通过accept得到和客户端配对好的新socket了（client端会创建这么一个socket给server使用）

连接
操作的实现：
```c
//file: net/unix/af_unix.c
static int unix_stream_connect(struct socket *sock, struct sockaddr *uaddr,
          int addr_len, int flags)
{
 struct sockaddr_un *sunaddr = (struct sockaddr_un *)uaddr;

 ...

 // 1. 为服务器侧申请一个新的 socket 对象
 newsk = unix_create1(sock_net(sk), NULL);

 // 2. 申请一个 skb，并关联上 newsk
 skb = sock_wmalloc(newsk, 1, 0, GFP_KERNEL);
 ...

 // 3. 建立两个 sock 对象之间的连接
 unix_peer(newsk) = sk;
 newsk->sk_state  = TCP_ESTABLISHED;
 newsk->sk_type  = sk->sk_type;
 ...
 sk->sk_state = TCP_ESTABLISHED;
 unix_peer(sk) = newsk;

 // 4. 把连接中的一头（新 socket）放到服务器接收队列中
 __skb_queue_tail(&other->sk_receive_queue, skb);
}
```

#### 发送过程
`send`
会去调用`sendto`系统调用
1. 找到socket（内核有片区域，记录了各种协议栈的函数地址）
2. 构造`msghdr`对象，其中存有buffer地址，data size。
进入协议栈`inet_sendmsg`后，内核会找到socket上的具体协议发送函数:`unix_stream_sendmsg`：
```c
//file:
static int unix_stream_sendmsg(struct kiocb *kiocb, struct socket *sock,
          struct msghdr *msg, size_t len)
{
 // 1.申请一块缓存区
 skb = sock_alloc_send_skb(sk, size, msg->msg_flags&MSG_DONTWAIT,
      &err);

 // 2.拷贝用户数据到内核缓存区
 err = memcpy_fromiovec(skb_put(skb, size), msg->msg_iov, size);

 // 3. 查找socket peer
 struct sock *other = NULL;
 other = unix_peer(sk);

 // 4.直接把 skb放到对端的接收队列中!!!
 skb_queue_tail(&other->sk_receive_queue, skb);

 // 5.发送完毕回调
 other->sk_data_ready(other, size);
}
```




# 补充
## Cgroup
cgroup的作用基本上就是**控制一个进程或一组进程**可以**访问或使用给定关键资源（CPU、内存、网络和磁盘 I/O）的量**。
一个容器中通常运行了多个进程，并且需要对这些进程实施统一控制，因此 cgroup 是容器的关键组件。



