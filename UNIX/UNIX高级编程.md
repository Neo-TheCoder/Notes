
# 第一章 UNIX基础知识
OS为运行的程序提供服务
典型的服务：
执行新程序、打开文件、读文件、分配存储区、获得当前时间

## 1.2 UNIX体系结构
UNIX操作系统的体系结构
**内核**：控制计算机硬件资源，提供程序运行环境
***系统调用***就是内核的接口。

应用程序既可以使用公用函数库，又可以使用系统调用。
shell是特殊的应用程序，为运行其他程序提供接口。

Linux是GNU操作系统使用的内核，因此可以称这种操作系统为GNU/Linux操作系统。


## 1.4 文件和目录
目录是一个包含**目录项**的文件。
每个目录项都包含一个文件名，同时还包含说明该文件属性（是普通文件还是目录、文件大小、所有者、权限、最后修改时间）的信息。


## 1.5 输入和输出
### 1.5.1 文件描述符
小的非负整数，内核用以标识一个特定进程正在访问的文件
当内核打开或创建一个新文件时，都会返回一个文件描述符，读写文件时可用。


### 1.5.2 标准输入、标准输出和标准错误
每当允许一个程序，所有shell都为其打开3个文件描述符：
标准输入、标准输出、标准错误
不做特殊处理则3个描述符都连接向终端
```shell
ls > file.list
# 使得描述符重定向到某个文件
```

### 1.5.3 不带缓冲的I/O函数
open read write lseek close
都会使用文件描述符

### 1.5.4 标准I/O函数
为那些不带缓冲的I/O函数提供一个带缓冲的接口
比如printf


## 1.6 程序和进程
### 1 程序
是一个存储在磁盘上某个目录中的可执行文件、内核使用exec函数，将程序读入内存，并执行程序

### 2 进程和进程ID
程序的执行实例被称为进程(process)，某些OS用任务task表示正在被执行的程序
UNIX系统确保每个进程都有一个唯一的标识符

### 3 进程控制
fork exec waitpid

### 4 线程和线程ID

通常一个进程只有一个控制线程thread――――某一时刻执行的一租机器指令
一个进程内的所有线程共享同一地址空间、文件描述符、栈以及进程相关的属性
线程ID只在所属的进程内起作用

## 1.7 出错处理
整型变量errno记录错误类型
#include<errno.h>
extern int errno;
多线程环境中每个线程都有属于自己的局部errno


## 1.8 用户标识
### 1 用户ID
0标识root用户

### 2 组ID
用户组

### 3 附属组ID



## 1.9 信号
用于通知进程发生了某种情况
例如除数为0，则需要把SIGFPE的信号发给该异常。
进程对异常的处理：
1、忽略
2、默认方式：终止
3、捕捉，处理


## 1.10 时间值
1、日历时间
2、进程时间
    UNIX系统为一个进程维护3个进程时间值
    时钟时间
    用户CPU时间：执行用户指令所用的时间量
    系统CPU时间：为该进程执行内核程序所经历的时间


## 1.11 系统调用和库函数
通用库函数可能调用一个或多个内核的系统调用 并非内核的入口点
例如prinf函数会调用write系统调用以输出一个字符串
malloc调用sbrk

进程控制系统调用fork、exec wait通常直接由用户应用程序直接调用


# 第三章 文件IO
UNIX系统中的大多文件IO只用到:
open、read、write、lseek、close
这些函数都是不带缓冲的I/O(unbuffered I/O),意思是每个read和write都调用内核中的一个系统调用
本章涉及:多个进程间如何共享文件 以及涉及到的内核有关的数据结构

## 3.2 文件描述符
对于内核,所有打开的文件都通过文件描述符引用(一对一的标识打开的文件,用于read,write的参数)
UNIX系统shell把文件描述符0与进程的标准输入关联,即符号常量**STDIN_FILENO** 1--> 标准输出**STDOUT_FILENO**    2--> 标准错误**STDERR_FILENO**
文件描述符的变化范围:0 ~ OPEN_MAX - 1

## 3.3 函数open和openat
```cpp
#include<fcntl.h>
int open(const char* path, int oflag, ...);
int openat(int fd, const char* path, int oflag, ...);   // 用于相对路径
// 成功返回对应文件描述符 失败返回-1
```

***TOCTTOU: time of check to time of use***
如果有两个基于文件的函数调用,第二个依赖第一个的结果,这个程序就是脆弱的 因为两个调用**不是原子操作** 在两个函数调用之间文件可能改变

## 3.4 函数creat
创建新文件

## 3.5 函数close
关闭一个文件会释放该进程加在该文件上的所有记录锁
当一个进程终止,内核自动关闭所有它打开的文件

## 3.6 函数lseek
每个打开文件都维护一个"当前文件偏移量",记录从文件开始处的字节数
默认为0
```cpp
off_t currpos = lseek(fd, 0, SEE_CUR);
// 用于确定打开文件的当前偏移量
```
如果文件描述符指向一个管道 FIFO socket,lseek返回-1
文件偏移量可以大于文件的当前长度,对其下一次写将加长该文件,在文件中构成一个空洞(位于文件中但没有写过的字节都被读为0)
空洞不要求在磁盘上占用存储区

## 3.7 函数read
```cpp
ssize_t read(int fd, void* buf, size_t nbytes);
// 成功则返回读到的字节数
```
实际读到的字节数少于要求的字节数的情况比如:提前读到结尾 终端设备通常一次最多一行 本身就不包含这么多

## 3.8 函数write
```cpp
ssize_t write(int fd, void* buf, size_t nbytes);
// 成功则返回已写的字节数
```

## 3.9 I/O的效率
大多数文件系统采用预读(read ahead):当检测到正进行顺序读取时,系统试图读入比要求更多的数据,假定这些数据很快用到

## 3.10 文件共享
内核使用3种数据结构表示打开文件:
1. 每个进程有一个记录项:打开文件描述符表,持有每个文件描述符对应文件表项的指针
2. 内核为所有文件维护一个文件表,每一项包括
    文件状态标志(读\写\同步\非阻塞) --> 用于指定该文件表项的**任何进程**中的所有描述符,而文件描述符局限于一个进程
    当前文件偏移量
    指向该文件v节点表项的指针
3. 每个打开文件(或设备)都有一个v节点
    v节点:包含文件类型和对此文件进程各种操作函数的指针 此外 还包含该文件的i节点(i node索引节点 --> ***虚拟文件系统***)
    这些信息在打开文件时从磁盘读入内存
    i节点:包含问年所有者 文件长度 指向文件实际数据块在磁盘上所在位置的指针

如果两个独立进程各自打开一个文件,那么这两个进程表项(假设文件描述符分别为3, 4)指向**两个文件表项**(见图),它们指向同一个V节点表项
毕竟每个进程都需要拥有自己对该文件的当前偏移量
但也可能有多个文件描述符指向同一文件表项 --> dup函数 / fork父子进程共享


## 3.11 原子操作
举例:
AB进程对同一文件追加,可能存在这种情况,A先定位(lseek),B定位,写,A再写,A就把B写的内容覆盖了
追加的write操作是先定位到文件尾端,再写,本质上是两个分开的函数调用,应该要合成原子操作
任何要求多于一个函数调用的操作都不是原子操作,因为两个调用之间,内核可能挂起进程
对于以上情况,内核提供原子操作:打开文件时设置O_APPEND标志,这样内核在每次写操作之前,都将进程的当前偏移量设置到结尾,不用每个进程调用lseek

### 3.11.2 函数pread和pwrite
pread 等价于 lseek read
但无法中断定位和读操作 并且 不更新当前文件偏移量

### 3.11.3 创建一个文件
同理 open和creat不是原子操作

## 3.12 函数dup和dup2
用于复制现有的文件描述符
目的是共享同一文件状态标志,以及当前文件偏移量

```c
    dup(fd);
    // 等价于:
    fcntl(fd, F_DUPFD, 0);

    dup2(fd, fd2);
    // 等价于:
    close(fd2); // 若fd2已打开,则先关闭
    fcntl(fd, F_DUPFD, fd2);
    // 但是dup2是原子操作
```


## 3.13 函数sync fsync fdatasync
UNIX内核中有高速缓存 大多磁盘I/O通过缓冲区进行
**延迟写**
向文件写入数据时,内核先将数据复制到缓冲区,然后排入队列,晚点再写入磁盘
当内核需要重用缓冲区来存放其他磁盘块数据时,会把所有延迟写数据块写入磁盘
为了保证磁盘上实际文件系统和缓冲区内容的一致性,提供三个sync函数

### sync
只将所有修改过的块缓冲区排入写队列,然后直接返回,不等待实际磁盘操作结束
通常 名为update的系统守护进程周期性调用(一般每隔30秒)sync,从而保证定期flush内核的块缓冲区

### fsync
只对由fd指定的一个文件起作用,等待写磁盘操作结束才返回
fsync可用于数据库这样的应用程序,确保修改过的块立即写到磁盘

### fdatasync
相比fsync只影响文件的数据部分,而sync还同步更新文件的属性


## 3.14 函数fcntl
改变已打开文件的属性
```c
int fcntl(int fd, int cmd, ...);
// cmd有11个
```
有5个功能:
复制已有的描述符 获取/设置文件描述符标志 获取/设置文件状态标志 获取/设置异步I/O所有权 获取/设置记录锁


## 3.15 函数ioctl
I/O操作的杂物箱


## 3.16 /dev/fd
该目录的目录项时名为0,1,2等的文件
打开文件/dev/fd/n等价于复制描述符n
主要由shell使用






# 第七章 进程环境

## 7.2 main函数
```c
int main(int argc,char *argv[]);
// argc是命令行参数的数目
// atgv是指向各个参数的各个指针构成的数组
```
内核执行C程序时，调用**exec函数**，在调用main前先调用一个特殊的启动例程（是一个特殊的函数，处理一些准备工作），可执行文件将此启动例程指定为程序的起始地址（是由链接器设置的）
启动例程从内核取得命令行参数和环境变量值
（PS：
### 启动例程的操作：
#### 设置堆栈：
启动例程会设置程序的堆栈指针，确保程序能够正确地使用堆栈空间。
#### 初始化运行时库：
启动例程会初始化程序所需的运行时库，例如C语言的标准库。这可能包括初始化全局变量、静态变量和其他运行时数据结构。
#### 获取命令行参数和环境变量：
启动例程会从操作系统获取命令行参数和环境变量的值，并将它们传递给main函数。这样，程序就可以根据需要使用这些参数和变量。
#### 调用main函数：
最后，启动例程会调用程序的main函数，开始程序的正式执行。
）

## 7.3 进程终止
### 正常终止
1. main返回
2. 调用exit
3. 调用_exit或_Exit
4. 最后一个线程从其启动例程返回
5. 从最后一个线程调用pthread_exit

### 异常终止有3种
6. 调用abort
7. 接到一个信号
8. 最后一个线程对取消请求做出响应

```cpp
#include<stdlib.h> // ISO C
void exit(int status); // 会执行一个标准I/O库的清理关闭处理，对所有打开流调用fclose函数（导致输出缓冲中的所有数据都冲洗到文件上），再返回内核
void _Exit(int status);

#include<unistd.h> // POSIX.1
void _exit(int status);
```
三个函数都带一个入参：**终止状态**
只有main返回一个整型并且main执行到最后一条语句时返回（隐式返回），那么这个进程的终止状态是0，要不然进程的终止状态就是未定义的

## 7.4 命令行参数
执行程序时可以将命令行参数传递给程序，这是UNIX shell的常规操作

## 7.5 环境表
```cpp
extern char **environ;
// 该全局变量包含了环境表这一字符指针数组的地址
```
```shell
# 环境字符串
HOME=/home/sar\0
```
大多数UNIX系统支持main函数带三个参数，第三个参数就是环境表地址
而IOS C规定main函数只有两个参数（毕竟第三个参数相比全局environ没好到哪里去，POSIX1也规定使用全局的而不是用第三个入参，通常使用getenv和putenv函数来访问特定的环境变量）


## 7.6 C程序的存储空间布局
C程序的**逻辑布局**一直由以下几部分组成：
（**从低地址到高地址**）
### 正文段
CPU执行的机器指令部分。正文段是可共享的（在存储中只需有一个副本）、只读的

### 初始化数据段
通常称**数据段**，包含了程序中需明确地赋初值的变量，比如C程序中任何函数之外的定义：
```c
int maxcount = 99;
```
此变量按照初值的设定放在初始化数据段中

### 未初始化数据段
通常称**bss段（block started by symbol）**。
在程序开始执行前，内核将此段中的数据初始化为0或空指针
```c
long sum[1000];
```
函数外部未定义的声明

### 堆
通常在堆中进行动态存储分配
由于历史惯例，堆位于未初始化数据段和栈之间

### 栈
自动变量以及每次函数调用时所需保存的信息都存放在栈中。
每次函数调用时，其返回地址以及调用者的环境信息（如某些机器寄存器的值）都存放在栈中。然后，最近被调用的函数在栈上为其自动和临时变量分配存储空间，
（以这种方式使用栈，C递归函数就可以工作。递归函数每次调用自身时，用一个新的栈帧）

（PS：可执行文件中，还有若干其他类型的段，比如：包含符号表的段、包含调试信息的段、包含动态共享库链接表的段，这些部分并不装载到进程执行的程序映像中
而且显然，未初始化数据段的内容不会包含在磁盘程序文件中，毕竟内核在程序开始运行前，未初始化数据段的内容都是设置为0。
真正需要存放在磁盘程序文件中的段只有正文段和初始化数据段。
）

## 7.7 共享库
动态链接的方法使得程序与共享库函数相链接，减少了每个可执行文件的长度，不过增加了运行时间开销（在该程序第一次被执行时，或者每个共享库函数第一次被调用时），还有一个好处就是使用库函数的新版本代替老版本不需要对使用该库的程序重新编译。

## 7.8 存储空间分配
```cpp
// ISO的三个用于存储空间动态分配的函数
#include<stdlib.h>
1. malloc
分配指定字节数的存储区（其中的初始值不确定）
void *malloc(size_t size);

2. calloc
为指定数量、指定长度的对象分配存储空间（空间中的每一位都初始化为0）
void *calloc(size_t nobj, size_t size);

3. realloc
增加或减少以前分配区的长度（初始值不确定）
void *realloc(void* ptr, size_t newsize);
// 常用于增加以前分配的存储区的长度
// 比如原先有个数组长度为512，在运行时填充，发现原存储区不够用，就可以调用该函数扩充响应存储空间而不需移动原先的内容
```
这三个函数返回的指针必然是适当对齐的，使其可用于任何数据对象。
比如，如果系统要求最严苛的对齐要求是：double必须在8的倍数地址单元处开始，那么这三个函数返回的指针都是这样对齐的。



## 7.9 环境变量
POSIX.1定义了一些经典的环境变量，XSI扩展又定义了另一些



# 第八章 进程控制
***关于UNIX系统的进程控制，包括创建新进程、执行程序和进程控制终止***

## 8.2 进程标识
每个进程都有**唯一**标识：**进程ID**。进程ID是可复用的，大多数UNIX系统实用延迟复用算法，避免新进程被误认为是同一ID的某个已终止的进程。
系统中有一些专用进程：
**ID为0的进程**
通常是调度进程，又称为交换进程（swapper），该进程是内核的一部分，并不执行任何磁盘上的程序，也被称为系统进程。
**ID为1的进程**
通常是init进程，在自举过程中由内核调用。该进程的程序文件在早期UNIX版本中是etc/init，在较新版本中是/sbin/init。它负责在自举内核后启动一个UNIX系统。
init通常读取与系统有关的初始化文件（/etc/rc*文件或/etc/inittab文件，以及在/etc/init.d中的文件），并将系统引导到一个状态（比如多用户）
**init进程绝不会终止**，它是一个普通的用户进程（不是像交换进程那样的内核中的系统进程），但是可以以超级用户特权运行，它是所有孤儿进程的父进程。
每个UNIX系统实现都有一套提供操作系统服务的内核进程，某些UNIX的虚拟存储器实现中，进程ID 2是page守护进程，此进程负责支持虚拟存储器系统的分页操作。

## 8.3 函数fork
```cpp
#include<unistd.h>
pid_t fork(void);   // 子进程返回0，父进程返回子进程ID，若出错则返回-1
```
**fork函数被调用一次，却返回两次**
之所以将子进程ID返回给父进程，是因为一个进程的子进程可以有多个，并且没有一个函数使一个进程可以获得其所有子进程的进程ID。
之所以fork使子进程得到返回值0，是因为一个进程只会有一个父进程，所以子进程总是可以用getppid来获得父进程的进程ID（而不可能是0，已经被内核交换进程使用了）
**子进程和父进程继续执行fork调用之后的指令**。子进程可获得父进程数据空间、堆和栈的**副本**，而父子进程真正共享的是正文段。
由于在fork之后经常伴随着exec（因此复制整个空间是不必要的），所以现在的很多实现并不执行一个父进程数据段、栈和堆的完全副本，而是使用**写时复制（Copy On Write）**技术。这些区域由父进程和子进程共享，而且内核将它们的访问权限改变为只读，**如果父进程或者子进程试图修改这些区域，则内核只为修改区域的那块内存制作一个副本，通常是虚拟存储系统中的一个页**
一般来说，在调用fork后，是父进程先执行还是子进程先执行是不确定的，这取决于内核使用的调度算法（可以通过进程间通信来实现父子进程的相互同步）。

**文件共享**
在重定向父进程的标准输出时，子进程的标准输出也被重定向，因为fork的一个特性是父进程的所有打开文件描述符都被复制到子进程中，即：父子进程的每个相同的打开描述符共享一个文件表项。
**父子进程共享一个文件偏移量**


## 8.6 函数wait和waitpid
当一个进程正常或异常终止时，内核就向其父进程发送`SIGCHLD`信号（意味着子进程状态改变）。因为子进程属于异步事件，所以这种由内核发向父进程的通知对于父进程来说也是异步的。
父进程收到该信号时，可以忽略，或者提供对应的信号处理函数。

### 调用wait或waitpid的进程
如果其所有子进程都还在运行，则阻塞
如果一个子进程已终止，正等待父进程获取其终止状态，则取得该子进程的终止状态立即返回
如果没有任何子进程，则立即出错返回
（如果进程由于接收到SIGCHLD信号而调用wait，理论上wait立即返回）
```cpp
#include <sys/wait.h>
// 以下两函数若成功，则返回进程ID，若出错，则返回0或-1
// status是一个指向整型变量的指针，用于存储子进程的终止状态。

pid_t wait(int *statloc);
// 使得调用进程（调用wait的线程）一直阻塞直到有一个子进程终止（具体是哪个子进程终止了，可以通过返回值得知）

pid_t waitpid(pid_t pid, int *statloc, int options);
/*
    waitpid不等待在其调用后的第一个终止子进程
    可通过options控制要等待的进程
*/

```

PS：
**僵尸进程**（Zombie Process）是指一个子进程在终止后，其父进程没有及时调用`wait`或`waitpid`等系统调用来获取子进程的终止状态，导致子进程的进程描述符仍然存在于系统进程表中，但是已经没有运行的代码。僵尸进程不会占用系统资源，但是会占用进程表中的一个位置。
**孤儿进程**（Orphan Process）是指一个父进程在子进程终止之前就已经退出或终止，而子进程还在运行。这种情况下，子进程会被称为孤儿进程。孤儿进程会被init进程（进程ID为1）接管，init进程会成为孤儿进程的新父进程，并负责回收子进程的资源。




# 第九章 进程关系


## 9.8 作业控制
**作业控制**允许在一个终端上启动多个作业（进程组），它控制哪一个作业可访问该终端以及哪些作业在后台运行。
作业控制要求以下三种形式的支持：
1. 支持作业控制的shell
2. 内核中的终端驱动程序必须支持作业控制
3. 内核必须提供对某些作业控制信号的支持






# 第十章 信号
## 10.1 引言
信号是软件中断，信号提供了一种处理异步事件的方法：比如用户在中断键入中断键，就会通过信号机制停止一个程序，或及早终止管道中的下一个程序。
POSIX.1对可靠信号例程做了标准化（UNIX系统的早期版本就已提供信号机制，但是信号模型并不可靠，信号可能丢失）。

## 10.2 信号概念
每个信号都有一个名字，都是以'SIG'开头。
例如：
`SIGABRT`（夭折信号，进程调用abort时产生）、`SIGALRM`（闹钟信号，alarm函数设定的定时器超时后产生）
信号都被定义为正整数常量（定义在内核的头文件，然后在用提供给用户的头文件去包含它）
不存在编号为0的信号，kill函数对信号编号0有特殊应用（又被称为空信号）

### 可以产生信号的条件
1. Ctrl + C，Delete键都可以产生中断信号（`SIGINT`）
2. 硬件异常产生信号：除数为0、无效的内存引用（对应`SIGSEGV`信号）等。通常由硬件检测到这些条件，并通知内核，然后内核根据情况产生适当的信号。
3. 进程调用kill(2)函数可以将任意信号发送给另一个进程或进程组。接收信号进程和发送信号进程的所有者必须相同 / 发送信号进程的所有者必须是超级用户
4. 用户可用kill(1)命令将信号发送给其他进程
 常用于终止一个失控的后台进程
5. 当检测到某种**软件条件**已经发生，并应将其通知有关进程时也产生信号 ，例如`SIGURG`（在网络连接上传来带外的数据），`SIGPIPE`（在管道的读进程已终止后，一个进程写此管道）以及SIGALRM

信号是**异步事件**的经典实例，毕竟产生信号的事件对于进程而言是随机的，进程不能简单地测试一个变量（如error）来判断是否发生了一个信号，而是必须告诉内核：在此信号发生时，请执行以下操作。

### 对信号的处理方法
1. 忽略
    `SIGKILL`和`SIGSTOP`是例外，不可忽略，它们向内核和超级用户提供了使进程终止或停止的可靠方法，如果忽略某些由硬件异常产生的信号（非法内存引用或除数为0），则进程运行行为是未定义

2. 捕捉
    通知内核在某种信号发生时，调用一个用户函数，从而执行用户对这种事件希望进行的处理
    例如：命令解释器程序，当用户键盘产生中断信号时，该命令解释器理论上应该回到主循环，终止当前命令，如果能够捕捉到`SIGCHLD`信号，则表示一个子进程已经终止，那么该信号的捕捉函数就可以调用waitpid以取得该子进程的进程ID以及它的终止状态

SIGKILL和SIGSTOP是例外，不可捕捉

3. 执行系统默认动作
默认动作一般是终止该进程
默认动作如果是终止+core，则意味着在进程当前工作目录的core文件中复制了该进程的内存映像（可以使用core文件检查进程终止时的状态）。


## 10.3 函数signal
```cpp
#include<signal.h>
void (*signal(int signo, void (*func)(int)))(int);
// signo 信号名、func的值是接到此信号后要调用的函数的地址（如果其值为SIG_IGN，则向内核表示忽略此信号；如果其值为SIG_DFL，则表示执行系统默认动作）
```
如果指定函数地址，则调用对应函数，这种处理被称为**信号处理程序**/**信号捕捉函数**
signal函数原型说明该函数要求两个入参，返回值是一个函数指针，它指向的函数返回值是void类型，有一个int入参（它的意义是指向之前的信号处理程序函数）。
```cpp
typedef void Sigfunc(int);
Sigfunc *signal(int, Sigfunc*);
```

kill(1)命令，用于发送一个信号给一个进程或者进程组（是否终止取决于信号的类型，以及进程是否捕捉该信号）
```shell
kill -USR1 7216
# 表示给7216号进程发SIGUSR1信号

kill 7216
# 表示给7216号进程发SIGTERM信号，假设该进程不捕捉SIGTERM信号，而对该信号的系统默认动作是终止，于是进程就终止
```

### 程序启动时
执行程序时，一般所有信号都被设置为默认动作，除非调用exec的进程忽略该信号。`exec函数`将原先设置为要捕捉的信号都更改为默认动作，其他的信号状态不变。
(一个进程原先要捕提的信号，当其执行一个新程序后就不能再捕捉了，因为信号捕捉函数的地址很可能在所执行的新程序文件中已无意义，这是因为当进程执行一个新程序时，它的地址空间会被重新分配，原先注册的信号处理函数的地址可能已经失效，因此进程不能再捕捉原先要捕获的信号。)

（PS：当我们说一个进程执行一个新程序时，意味着该进程正在运行的程序（也称为进程的映像）被替换为另一个程序的映像。这通常是通过调用exec系列函数来实现的，如execve、execvp等。
在UNIX系统中，每个进程都有一个当前运行的程序映像，它包含了程序的代码、数据和其他相关资源。**当进程执行一个新程序时，操作系统会将新程序的映像加载到进程的地址空间中，取代原先的程序映像。**这样，进程就开始执行新程序的代码，并使用新程序的数据和资源。
执行新程序的原因可能是进程需要切换到另一个功能或逻辑，或者是通过调用另一个程序来完成某个任务。例如，一个shell进程可以通过执行用户输入的命令来启动不同的程序，每次执行新的命令时，就会执行一个新的程序。
需要注意的是，当进程执行一个新程序时，它的状态和上下文信息可能会发生变化。例如，进程的打开文件描述符、环境变量、命令行参数等可能会被重置或改变。因此，在执行新程序之前，进程通常会保存必要的状态信息，以便在需要时进行恢复。
总之，当进程执行一个新程序时，它的当前运行的程序映像会被替换为另一个程序的映像，进程开始执行新程序的代码，并使用新程序的数据和资源。**这是进程切换到不同功能或任务的一种常见方式。**）

一个具体例子是：一个交互 shell 如何处理针对后台进程的中断和退出信号。对于一个非作业控制 shell，当在后台执行一个进程时，例如:








# 第十一章 线程
## 11.2 线程概念
### 多线程好处





  





# 第十五章 进程间通信


## 15.6 XSI IPC
3种IPC被称为**XSI IPC**：消息队列、信号量、共享存储，三者有相似之处
（其实现源自于UNIX系统的System V版本，最终在POSIX标准上得以规定）

### 15.6.1 标识符和键
每个内核中的IPC结构（消息队列、信号量、共享内存）都是通过**标识符**（非负整数，相比文件描述符而言，是比较大的整数）来引用
例如，要向一个消息队列发送消息或者从一个消息队列取消息，只需要知道其队列标识符。
当一个IPC结构被创建，然后又被删除时，与这种结构相关的标识符连续加1，这样的操作会1直到达到一个整型数的最大正值，之后再回到0。
标识符时IPC对象的内部名，还需要一个外部名字（称之为key）来使得多个合作进程能够再同一IPC对象上汇聚。
在通过mssget、semget、shmget创建IPC结构时，都应指定一个键（是基本系统数据类型key_t,在<sys/types.h>被定义为长整型），它由内核变换成标识符

#### 使client进程和server进程能够再同一IPC对象上汇聚
1. server指定键**IPC_PRIVATE**（使用IPC_PRIVATE创建的IPC对象, key值属性为0，和IPC对象的编号就没有了对应关系，用于有亲缘关系的进程。可用于父进程子关系，父进程通过它创建的IPC结构返回的标识符可供fork后的子进程使用）创建一个新IPC结构，将返回的标识符放在文件等地以便client进程取用
2. 在一个公用头文件中定义一个client和server都认可的键，然后server通过此键创建一个新的IPC结构（但是该键可能已经和一个IPC结构相结合）
3. client和server进程认同同一个路径名和项目ID（0 ~ 255），然后调用ftok将这两个值变换为一个键，然后使用方法2

### 15.6.2 权限结构
每个XSI IPC结构关联一个ipc_perm结构，规定了权限和所有者。

### 15.6.3 结构限制
三者都有内置限制，但大多可以通过重新配置内核来改变

### 15.6.4 优点和缺点
#### 缺点
1. IPC结构是在系统范围内起作用的，**没有引用计数**
例如：如果进程创建了一个消息队列，并往队列放了几则消息，然后终止，这个消息队列及其内容都不会删除（除非被某个进程删除），如果是管道的话，当最后一个引用管道的进程终止时，管道就会被删除。如果是FIFO（有名管道），当最后一个引用FIFO的进程终止时，虽然FIFO的名字还会保存在系统中，但是其中的数据会被删除。

2. 这些IPC结构在文件系统中没有名字
因而无法使用文件操作（ls、rm、chmod），内核因此增加了十几个全新的系统调用（msgget、semop、shmat）
因为这些IPC不存在文件描述符，所以不能使用多路转换I/O函数（select、poll），因而很难一次使用两个及以上的XSI IPC结构。


#### 优点
可靠（因为范围在一台主机）、流控制的（如果系统资源（缓冲区）短缺，活接收进程不能再接收更多消息，则发送进程休眠，当流控制条件消失时，发送进程自动唤醒）、面向记录的
而UNIX流套接字可以做到：IPC设施能自动地为每个客户进程创建一个到服务器进程的唯一连接




## 15.7 消息队列
本质上是**消息的链表**，存储在内核中，由消息队列的标识符标识
**msgget**用于创建一个新队列或打开一个现有队列，**msgsnd**用于将新消息添加到队列尾端。**msgrcv**用于从队列中取消息。
每个队列都有一个msqid_ds结构与其关联，用于表示队列的当前状态

```cpp
#include<sys/msg.h>
int msgget(key_t key, int flag);    // 创建新队列或者打开现有的。若成功，则返回消息队列ID，若出错，则返回-1
```

## 15.8 信号量
是一个计数器，用于为多个进程提供对共享数据的访问
### 进程为了获得共享资源的经典场景：
1. 测试控制该资源的信号量
2. 若其为正，则进程可以使用该资源，并将信号量值 - 1
3. 否则，若此时信号量值为0，则进程进入休眠状态，直到信号量 > 0，进程被唤醒后，回到（1）
当进程使用完共享资源，信号量 + 1
（其中信号量的测试以及减1操作应当是**原子操作**，它是在内核中实现的）

常用的信号量形式称为**二元信号量**，控制单个资源，初始值为1（可以是任意正值，表示有多少个共享资源单位以供共享使用）
XSI信号量更为复杂，有以下特性：
1. 信号量不是单个非负值，而必须是含有一个或多个信号量值的集合，创建信号量时，要指定集合中的信号量个数
2. 信号量的创建独立于初始化，也就是说不能原子地创建一个信号量集合，并为他们赋初值
3. 进程终止时可能没有释放分配给它的信号量（undo功能用于处理这种情况）



## 15.9 共享存储
数据不用在client、server进程之间复制，速度最快
需要注意多进程访问同一个存储区的同步问题（通常用信号量、记录锁、互斥量控制）


```cpp
int shmget(key_t key,size_t size,int flag);
// 返回一个共享存储标识符
// 若成功则返回共享存储的ID
// size是共享内存段的长度 通常为系统页长的整数倍
```





共享存储区的位置，在栈空间（位于较高地址的位置）之下
高地址首先是命令行参数和环境变量，然后是栈空间、共享存储、堆区、未初始化的数据、已初始化的数据、地址最低的区域是正文
图15-32 在基于Intel的Linux系统上的存储区布局







# 第16章 网络IPC





## 16.2 套接字描述符
```c++
#include<sys/socket.h>
int socket(int domain,int type,int protocol);
// 若成功，则返回文件（套接字）描述符


```



# 第17章 高级进程间通信
## 17.1 引言
UNIX域套接字（Unix Domain Socket），用于IPC通信

## 17.2 UNIX域套接字
相比传统的网络套接字效率更高，UNIX domain socket仅复制数据，并不执行协议处理：添加或删除网络报头、计算校验和、 产生顺序号、发送确认报文等操作
UNIX域套接字提供**流**和**数据报**两种接口，它就像是**套接字和管道的混合**
是**可靠的**、不会丢失报文、也不会出错
一对相互连接的UNIX域套接字可以起到**全双工管道**的作用

```cpp
#include <sys/socket.h>
int socketpair(int domain, int type, int protocol, int sockfd[2]);  // 可用于创建一对无名的、相互连接的UNIX域套接字
```

















