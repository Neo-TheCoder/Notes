
# 第一章 UNIX基础知识
OS为运行的程序提供服务
典型的服务：
执行新程序、打开文件、读文件、分配存储区、获得当前时间

## 1.2 UNIX体系结构
UNIX操作系统的体系结构
**内核**：控制计算机硬件资源，提供程序运行环境
***系统调用***就是内核的接口。

应用程序既可以使用公用函数库，又可以使用系统调用。
shell是特殊的应用程序，为运行其他程序提供接口。

Linux是GNU操作系统使用的内核，因此可以称这种操作系统为GNU/Linux操作系统。


## 1.4 文件和目录
目录是一个包含**目录项**的文件。
每个目录项都包含一个文件名，同时还包含说明该文件属性（是普通文件还是目录、文件大小、所有者、权限、最后修改时间）的信息。


## 1.5 输入和输出
### 1.5.1 文件描述符
小的非负整数，内核用以标识一个特定进程正在访问的文件
当内核打开或创建一个新文件时，都会返回一个文件描述符，读写文件时可用。


### 1.5.2 标准输入、标准输出和标准错误
每当允许一个程序，所有shell都为其打开3个文件描述符：
标准输入、标准输出、标准错误
不做特殊处理则3个描述符都连接向终端
```shell
ls > file.list
# 使得描述符重定向到某个文件
```

### 1.5.3 不带缓冲的I/O函数
open read write lseek close
都会使用文件描述符

### 1.5.4 标准I/O函数
为那些不带缓冲的I/O函数提供一个带缓冲的接口
比如printf


## 1.6 程序和进程
### 1 程序
是一个存储在磁盘上某个目录中的可执行文件、内核使用exec函数，将程序读入内存，并执行程序

### 2 进程和进程ID
程序的执行实例被称为进程(process)，某些OS用任务task表示正在被执行的程序
UNIX系统确保每个进程都有一个唯一的标识符

### 3 进程控制
fork exec waitpid

### 4 线程和线程ID

通常一个进程只有一个控制线程thread――――某一时刻执行的一租机器指令
一个进程内的所有线程共享同一地址空间、文件描述符、栈以及进程相关的属性
线程ID只在所属的进程内起作用

## 1.7 出错处理
整型变量errno记录错误类型
#include<errno.h>
extern int errno;
多线程环境中每个线程都有属于自己的局部errno


## 1.8 用户标识
### 1 用户ID
0标识root用户

### 2 组ID
用户组

### 3 附属组ID



## 1.9 信号
用于通知进程发生了某种情况
例如除数为0，则需要把SIGFPE的信号发给该异常。
进程对异常的处理：
1、忽略
2、默认方式：终止
3、捕捉，处理


## 1.10 时间值
1、日历时间
2、进程时间
    UNIX系统为一个进程维护3个进程时间值
    时钟时间
    用户CPU时间：执行用户指令所用的时间量
    系统CPU时间：为该进程执行内核程序所经历的时间


## 1.11 系统调用和库函数
通用库函数可能调用一个或多个内核的系统调用 并非内核的入口点
例如prinf函数会调用write系统调用以输出一个字符串
malloc调用sbrk

进程控制系统调用fork、exec wait通常直接由用户应用程序直接调用


# 第三章 文件IO
UNIX系统中的大多文件IO只用到:
open、read、write、lseek、close
这些函数都是不带缓冲的I/O(unbuffered I/O),意思是每个read和write都调用内核中的一个系统调用
本章涉及:多个进程间如何共享文件 以及涉及到的内核有关的数据结构

## 3.2 文件描述符
对于内核,所有打开的文件都通过文件描述符引用(一对一的标识打开的文件,用于read,write的参数)
UNIX系统shell把文件描述符0与进程的标准输入关联,即符号常量**STDIN_FILENO** 1--> 标准输出**STDOUT_FILENO**    2--> 标准错误**STDERR_FILENO**
文件描述符的变化范围:0 ~ OPEN_MAX - 1

## 3.3 函数open和openat
```cpp
#include<fcntl.h>
int open(const char* path, int oflag, ...);
int openat(int fd, const char* path, int oflag, ...);   // 用于相对路径
// 成功返回对应文件描述符 失败返回-1
```

***TOCTTOU: time of check to time of use***
如果有两个基于文件的函数调用,第二个依赖第一个的结果,这个程序就是脆弱的 因为两个调用**不是原子操作** 在两个函数调用之间文件可能改变

## 3.4 函数creat
创建新文件

## 3.5 函数close
关闭一个文件会释放该进程加在该文件上的所有记录锁
当一个进程终止,内核自动关闭所有它打开的文件

## 3.6 函数lseek
每个打开文件都维护一个"当前文件偏移量",记录从文件开始处的字节数
默认为0
```cpp
off_t currpos = lseek(fd, 0, SEE_CUR);
// 用于确定打开文件的当前偏移量
```
如果文件描述符指向一个管道 FIFO socket,lseek返回-1
文件偏移量可以大于文件的当前长度,对其下一次写将加长该文件,在文件中构成一个空洞(位于文件中但没有写过的字节都被读为0)
空洞不要求在磁盘上占用存储区

## 3.7 函数read
```cpp
ssize_t read(int fd, void* buf, size_t nbytes);
// 成功则返回读到的字节数
```
实际读到的字节数少于要求的字节数的情况比如:提前读到结尾 终端设备通常一次最多一行 本身就不包含这么多

## 3.8 函数write
```cpp
ssize_t write(int fd, void* buf, size_t nbytes);
// 成功则返回已写的字节数
```

## 3.9 I/O的效率
大多数文件系统采用预读(read ahead):当检测到正进行顺序读取时,系统试图读入比要求更多的数据,假定这些数据很快用到

## 3.10 文件共享
内核使用3种数据结构表示打开文件:
1. 每个进程有一个记录项:打开文件描述符表,持有每个文件描述符对应文件表项的指针
2. 内核为所有文件维护一个文件表,每一项包括
    文件状态标志(读\写\同步\非阻塞) --> 用于指定该文件表项的**任何进程**中的所有描述符,而文件描述符局限于一个进程
    当前文件偏移量
    指向该文件v节点表项的指针
3. 每个打开文件(或设备)都有一个v节点
    v节点:包含文件类型和对此文件进程各种操作函数的指针 此外 还包含该文件的i节点(i node索引节点 --> ***虚拟文件系统***)
    这些信息在打开文件时从磁盘读入内存
    i节点:包含问年所有者 文件长度 指向文件实际数据块在磁盘上所在位置的指针

如果两个独立进程各自打开一个文件,那么这两个进程表项(假设文件描述符分别为3, 4)指向**两个文件表项**(见图),它们指向同一个V节点表项
毕竟每个进程都需要拥有自己对该文件的当前偏移量
但也可能有多个文件描述符指向同一文件表项 --> dup函数 / fork父子进程共享


## 3.11 原子操作
举例:
AB进程对同一文件追加,可能存在这种情况,A先定位(lseek),B定位,写,A再写,A就把B写的内容覆盖了
追加的write操作是先定位到文件尾端,再写,本质上是两个分开的函数调用,应该要合成原子操作
任何要求多于一个函数调用的操作都不是原子操作,因为两个调用之间,内核可能挂起进程
对于以上情况,内核提供原子操作:打开文件时设置O_APPEND标志,这样内核在每次写操作之前,都将进程的当前偏移量设置到结尾,不用每个进程调用lseek

### 3.11.2 函数pread和pwrite
pread 等价于 lseek read
但无法中断定位和读操作 并且 不更新当前文件偏移量

### 3.11.3 创建一个文件
同理 open和creat不是原子操作

## 3.12 函数dup和dup2
用于复制现有的文件描述符
目的是共享同一文件状态标志,以及当前文件偏移量

```c
    dup(fd);
    // 等价于:
    fcntl(fd, F_DUPFD, 0);

    dup2(fd, fd2);
    // 等价于:
    close(fd2); // 若fd2已打开,则先关闭
    fcntl(fd, F_DUPFD, fd2);
    // 但是dup2是原子操作
```


## 3.13 函数sync fsync fdatasync
UNIX内核中有高速缓存 大多磁盘I/O通过缓冲区进行
**延迟写**
向文件写入数据时,内核先将数据复制到缓冲区,然后排入队列,晚点再写入磁盘
当内核需要重用缓冲区来存放其他磁盘块数据时,会把所有延迟写数据块写入磁盘
为了保证磁盘上实际文件系统和缓冲区内容的一致性,提供三个sync函数

### sync
只将所有修改过的块缓冲区排入写队列,然后直接返回,不等待实际磁盘操作结束
通常 名为update的系统守护进程周期性调用(一般每隔30秒)sync,从而保证定期flush内核的块缓冲区

### fsync
只对由fd指定的一个文件起作用,等待写磁盘操作结束才返回
fsync可用于数据库这样的应用程序,确保修改过的块立即写到磁盘

### fdatasync
相比fsync只影响文件的数据部分,而sync还同步更新文件的属性


## 3.14 函数fcntl
改变已打开文件的属性
```c
int fcntl(int fd, int cmd, ...);
// cmd有11个
```
有5个功能:
复制已有的描述符 获取/设置文件描述符标志 获取/设置文件状态标志 获取/设置异步I/O所有权 获取/设置记录锁


## 3.15 函数ioctl
I/O操作的杂物箱


## 3.16 /dev/fd
该目录的目录项时名为0,1,2等的文件
打开文件/dev/fd/n等价于复制描述符n
主要由shell使用






# 第七章 进程环境

## 7.2 main函数
```c
int main(int argc,char *argv[]);
// argc是命令行参数的数目
// atgv是指向各个参数的各个指针构成的数组
```
内核执行C程序时，调用**exec函数**，在调用main前先调用一个特殊的启动例程（是一个特殊的函数，处理一些准备工作），可执行文件将此启动例程指定为程序的起始地址（是由链接器设置的）
启动例程从内核取得命令行参数和环境变量值
（PS：
### 启动例程的操作：
#### 设置堆栈：
启动例程会设置程序的堆栈指针，确保程序能够正确地使用堆栈空间。
#### 初始化运行时库：
启动例程会初始化程序所需的运行时库，例如C语言的标准库。这可能包括初始化全局变量、静态变量和其他运行时数据结构。
#### 获取命令行参数和环境变量：
启动例程会从操作系统获取命令行参数和环境变量的值，并将它们传递给main函数。这样，程序就可以根据需要使用这些参数和变量。
#### 调用main函数：
最后，启动例程会调用程序的main函数，开始程序的正式执行。
）

## 7.3 进程终止
### 正常终止
1. main返回
2. 调用exit
3. 调用_exit或_Exit
4. 最后一个线程从其启动例程返回
5. 从最后一个线程调用pthread_exit

### 异常终止有3种
6. 调用abort
7. 接到一个信号
8. 最后一个线程对取消请求做出响应

```cpp
#include<stdlib.h> // ISO C
void exit(int status); // 会执行一个标准I/O库的清理关闭处理，对所有打开流调用fclose函数（导致输出缓冲中的所有数据都冲洗到文件上），再返回内核
void _Exit(int status);

#include<unistd.h> // POSIX.1
void _exit(int status);
```
三个函数都带一个入参：**终止状态**
只有main返回一个整型并且main执行到最后一条语句时返回（隐式返回），那么这个进程的终止状态是0，要不然进程的终止状态就是未定义的

## 7.4 命令行参数
执行程序时可以将命令行参数传递给程序，这是UNIX shell的常规操作

## 7.5 环境表
```cpp
extern char **environ;
// 该全局变量包含了环境表这一字符指针数组的地址
```

```shell
# 环境字符串
HOME=/home/sar\0
```
大多数UNIX系统支持main函数带三个参数，第三个参数就是环境表地址
而IOS C规定main函数只有两个参数（毕竟第三个参数相比全局environ没好到哪里去，POSIX1也规定使用全局的而不是用第三个入参，通常使用getenv和putenv函数来访问特定的环境变量）


## 7.6 C程序的存储空间布局
C程序的**逻辑布局**一直由以下几部分组成：
（**从低地址到高地址**）
### 正文段
CPU执行的机器指令部分。正文段是可共享的（在存储中只需有一个副本）、只读的

### 初始化数据段
通常称**数据段**，包含了程序中需明确地赋初值的变量，比如C程序中任何函数之外的定义：
```c
int maxcount = 99;
```
此变量按照初值的设定放在初始化数据段中

### 未初始化数据段
通常称**bss段（block started by symbol）**。
在程序开始执行前，内核将此段中的数据初始化为0或空指针
```c
long sum[1000];
```
函数外部未定义的声明

### 堆
通常在堆中进行动态存储分配
由于历史惯例，堆位于未初始化数据段和栈之间

### 栈
自动变量以及每次函数调用时所需保存的信息都存放在栈中。
每次函数调用时，其返回地址以及调用者的环境信息（如某些机器寄存器的值）都存放在栈中。然后，最近被调用的函数在栈上为其自动和临时变量分配存储空间，
（以这种方式使用栈，C递归函数就可以工作。递归函数每次调用自身时，用一个新的栈帧）

（PS：可执行文件中，还有若干其他类型的段，比如：包含符号表的段、包含调试信息的段、包含动态共享库链接表的段，这些部分并不装载到进程执行的程序映像中
而且显然，未初始化数据段的内容不会包含在磁盘程序文件中，毕竟内核在程序开始运行前，未初始化数据段的内容都是设置为0。
真正需要存放在磁盘程序文件中的段只有正文段和初始化数据段。
）

## 7.7 共享库
动态链接的方法使得程序与共享库函数相链接，减少了每个可执行文件的长度，不过增加了运行时间开销（在该程序第一次被执行时，或者每个共享库函数第一次被调用时），还有一个好处就是使用库函数的新版本代替老版本不需要对使用该库的程序重新编译。

## 7.8 存储空间分配
```cpp
// ISO的三个用于存储空间动态分配的函数
#include<stdlib.h>
1. malloc
分配指定字节数的存储区（其中的初始值不确定）
void *malloc(size_t size);

2. calloc
为指定数量、指定长度的对象分配存储空间（空间中的每一位都初始化为0）
void *calloc(size_t nobj, size_t size);

3. realloc
增加或减少以前分配区的长度（初始值不确定）
void *realloc(void* ptr, size_t newsize);
// 常用于增加以前分配的存储区的长度
// 比如原先有个数组长度为512，在运行时填充，发现原存储区不够用，就可以调用该函数扩充响应存储空间而不需移动原先的内容
```
这三个函数返回的指针必然是适当对齐的，使其可用于任何数据对象。
比如，如果系统要求最严苛的对齐要求是：double必须在8的倍数地址单元处开始，那么这三个函数返回的指针都是这样对齐的。



## 7.9 环境变量
POSIX.1定义了一些经典的环境变量，XSI扩展又定义了另一些



# 第八章 进程控制
***关于UNIX系统的进程控制，包括创建新进程、执行程序和进程控制终止***

## 8.2 进程标识
每个进程都有**唯一**标识：**进程ID**。进程ID是可复用的，大多数UNIX系统实用延迟复用算法，避免新进程被误认为是同一ID的某个已终止的进程。
系统中有一些专用进程：
**ID为0的进程**
通常是调度进程，又称为交换进程（swapper），该进程是内核的一部分，并不执行任何磁盘上的程序，也被称为系统进程。
**ID为1的进程**
通常是init进程，在自举过程中由内核调用。该进程的程序文件在早期UNIX版本中是etc/init，在较新版本中是/sbin/init。它负责在自举内核后启动一个UNIX系统。
init通常读取与系统有关的初始化文件（/etc/rc*文件或/etc/inittab文件，以及在/etc/init.d中的文件），并将系统引导到一个状态（比如多用户）
**init进程绝不会终止**，它是一个普通的用户进程（不是像交换进程那样的内核中的系统进程），但是可以以超级用户特权运行，它是所有孤儿进程的父进程。
每个UNIX系统实现都有一套提供操作系统服务的内核进程，某些UNIX的虚拟存储器实现中，进程ID 2是page守护进程，此进程负责支持虚拟存储器系统的分页操作。

## 8.3 函数`fork`
```cpp
#include<unistd.h>
pid_t fork(void);   // 子进程返回0，父进程返回子进程ID，若出错则返回-1
```
**`fork`函数被调用一次，却返回两次**
之所以将子进程ID返回给父进程，是因为一个进程的子进程可以有多个，并且没有一个函数使一个进程可以获得其所有子进程的进程ID。
之所以fork使子进程得到返回值0，是因为一个进程只会有一个父进程，所以子进程总是可以用`getppid`来获得父进程的进程ID（而不可能是0，已经被内核交换进程使用了）

**子进程和父进程继续执行fork调用之后的指令**。子进程可获得父进程数据空间、堆和栈的**副本**，而父子进程真正共享的是**正文段**。
由于在fork之后经常伴随着`exec`（因此复制整个空间是不必要的，新程序会替换原来的程序，完全的复制是没必要的），所以现在的很多实现并不执行一个父进程数据段、栈和堆的完全副本，而是使用**写时复制（Copy On Write）**技术。这些区域由父进程和子进程共享，而且内核将它们的访问权限改变为只读，**如果父进程或者子进程试图修改这些区域，则内核只为修改区域的那块内存制作一个副本，通常是虚拟存储系统中的一个页**（也就是有必要的情况下才执行拷贝）

一般来说，在调用`fork`后，是父进程先执行还是子进程先执行是不确定的，这取决于内核使用的调度算法（可以通过进程间通信来实现父子进程的相互同步）。

**文件共享**
在重定向父进程的标准输出时，子进程的标准输出也被重定向，因为fork的一个特性是父进程的所有打开文件描述符都被复制到子进程中，即：父子进程的每个相同的打开描述符共享一个文件表项。
**父子进程共享一个文件偏移量**

### 使`fork`失败的原因
1. 系统中进程过多
2. 该实际用户ID的进程总数超过了系统限制（`CHILD_MAX`规定了每个实际用户ID在任一时刻可拥有的最大进程数）

### `fork`有两种用法
1. 一个父进程希望复制自己，使得父子进程同时执行不同的代码段
常用于网络服务进程：父进程等待客户端的服务请求，当请求到达，父进程调用fork，使子进程处理此请求，而父进程继续等待下一个服务请求

2. 一个进程要执行一个不同的程序
shell就是如此，子进程从`fork`返回后立刻调用`exec`（某些操作系统将这种`fork`之后立马执行`exec`组合成一个操作：`spawn`，而UNIX系统将二者分开，因为很多时候要单独使用fork，并且还能使得子进程在`fork`和`exec`之间可以更改自己的属性：比如I/O重定向、用户ID、信号安排等）



## 8.4 函数vfork
`vfork`会创建一个新进程，该新进程的目的是`exec`一个新程序（shell的基本部分就是利用它）
### 相比`fork`，`vfork`的区别

#### 创建的子进程不会将父进程的地址空间完全复制到子进程中
因为子进程会立即调用`exec`（或`exit`），也就不会引用到该地址空间。在子进程调用`exec`或`exit`之前，**它在父进程的空间中运行**（这种优化使得在某些UNIX系统中提高了效率）。
但如果子进程修改数据（除了用于存放`vfork`返回值的变量）、进行函数调用、或者没有调用`exec`或`exit`就返回，则会导致未知结果。
写时复制技术可以提高`fork`之后跟随`exec`操作的效率，而直接不复制数据，在父进程的空间运行自然是更快。

#### vfork保证子进程先运行
在调用`exec`或`exit`之后父进程才可能被调度运行（内核使得父进程处于休眠状态），当子进程调用这两个函数中的任意一个时，父进程会恢复运行。
如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。

PS：`_exit`相比`exit`不执行标准I/O缓冲区的`flush`。大多数`exit`的现代实现都不去管流的关闭了，因为进程即将终止时，自有内核去关闭在进程中已经打开的文件描述符，没必要在库中去写关闭流的逻辑了。



## 8.5 函数exit
### 进程5种正常终止
1. `main`函数内执行`return`，等效于调用`exit`

2. 调用`exit`函数（由ISO C定义），包含如下操作：
    调用各种终止处理程序（这些程序在调用atexit函数时登记）、关闭所有标准I/O流
    而ISO C并不处理文件描述符、多进程以及作业控制，所以这一定义对于UNIX系统是不完整的

3. 调用_exit或_Exit函数，ISO C定义_Exit目的是为进程提供一种无需运行终止处理程序或信号处理程序而终止的办法
    在UNIX系统中，_exit和_Exit是同义的（不做清理操作），不冲洗标准I/O流，`_exit`由`exit`调用，处理UNIX系统特定的细节，`_exit`是由POSIX.1说明的。
    大多数UNIX系统中，`exit(3)`是标准C库中的一个函数（包含清理操作），而`_exit(2)`是一个系统调用

4. 进程的最后一个线程在其启动例程中执行return。而该线程的返回值不用作进程的返回值，当最后一个线程从其启动例程返回时，该进程以终止状态0返回。

5. 进程的最后一个线程调用pthread_exit函数。进程终止状态为0.

### 进程3种异常终止
1. 调用abort，产生SIGABRT信号，是2的特例

2. 当进程接收到某些信号时。信号可由**进程自身、其他进程或内核产生**
    比如进程如果引用地址空间之外的存储单元、或者除以0，内核就会为进程产生相应的信号

3. 最后一个线程对“取消”请求作出相应。
    默认情况下，“取消”以延迟方式发生，一个线程要求取消另一个线程，若干时间后，目标线程终止。

**不管进程如何终止，最后都会执行内核中的同一段代码：为相应进程关闭所有打开的描述符，释放所使用的存储器**

对于以上任意的终止情形，需要有机制实现终止进程通知其父进程它是如何终止的。
对于三大终止函数（exit、_exit、_Exit），实现方式是：将`退出状态`作为参数传递给函数
而异常终止情况下，内核产生一个指示其异常终止原因的`终止状态`，而终止进程的父进程都能用`wait`或`waitpid`取得终止子进程的`终止状态`
PS：在进程最后调用`_exit`时，内核将`退出状态`转换成`终止状态`。这里的`退出状态`指的是进程调用`_exit`时传递给内核的`退出状态参数`。
而`终止状态`是内核中用于表示进程终止原因的一种状态。
然后，内核会将进程的状态从"运行"状态转换为"终止"状态。这个终止状态包含了进程的退出状态参数以及其他一些信息，例如进程的终止原因（正常退出、异常终止等）。
**终止状态的保存和传递对于父进程来说是很重要的**。父进程可以通过调用`wait`或`waitpid`系统调用来等待子进程的终止，并获取子进程的终止状态。这样，父进程就可以根据子进程的终止状态来判断子进程的执行结果或处理其他相关的操作。

如果父进程在子进程之前终止，则子进程的父进程改变为init进程（或者说被init进程收养）。操作过程大致是：在一个进程终止时，内核逐个检查所有活动进程，以判断它是否是正要终止进程的子进程，如果是，则该进程的父进程ID更改为1（init进程），保证每个子进程都有一个父进程。

#### 如果子进程在父进程之前终止，父进程如何在检查时得到子进程的终止状态呢？
若子进程完全消失，则进程在准备好检查子进程是否终止时是无法获取终止状态的。
内核为每个终止子进程保存了一些信息（比如：进程ID、终止状态、该进程使用的CPU时间总量），所以当父进程调用`wait()`、或者`waitpid()`时，可以得到这些信息
内核可以释放终止进程所使用的所有存储区、关闭所有打开文件
在UNIX中，一个已经终止，但是其父进程尚未对其进行善后处理（获取终止子进程的有关信息、释放它仍然占用的资源）的进程被称为僵尸进程（zombie~）。ps(1)命令将僵尸进程的状态打印为Z。
如果编写一个长期运行的程序，fork了很多子进程，除非进程等待取得子进程的**终止状态**，这些子进程终止后都会变成僵尸进程。

PS：
**僵尸进程**（Zombie Process）是指一个子进程在终止后，其父进程没有及时调用`wait`或`waitpid`等系统调用来获取子进程的终止状态，**导致子进程的进程描述符仍然存在于系统进程表中，但是已经没有运行的代码。僵尸进程不会占用系统资源，但是会占用进程表中的一个位置**。
**孤儿进程**（Orphan Process）是指一个父进程在子进程终止之前就已经退出或终止，而子进程还在运行。这种情况下，子进程会被称为孤儿进程。孤儿进程会被init进程（进程ID为1）接管，init进程会成为孤儿进程的新父进程，并负责回收子进程的资源。


#### 一个由init抚养的进程终止时会怎样？
init被编写成：无论何时只要有一个子进程终止，inir就会调用一个`wait`取得其终止状态，避免系统中塞满了僵尸进程。



## 8.6 函数wait和waitpid
当一个进程正常或异常终止时，内核就向其父进程发送`SIGCHLD`信号（意味着子进程状态改变）。因为**子进程的终止属于异步事件**，所以这种由内核发向父进程的通知对于父进程来说也是异步的。
父进程收到该信号时，可以忽略，或者提供对应的信号处理函数。

### 调用wait或waitpid的进程
1. 如果其所有子进程都还在运行，则阻塞
2. 如果一个子进程已终止，正等待父进程获取其`终止状态`，则取得该子进程的终止状态立即返回
3. 如果没有任何子进程，则立即出错返回
（如果进程由于接收到`SIGCHLD`信号而调用wait，希望wait立即返回，只不过实际情况难以预测，进程可能阻塞）

```cpp
#include <sys/wait.h>
// 以下两函数若成功，则返回进程ID，若出错，则返回0或-1
// status是一个指向整型变量的指针，用于存储子进程的终止状态。

pid_t wait(int *statloc);
// 使得调用进程（调用wait的线程）一直阻塞直到有一个子进程终止（具体是哪个子进程终止了，可以通过返回值得知）

pid_t waitpid(pid_t pid, int *statloc, int options);
/*
    waitpid不等待在其调用后的第一个终止子进程
    可通过options控制要等待的进程
*/
```
以上两函数返回的整型状态字是由实现定义的（**某些位表示退出状态（正常返回），其他位表示信号编号（异常返回），有一位指示是否产生core文件**）
POSIX.1规定，终止状态用定义在`<sys/wait.h>`中的宏来查看
有四个互斥的宏可用于取得进程终止原因：
`WIFEXITED`
    若正常终止子进程返回的状态，则为真
    可执行WEXITSTATUS，获取子进程传送给exit或_exit参数的低8位
`WIFSIGNALED`
    若为异常终止子进程返回的状态，则为真
    可执行WTERMSIG，获取使子进程终止的信号编号
`WIFSTOPPED`
    若为当前暂停子进程返回的状态，则为真
    可执行WSTOPSIG，获取使子进程暂停的信号编号
`WIFCONTINUED`
    若在作业控制暂停后已经继续的子进程返回可状态，则为真


#### 双重fork
在双重fork()的过程中，父进程首先调用一次`fork()`，创建一个子进程。然后，子进程再调用一次`fork()`，创建一个孙子进程。此时，子进程退出，孙子进程成为一个孤儿进程，即它的父进程已经退出，它被init进程接管。
孙子进程不再与父进程有任何关联，它可以独立运行，不受父进程的影响。这在一些特殊的场景下非常有用，比如在创建守护进程时，需要让子进程成为孤儿进程，以避免父进程在后续操作中对它的影响。
需要注意的是，双重fork()的过程中，每次调用fork()都会创建一个新的进程，因此需要注意进程的资源消耗和管理。同时，孙子进程需要自己处理一些父进程通常会处理的任务，比如打开文件、设置信号处理等。

## 8.7 函数waitid
```cpp
#include <sys/wait.h>
int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options)；
// 成功返回0，失败返回-1
```

## 8.9 竞争条件



## 8.10 函数exec
调用`fork`函数创建新的子进程后，子进程往往要调用`exec`函数以执行另一个程序
当进程调用一种（共有7种）`exec`函数时（而不创建新进程，所以进程ID不会改变），该进程执行的程序完全替换为新程序，从main函数开始执行
**`exec`只是用磁盘上的一个新程序替换了当前进程的正文段、数据段、堆段、栈段**
**所有的`exec`函数使得UNIX系统进程控制原语更加完善，用`fork`可以创建新进程，用`exec`可以执行新的程序，`exit`和`wait`函数处理终止和等待终止，这些就是必需的基本进程控制原语**

```cpp
#include<unistd.h>
int execl(const char* pathname, const char* arg0, ...); // 路径名 并且命令行参数一个个地传递
...
int execlp(const char* filename, const char* arg0, ...);    // 文件名
/*
若包含/，则视为路径名，否则就按照PATH环境变量，在所指定的各目录种搜寻可执行文件
若找到一个可执行文件，但不是由链接编辑器产生的机器可执行文件，则认为该文件是一个shell脚本，尝试调用/bin/sh，将该filename作为shell的输入
*/

int execve(const char* pathname, char *const argv[], char *const envp[]);   // 是内核的系统调用，另外6个最终都会调用它

int fexecve(int fd, char *const argv[], char* const envp[]);    // 文件描述符 接收命令行参数数组
/*
 依赖调用进程来完成寻找可执行文件的操作，调用进程可使用文件描述符验证所需的文件，并无竞争地执行该文件（要不然拥有特权的恶意用户就可以在找到文件位置并验证之后，但在调用进程执行该文件之前替换可执行文件）
本质上是使用/proc把文件描述符参数转换成路径名
*/


// 以上函数成功不返回，失败返回-1
```
PS：
`/proc`是一个特殊的虚拟文件系统，它在Linux系统中扮演着重要的角色。它提供了一种访问和操作内核数据结构的接口，以及获取系统和进程信息的途径。
在`/proc`文件系统中，每个运行的进程都有一个对应的目录，以进程ID（PID）命名。例如，进程ID为123的进程将在`/proc/123`目录下有一个对应的目录。这些目录中包含了与该进程相关的信息，如进程状态、命令行参数、打开的文件、内存映射、网络状态等。
除了进程目录外，`/proc`文件系统还包含了其他一些特殊的文件和目录，用于提供系统级别的信息。例如：
- `/proc/cpuinfo`：包含有关CPU的信息。
- `/proc/meminfo`：包含有关内存的信息。
- `/proc/filesystems`：列出当前支持的文件系统。
- `/proc/sys`：包含一些系统参数和配置项。
通过读取和解析`/proc`文件系统中的文件，可以获取有关系统和进程的各种信息，这对于系统监控、性能分析、调试和诊断非常有用。
需要注意的是，`/proc`文件系统中的文件和目录并不是实际的磁盘上的文件，而是内核在运行时动态生成的。因此，对`/proc`文件系统的读取和操作实际上是在与内核进行交互。


`PATH`变量包含了一张目录表（称为路径前缀，目录之间用冒号隔开）：
```shell
PATH=/bin:/usr/bin:/usr/local/bin:.
# 最后的.表示当前目录
```
以e结尾的exec函数接收环境变量表，其余函数调用进程中的environ变量为新程序复制现有的环境
通常，一个进程允许将其环境传播给其子进程，有时进程想为子进程指定某一个确定的环境：例如初始化一个新登录的shell时，login程序通常创建一个只定义少数几个变量的特殊环境，可以设置一个shell启动文件

执行`exec`后，新程序继承了一些属性（进程ID、父进程ID、实际用户ID、进程组、工作目录、根目录、文件锁等）



## 8.11 更改用户ID和更改组ID




## 8.16 进程调度






# 第九章 进程关系


## 9.8 作业控制
PS：
在UNIX系统中，作业（**即进程组**）是指在一个shell会话中由一个或多个进程组成的一组任务。一个作业可以由一个或多个进程组成，这些进程可以是前台进程或后台进程。
前台进程是指当前正在运行的进程，它会占用终端并接收用户输入。当一个作业中有多个前台进程时，它们共享同一个终端。
后台进程是指在后台运行的进程，它不会占用终端并且不会接收用户输入。当一个作业中有多个后台进程时，它们可以并行运行。
在UNIX系统中，可以使用作业控制命令来管理作业。常用的作业控制命令包括：
- jobs：列出当前会话中的所有作业。
- fg：将一个作业中的前台进程切换到前台运行。
- bg：将一个作业中的后台进程切换到后台运行。
- Ctrl-Z：将一个作业中的前台进程挂起，并将其切换到后台运行。
作业控制命令可以帮助用户管理多个进程的运行，提高工作效率。

**作业控制**允许在一个终端上启动多个作业（进程组），它控制哪一个作业可访问该终端以及哪些作业在后台运行。
作业控制要求以下三种形式的支持：
1. 支持作业控制的shell
2. 内核中的终端驱动程序必须支持作业控制
3. 内核必须提供对某些作业控制信号的支持






# 第十章 信号
## 10.1 引言
信号是软件中断，信号提供了一种处理异步事件的方法：比如用户在中断键入中断键，就会通过信号机制停止一个程序，或及早终止管道中的下一个程序。
POSIX.1对可靠信号例程做了标准化（UNIX系统的早期版本就已提供信号机制，但是信号模型并不可靠，信号可能丢失）。

## 10.2 信号概念
每个信号都有一个名字，都是以'SIG'开头。
例如：
`SIGABRT`（夭折信号，进程调用abort时产生）、`SIGALRM`（闹钟信号，alarm函数设定的定时器超时后产生）
信号都被定义为正整数常量（定义在内核的头文件，然后在用提供给用户的头文件去包含它）
不存在编号为0的信号，kill函数对信号编号0有特殊应用（又被称为空信号）

### 可以产生信号的条件
1. Ctrl + C，Delete键都可以产生中断信号（`SIGINT`）
2. 硬件异常产生信号：除数为0、无效的内存引用（对应`SIGSEGV`信号）等。通常由硬件检测到这些条件，并通知内核，然后内核根据情况产生适当的信号。
3. 进程调用kill(2)函数可以将任意信号发送给另一个进程或进程组。接收信号进程和发送信号进程的所有者必须相同 / 发送信号进程的所有者必须是超级用户
4. 用户可用kill(1)命令将信号发送给其他进程
 常用于终止一个失控的后台进程
5. 当检测到某种**软件条件**已经发生，并应将其通知有关进程时也产生信号 ，例如`SIGURG`（在网络连接上传来带外的数据），`SIGPIPE`（在管道的读进程已终止后，一个进程写此管道）以及SIGALRM

信号是**异步事件**的经典实例，毕竟产生信号的事件对于进程而言是随机的，进程不能简单地测试一个变量（如error）来判断是否发生了一个信号，而是必须告诉内核：在此信号发生时，请执行以下操作。

### 对信号的处理方法
1. 忽略
    `SIGKILL`和`SIGSTOP`是例外，不可忽略，它们向内核和超级用户提供了使进程终止或停止的可靠方法，如果忽略某些由硬件异常产生的信号（非法内存引用或除数为0），则进程运行行为是未定义

2. 捕捉
    通知内核在某种信号发生时，调用一个用户函数，从而执行用户对这种事件希望进行的处理
    例如：命令解释器程序，当用户键盘产生中断信号时，该命令解释器理论上应该回到主循环，终止当前命令，如果能够捕捉到`SIGCHLD`信号，则表示一个子进程已经终止，那么该信号的捕捉函数就可以调用waitpid以取得该子进程的进程ID以及它的终止状态

SIGKILL和SIGSTOP是例外，不可捕捉

3. 执行系统默认动作
默认动作一般是终止该进程
默认动作如果是终止+core，则意味着在进程当前工作目录的core文件中复制了该进程的内存映像（可以使用core文件检查进程终止时的状态）。


## 10.3 函数signal
```cpp
#include<signal.h>
void (*signal(int signo, void (*func)(int)))(int);
// signo 信号名、func的值是接到此信号后要调用的函数的地址（如果其值为SIG_IGN，则向内核表示忽略此信号；如果其值为SIG_DFL，则表示执行系统默认动作）
```
如果指定函数地址，则调用对应函数，这种处理被称为**信号处理程序**/**信号捕捉函数**
signal函数原型说明该函数要求两个入参，返回值是一个函数指针，它指向的函数返回值是void类型，有一个int入参（它的意义是指向之前的信号处理程序函数）。
```cpp
typedef void Sigfunc(int);
Sigfunc *signal(int, Sigfunc*);
```

kill(1)命令，用于发送一个信号给一个进程或者进程组（是否终止取决于信号的类型，以及进程是否捕捉该信号）
```shell
kill -USR1 7216
# 表示给7216号进程发SIGUSR1信号

kill 7216
# 表示给7216号进程发SIGTERM信号，假设该进程不捕捉SIGTERM信号，而对该信号的系统默认动作是终止，于是进程就终止
```

### 程序启动时
执行程序时，一般所有信号都被设置为默认动作，除非调用exec的进程忽略该信号。`exec函数`将原先设置为要捕捉的信号都更改为默认动作，其他的信号状态不变。
(一个进程原先要捕提的信号，当其执行一个新程序后就不能再捕捉了，因为信号捕捉函数的地址很可能在所执行的新程序文件中已无意义，这是因为当进程执行一个新程序时，它的地址空间会被重新分配，原先注册的信号处理函数的地址可能已经失效，因此进程不能再捕捉原先要捕获的信号。)

（PS：当我们说一个进程执行一个新程序时，意味着该进程正在运行的程序（也称为进程的映像）被替换为另一个程序的映像。这通常是通过调用exec系列函数来实现的，如execve、execvp等。
在UNIX系统中，每个进程都有一个当前运行的程序映像，它包含了程序的代码、数据和其他相关资源。**当进程执行一个新程序时，操作系统会将新程序的映像加载到进程的地址空间中，取代原先的程序映像。**这样，进程就开始执行新程序的代码，并使用新程序的数据和资源。
执行新程序的原因可能是进程需要切换到另一个功能或逻辑，或者是通过调用另一个程序来完成某个任务。例如，一个shell进程可以通过执行用户输入的命令来启动不同的程序，每次执行新的命令时，就会执行一个新的程序。
需要注意的是，当进程执行一个新程序时，它的状态和上下文信息可能会发生变化。例如，进程的打开文件描述符、环境变量、命令行参数等可能会被重置或改变。因此，在执行新程序之前，进程通常会保存必要的状态信息，以便在需要时进行恢复。
总之，当进程执行一个新程序时，它的当前运行的程序映像会被替换为另一个程序的映像，进程开始执行新程序的代码，并使用新程序的数据和资源。**这是进程切换到不同功能或任务的一种常见方式。**）

一个具体例子是：一个交互 shell 如何处理针对后台进程的中断和退出信号。对于一个非作业控制 shell，当在后台执行一个进程时，例如:








# 第十一章 线程
## 11.2 线程概念
### 多线程好处
1. 为每种事件类型分配单独的处理线程，可以简化异步事件的代码，每个线程在进行事件处理时可采用同步编程模式
2. 多进程必须使用OS提供的复杂机制才能实现内存和文件描述符的共享，而多线程自动可以访问相同的存储地址空间和文件描述符
3. 有些问题分解后可以提高整个程序的吞吐量，单线程进程要处理多任务必须把任务串行化，而多线程时，相互独立的任务可以交叉运行
4. 交互的程序可以使用多线程来改善响应时间，多线程可以把业务逻辑区分

即便是单处理器，多线程编程模型也是有益的，不管处理器数量，程序都可以使用线程来简化，而且多线程可以实现部分地阻塞，改善响应时间和吞吐量

### 每个线程执行环境必需的信息
**线程ID、一组寄存器值、栈、调度优先级、策略、信号屏蔽字、errno变量、线程私有数据**
**一个进程的所有信息对该进程的所有线程都是共享的，包括可执行程序的代码、程序的全局内存和堆内存、栈以及文件描述符。**


## 11.3 线程标识
线程ID只有**在所属的进程上下文中才有意义**
```cpp
#include<pthread.h>
int pthread_equal(pthread_t tid1, pthread_t tid2);
// 线程ID是用pthread_t来表示的，不像进程ID是个非负整数
```

## 11.4 线程创建
传统UNIX进程模型中，每个进程只有一个控制线程
```cpp
#include<pthread.h>
int pthread_create(pthread_t *restrict tidp, const pthread_attr_t *restrict attr, void *(*start_rtn)(void*), void *restrict arg);
/*
    当pthread_create成功返回，新创建线程的线程ID会被设置成tidp指向的内存单元
    attr参数用于指定线程属性
    start_rtn是函数指针，表示传递给新线程的入口函数
    arg是传递给新线程入口函数的参数
*/
```
线程创建时不保证哪个线程会先运行，新线程会继承调用线程的浮点环境和信号屏蔽字，清除挂起信号集
pthread调用失败时返回错误码，而不像其他POSIX函数一样设置errno，每个线程提供errno的副本，对于线程而言，从函数中返回错误码更为清洗整洁，这样可以不依赖随着函数执行而不断变化的全局状态，从而把错误范围限制在引起出错的函数中


## 11.5 线程终止
如果进程中的任意线程调用了exit、_Exit或_exit，那么整个进程就会终止。类似地，如果默认动作是终止进程，那么发送到线程的信号就会终止整个进程

### 线程的三种退出方式（不终止整个进程）
1. 简单地从启动例程中返回，返回值是线程的退出码
2. 被同一进程中的其他线程取消
3. 线程调用`pthread_exit`
```cpp
#include<pthread.h>
void pthread_exit(void *rval_ptr);
// rval_ptr可传递参数
```

```cpp
#include<pthread.h>
int pthread_join(pthread_t thread, void **rval_ptr);
// 使得调用线程一直阻塞，直到指定线程调用pthread_exit、从启动例程中返回或被取消
// 如果线程简单地从启动例程中返回，rval_ptr就包含返回码，该函数可用于获得入参线程的退出状态
```
注意：以上无参类型指针rval_ptr可以传递的值不止一个，**可以传递复杂的结构体信息（前提是是其内存在调用者完成调用后仍然有效）**
例如：如果在调用线程的栈上分配了那么一个结构，那么其他的线程在使用这个结构时内存内容可能已经改变了。
又如，线程在自己的栈上分配了一个结构，然后把指向这个结构的指针传给pthread_exit（让其返回出去），那么调用pthread_join的线程试图使用该结构时，这个栈有可能已经被撤销，这块内存也已另作他用。

```cpp
#include<pthread.h>
int pthread_cancel(pthread_t tid);
// 线程调用该函数可以请求取消同一进程中的其他线程，该函数不等待线程终止，仅仅提出请求
```
线程可以安排它退出时需要调用的函数（常常被称为线程清理处理程序，thread cleanup handler）
一个线程可以建立多个清理处理程序，处理程序记录在栈中，也就是说，它们的执行顺序与注册顺序**相反**
```cpp
#include<pthread.h>
void pthread_cleanup_push(void(*rtn)(void*), void *arg);
void pthread_cleanup_pop(int execute);
```
对于以下操作，清理函数rtn是由`pthread_cleanup_push函数`调度的，调用时只有一个参数arg：
1. 调用`pthread_exit`时
2. 响应取消请求时
3. 用非零execute参数调用`pthread_cleanup_pop`时
    如果executr参数设置为0，清理函数将不被调用



## 11.6 线程同步
当多个控制线程共享相同的内存时，需要确保每个线程看到的数据一致。若临界资源不会被其他线程读取和修改，自然就不存在一致性问题。
**但若一个线程可以修改的变量，其他线程也可以读取或修改时，就需要线程同步，确保多线程访问变量的存储内容时不会访问到无效的值**





# 第十五章 进程间通信


## 15.6 XSI IPC
3种IPC被称为**XSI IPC**：消息队列、信号量、共享存储，三者有相似之处
（其实现源自于UNIX系统的System V版本，最终在POSIX标准上得以规定）

### 15.6.1 标识符和键
每个内核中的IPC结构（消息队列、信号量、共享内存）都是通过**标识符**（非负整数，相比文件描述符而言，是比较大的整数）来引用
例如，要向一个消息队列发送消息或者从一个消息队列取消息，只需要知道其队列标识符。
当一个IPC结构被创建，然后又被删除时，与这种结构相关的标识符连续加1，这样的操作会1直到达到一个整型数的最大正值，之后再回到0。
标识符时IPC对象的内部名，还需要一个外部名字（称之为key）来使得多个合作进程能够再同一IPC对象上汇聚。
在通过mssget、semget、shmget创建IPC结构时，都应指定一个键（是基本系统数据类型key_t,在<sys/types.h>被定义为长整型），它由内核变换成标识符

#### 使client进程和server进程能够再同一IPC对象上汇聚
1. server指定键**IPC_PRIVATE**（使用IPC_PRIVATE创建的IPC对象, key值属性为0，和IPC对象的编号就没有了对应关系，用于有亲缘关系的进程。可用于父进程子关系，父进程通过它创建的IPC结构返回的标识符可供fork后的子进程使用）创建一个新IPC结构，将返回的标识符放在文件等地以便client进程取用
2. 在一个公用头文件中定义一个client和server都认可的键，然后server通过此键创建一个新的IPC结构（但是该键可能已经和一个IPC结构相结合）
3. client和server进程认同同一个路径名和项目ID（0 ~ 255），然后调用ftok将这两个值变换为一个键，然后使用方法2

### 15.6.2 权限结构
每个XSI IPC结构关联一个ipc_perm结构，规定了权限和所有者。

### 15.6.3 结构限制
三者都有内置限制，但大多可以通过重新配置内核来改变

### 15.6.4 优点和缺点
#### 缺点
1. IPC结构是在系统范围内起作用的，**没有引用计数**
例如：如果进程创建了一个消息队列，并往队列放了几则消息，然后终止，这个消息队列及其内容都不会删除（除非被某个进程删除），如果是管道的话，当最后一个引用管道的进程终止时，管道就会被删除。如果是FIFO（有名管道），当最后一个引用FIFO的进程终止时，虽然FIFO的名字还会保存在系统中，但是其中的数据会被删除。

2. 这些IPC结构在文件系统中没有名字
因而无法使用文件操作（ls、rm、chmod），内核因此增加了十几个全新的系统调用（msgget、semop、shmat）
因为这些IPC不存在文件描述符，所以不能使用多路转换I/O函数（select、poll），因而很难一次使用两个及以上的XSI IPC结构。


#### 优点
可靠（因为范围在一台主机）、流控制的（如果系统资源（缓冲区）短缺，活接收进程不能再接收更多消息，则发送进程休眠，当流控制条件消失时，发送进程自动唤醒）、面向记录的
而UNIX流套接字可以做到：IPC设施能自动地为每个客户进程创建一个到服务器进程的唯一连接




## 15.7 消息队列
本质上是**消息的链表**，存储在内核中，由消息队列的标识符标识
**msgget**用于创建一个新队列或打开一个现有队列，**msgsnd**用于将新消息添加到队列尾端。**msgrcv**用于从队列中取消息。
每个队列都有一个msqid_ds结构与其关联，用于表示队列的当前状态

```cpp
#include<sys/msg.h>
int msgget(key_t key, int flag);    // 创建新队列或者打开现有的。若成功，则返回消息队列ID，若出错，则返回-1
```

## 15.8 信号量
是一个计数器，用于为多个进程提供对共享数据的访问
### 进程为了获得共享资源的经典场景：
1. 测试控制该资源的信号量
2. 若其为正，则进程可以使用该资源，并将信号量值 - 1
3. 否则，若此时信号量值为0，则进程进入休眠状态，直到信号量 > 0，进程被唤醒后，回到（1）
当进程使用完共享资源，信号量 + 1
（其中信号量的测试以及减1操作应当是**原子操作**，它是在内核中实现的）

常用的信号量形式称为**二元信号量**，控制单个资源，初始值为1（可以是任意正值，表示有多少个共享资源单位以供共享使用）
XSI信号量更为复杂，有以下特性：
1. 信号量不是单个非负值，而必须是含有一个或多个信号量值的集合，创建信号量时，要指定集合中的信号量个数
2. 信号量的创建独立于初始化，也就是说不能原子地创建一个信号量集合，并为他们赋初值
3. 进程终止时可能没有释放分配给它的信号量（undo功能用于处理这种情况）



## 15.9 共享存储
数据不用在client、server进程之间复制，速度最快
需要注意多进程访问同一个存储区的同步问题（通常用信号量、记录锁、互斥量控制）


```cpp
int shmget(key_t key,size_t size,int flag);
// 返回一个共享存储标识符
// 若成功则返回共享存储的ID
// size是共享内存段的长度 通常为系统页长的整数倍
```





共享存储区的位置，在栈空间（位于较高地址的位置）之下
高地址首先是命令行参数和环境变量，然后是栈空间、共享存储、堆区、未初始化的数据、已初始化的数据、地址最低的区域是正文
图15-32 在基于Intel的Linux系统上的存储区布局







# 第16章 网络IPC





## 16.2 套接字描述符
```c++
#include<sys/socket.h>
int socket(int domain,int type,int protocol);
// 若成功，则返回文件（套接字）描述符


```



# 第17章 高级进程间通信
## 17.1 引言
UNIX域套接字（Unix Domain Socket），用于IPC通信

## 17.2 UNIX域套接字
相比传统的网络套接字效率更高，UNIX domain socket仅复制数据，并不执行协议处理：添加或删除网络报头、计算校验和、 产生顺序号、发送确认报文等操作
UNIX域套接字提供**流**和**数据报**两种接口，它就像是**套接字和管道的混合**
是**可靠的**、不会丢失报文、也不会出错
一对相互连接的UNIX域套接字可以起到**全双工管道**的作用

```cpp
#include <sys/socket.h>
int socketpair(int domain, int type, int protocol, int sockfd[2]);  // 可用于创建一对无名的、相互连接的UNIX域套接字
```

















