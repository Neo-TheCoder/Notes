
# 第一章 UNIX基础知识
OS为运行的程序提供服务
典型的服务：
执行新程序、打开文件、读文件、分配存储区、获得当前时间

## 1.2 UNIX体系结构
UNIX操作系统的体系结构
**内核**：控制计算机硬件资源，提供程序运行环境
***系统调用***就是内核的接口。

应用程序既可以使用公用函数库，又可以使用系统调用。
shell是特殊的应用程序，为运行其他程序提供接口。

Linux是GNU操作系统使用的内核，因此可以称这种操作系统为GNU/Linux操作系统。


## 1.4 文件和目录
目录是一个包含**目录项**的文件。
每个目录项都包含一个文件名，同时还包含说明该文件属性（是普通文件还是目录、文件大小、所有者、权限、最后修改时间）的信息。


## 1.5 输入和输出
### 1.5.1 文件描述符
小的非负整数，内核用以标识一个特定进程正在访问的文件
当内核打开或创建一个新文件时，都会返回一个文件描述符，读写文件时可用。


### 1.5.2 标准输入、标准输出和标准错误
每当允许一个程序，所有shell都为其打开3个文件描述符：
标准输入、标准输出、标准错误
不做特殊处理则3个描述符都连接向终端
```shell
ls > file.list
# 使得描述符重定向到某个文件
```

### 1.5.3 不带缓冲的I/O函数
open read write lseek close
都会使用文件描述符

### 1.5.4 标准I/O函数
为那些不带缓冲的I/O函数提供一个带缓冲的接口
比如printf


## 1.6 程序和进程
### 1 程序
是一个存储在磁盘上某个目录中的可执行文件、内核使用exec函数，将程序读入内存，并执行程序

### 2 进程和进程ID
程序的执行实例被称为进程(process)，某些OS用任务task表示正在被执行的程序
UNIX系统确保每个进程都有一个唯一的标识符

### 3 进程控制
fork exec waitpid

### 4 线程和线程ID

通常一个进程只有一个控制线程thread――――某一时刻执行的一租机器指令
一个进程内的所有线程共享同一地址空间、文件描述符、栈以及进程相关的属性
线程ID只在所属的进程内起作用

## 1.7 出错处理
整型变量errno记录错误类型
#include<errno.h>
extern int errno;
多线程环境中每个线程都有属于自己的局部errno


## 1.8 用户标识
### 1 用户ID
0标识root用户

### 2 组ID
用户组

### 3 附属组ID



## 1.9 信号
用于通知进程发生了某种情况
例如除数为0，则需要把SIGFPE的信号发给该异常。
进程对异常的处理：
1、忽略
2、默认方式：终止
3、捕捉，处理


## 1.10 时间值
1、日历时间
2、进程时间
    UNIX系统为一个进程维护3个进程时间值
    时钟时间
    用户CPU时间：执行用户指令所用的时间量
    系统CPU时间：为该进程执行内核程序所经历的时间


## 1.11 系统调用和库函数
通用库函数可能调用一个或多个内核的系统调用 并非内核的入口点
例如prinf函数会调用write系统调用以输出一个字符串
malloc调用sbrk

进程控制系统调用fork、exec wait通常直接由用户应用程序直接调用


# 第三章 文件IO
UNIX系统中的大多文件IO只用到:
open、read、write、lseek、close
这些函数都是不带缓冲的I/O(unbuffered I/O),意思是每个read和write都调用内核中的一个系统调用
本章涉及:多个进程间如何共享文件 以及涉及到的内核有关的数据结构

## 3.2 文件描述符
对于内核,所有打开的文件都通过文件描述符引用(一对一的标识打开的文件,用于read,write的参数)
UNIX系统shell把文件描述符0与进程的标准输入关联,即符号常量**STDIN_FILENO** 1--> 标准输出**STDOUT_FILENO**    2--> 标准错误**STDERR_FILENO**
文件描述符的变化范围:0 ~ OPEN_MAX - 1

## 3.3 函数open和openat
```cpp
#include<fcntl.h>
int open(const char* path, int oflag, ...);
int openat(int fd, const char* path, int oflag, ...);   // 用于相对路径
// 成功返回对应文件描述符 失败返回-1
```

***TOCTTOU: time of check to time of use***
如果有两个基于文件的函数调用,第二个依赖第一个的结果,这个程序就是脆弱的 因为两个调用**不是原子操作** 在两个函数调用之间文件可能改变

## 3.4 函数creat
创建新文件

## 3.5 函数close
关闭一个文件会释放该进程加在该文件上的所有记录锁
当一个进程终止,内核自动关闭所有它打开的文件

## 3.6 函数lseek
每个打开文件都维护一个"当前文件偏移量",记录从文件开始处的字节数
默认为0
```cpp
off_t currpos = lseek(fd, 0, SEE_CUR);
// 用于确定打开文件的当前偏移量
```
如果文件描述符指向一个管道 FIFO socket,lseek返回-1
文件偏移量可以大于文件的当前长度,对其下一次写将加长该文件,在文件中构成一个空洞(位于文件中但没有写过的字节都被读为0)
空洞不要求在磁盘上占用存储区

## 3.7 函数read
```cpp
ssize_t read(int fd, void* buf, size_t nbytes);
// 成功则返回读到的字节数
```
实际读到的字节数少于要求的字节数的情况比如:提前读到结尾 终端设备通常一次最多一行 本身就不包含这么多

## 3.8 函数write
```cpp
ssize_t write(int fd, void* buf, size_t nbytes);
// 成功则返回已写的字节数
```

## 3.9 I/O的效率
大多数文件系统采用预读(read ahead):当检测到正进行顺序读取时,系统试图读入比要求更多的数据,假定这些数据很快用到

## 3.10 文件共享
内核使用3种数据结构表示打开文件:
1. 每个进程有一个记录项:打开文件描述符表,持有每个文件描述符对应文件表项的指针
2. 内核为所有文件维护一个文件表,每一项包括
    文件状态标志(读\写\同步\非阻塞) --> 用于指定该文件表项的**任何进程**中的所有描述符,而文件描述符局限于一个进程
    当前文件偏移量
    指向该文件v节点表项的指针
3. 每个打开文件(或设备)都有一个v节点
    v节点:包含文件类型和对此文件进程各种操作函数的指针 此外 还包含该文件的i节点(i node索引节点 --> ***虚拟文件系统***)
    这些信息在打开文件时从磁盘读入内存
    i节点:包含问年所有者 文件长度 指向文件实际数据块在磁盘上所在位置的指针

如果两个独立进程各自打开一个文件,那么这两个进程表项(假设文件描述符分别为3, 4)指向**两个文件表项**(见图),它们指向同一个V节点表项
毕竟每个进程都需要拥有自己对该文件的当前偏移量
但也可能有多个文件描述符指向同一文件表项 --> dup函数 / fork父子进程共享


## 3.11 原子操作
举例:
AB进程对同一文件追加,可能存在这种情况,A先定位(lseek),B定位,写,A再写,A就把B写的内容覆盖了
追加的write操作是先定位到文件尾端,再写,本质上是两个分开的函数调用,应该要合成原子操作
任何要求多于一个函数调用的操作都不是原子操作,因为两个调用之间,内核可能挂起进程
对于以上情况,内核提供原子操作:打开文件时设置O_APPEND标志,这样内核在每次写操作之前,都将进程的当前偏移量设置到结尾,不用每个进程调用lseek

### 3.11.2 函数pread和pwrite
pread 等价于 lseek read
但无法中断定位和读操作 并且 不更新当前文件偏移量

### 3.11.3 创建一个文件
同理 open和creat不是原子操作

## 3.12 函数dup和dup2
用于复制现有的文件描述符
目的是共享同一文件状态标志,以及当前文件偏移量

```c
    dup(fd);
    // 等价于:
    fcntl(fd, F_DUPFD, 0);

    dup2(fd, fd2);
    // 等价于:
    close(fd2); // 若fd2已打开,则先关闭
    fcntl(fd, F_DUPFD, fd2);
    // 但是dup2是原子操作
```


## 3.13 函数sync fsync fdatasync
UNIX内核中有高速缓存 大多磁盘I/O通过缓冲区进行
**延迟写**
向文件写入数据时,内核先将数据复制到缓冲区,然后排入队列,晚点再写入磁盘
当内核需要重用缓冲区来存放其他磁盘块数据时,会把所有延迟写数据块写入磁盘
为了保证磁盘上实际文件系统和缓冲区内容的一致性,提供三个sync函数

### sync
只将所有修改过的块缓冲区排入写队列,然后直接返回,不等待实际磁盘操作结束
通常 名为update的系统守护进程周期性调用(一般每隔30秒)sync,从而保证定期flush内核的块缓冲区

### fsync
只对由fd指定的一个文件起作用,等待写磁盘操作结束才返回
fsync可用于数据库这样的应用程序,确保修改过的块立即写到磁盘

### fdatasync
相比fsync只影响文件的数据部分,而sync还同步更新文件的属性


## 3.14 函数fcntl
改变已打开文件的属性
```c
int fcntl(int fd, int cmd, ...);
// cmd有11个
```
有5个功能:
复制已有的描述符 获取/设置文件描述符标志 获取/设置文件状态标志 获取/设置异步I/O所有权 获取/设置记录锁


## 3.15 函数ioctl
I/O操作的杂物箱


## 3.16 /dev/fd
该目录的目录项时名为0,1,2等的文件
打开文件/dev/fd/n等价于复制描述符n
主要由shell使用






# 第七章 进程环境

## 7.2 main函数
```c
int main(int argc,char *argv[]);
// argc是命令行参数的数目 atgv是指向各个参数的各个指针构成的数组
```
内核执行C程序，调用exec函数，在调用main前先调用一个特殊的启动例程，可执行文件将此启动例程指定为程序的起始地址（链接器设置的）
启动例程从内核取得命令行参数和环境变量值


## 7.3 进程终止
1、main返回
2、调用exit
3、调用_exit或_Exit
4、最后一个线程从其启动例程返回
5、从最后一个线程调用pthread_exit
异常终止有3种
6、调用abort
7、接到一个信号
8、最后一个线程对取消请求做出响应

## 7.6 C程序的存储空间布局


# 第八章 进程控制
***关于UNIX系统的进程控制，包括创建新进程、执行程序和进程控制终止***

## 8.2 进程标识























  


# 第十五章 进程间通信


## 15.7 消息队列
本质上是消息的链表，存储在内核中，由消息队列的标识符标识










## 15.9 共享存储
需要注意多进程访问同一个存储区的同步问题
可通过信号量、记录锁、互斥量


int shmget(key_t key,size_t size,int flag);
返回一个共享存储标识符
若成功则返回共享存储的ID
size是共享内存段的长度 通常为系统页长的整数倍




共享存储区的位置，在栈空间（位于较高地址的位置）之下
高地址首先是命令行参数和环境变量，然后是栈空间、共享存储、堆区、未初始化的数据、已初始化的数据、地址最低的区域是正文
图15-32 在基于Intel的Linux系统上的存储区布局









# 第16章 网络IPC





## 16.2 套接字描述符
```c++
#include<sys/socket.h>
int socket(int domain,int type,int protocol);
// 若成功，则返回文件（套接字）描述符


```



# 第17章 高级进程间通信
## 17.1 引言
UNIX域套接字（Unix Domain Socket），用于IPC通信

## 17.2 UNIX域套接字
相比传统的网络套接字效率更高，UNIX domain socket仅复制数据，并不执行协议处理：添加或删除网络报头、计算校验和、 产生顺序号、发送确认报文等操作
UNIX域套接字提供**流**和**数据报**两种接口，它就像是**接字和管道的混合**
```cpp
#include <sys/socket.h>
int socketpair(int domain, int type, int protocol, int sockfd[2]);  // 可用于创建一对无名的、相互连接的UNIX域套接字
```

















