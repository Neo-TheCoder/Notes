
# 第一章 UNIX基础知识
OS为运行的程序提供服务
典型的服务：
执行新程序、打开文件、读文件、分配存储区、获得当前时间

## 1.2 UNIX体系结构
UNIX操作系统的体系结构
**内核**：控制计算机硬件资源，提供程序运行环境
***系统调用***就是内核的接口。

应用程序既可以使用公用函数库，又可以使用系统调用。
shell是特殊的应用程序，为运行其他程序提供接口。

Linux是GNU操作系统使用的内核，因此可以称这种操作系统为GNU/Linux操作系统。


## 1.4 文件和目录
目录是一个包含**目录项**的文件。
每个目录项都包含一个文件名，同时还包含说明该文件属性（是普通文件还是目录、文件大小、所有者、权限、最后修改时间）的信息。


## 1.5 输入和输出
### 1.5.1 文件描述符
小的非负整数，内核用以标识一个特定进程正在访问的文件
当内核打开或创建一个新文件时，都会返回一个文件描述符，读写文件时可用。


### 1.5.2 标准输入、标准输出和标准错误
每当允许一个程序，所有shell都为其打开3个文件描述符：
标准输入、标准输出、标准错误
不做特殊处理则3个描述符都连接向终端
```shell
ls > file.list
# 使得描述符重定向到某个文件
```

### 1.5.3 不带缓冲的I/O函数
open read write lseek close
都会使用文件描述符

### 1.5.4 标准I/O函数
为那些不带缓冲的I/O函数提供一个带缓冲的接口
比如printf


## 1.6 程序和进程
### 1 程序
是一个存储在磁盘上某个目录中的可执行文件、内核使用exec函数，将程序读入内存，并执行程序

### 2 进程和进程ID
程序的执行实例被称为进程(process)，某些OS用任务task表示正在被执行的程序
UNIX系统确保每个进程都有一个唯一的标识符

### 3 进程控制
fork exec waitpid

### 4 线程和线程ID

通常一个进程只有一个控制线程thread――――某一时刻执行的一租机器指令
一个进程内的所有线程共享同一地址空间、文件描述符、栈以及进程相关的属性
线程ID只在所属的进程内起作用

## 1.7 出错处理
整型变量errno记录错误类型
#include<errno.h>
extern int errno;
多线程环境中每个线程都有属于自己的局部errno


## 1.8 用户标识
### 1 用户ID
0标识root用户

### 2 组ID
用户组

### 3 附属组ID



## 1.9 信号
用于通知进程发生了某种情况
例如除数为0，则需要把SIGFPE的信号发给该异常。
进程对异常的处理：
1、忽略
2、默认方式：终止
3、捕捉，处理


## 1.10 时间值
1、日历时间
2、进程时间
    UNIX系统为一个进程维护3个进程时间值
    时钟时间
    用户CPU时间：执行用户指令所用的时间量
    系统CPU时间：为该进程执行内核程序所经历的时间


## 1.11 系统调用和库函数
通用库函数可能调用一个或多个内核的系统调用 并非内核的入口点
例如prinf函数会调用write系统调用以输出一个字符串
malloc调用sbrk

进程控制系统调用fork、exec wait通常直接由用户应用程序直接调用


# 第三章 文件IO
UNIX系统中的大多文件IO只用到:
open、read、write、lseek、close
这些函数都是不带缓冲的I/O(unbuffered I/O),意思是每个read和write都调用内核中的一个系统调用
本章涉及:多个进程间如何共享文件 以及涉及到的内核有关的数据结构

## 3.2 文件描述符
对于内核,所有打开的文件都通过文件描述符引用(一对一的标识打开的文件,用于read,write的参数)
UNIX系统shell把文件描述符0与进程的标准输入关联,即符号常量**STDIN_FILENO** 1--> 标准输出**STDOUT_FILENO**    2--> 标准错误**STDERR_FILENO**
文件描述符的变化范围:0 ~ OPEN_MAX - 1

## 3.3 函数open和openat
```cpp
#include<fcntl.h>
int open(const char* path, int oflag, ...);
int openat(int fd, const char* path, int oflag, ...);   // 用于相对路径
// 成功返回对应文件描述符 失败返回-1
```

***TOCTTOU: time of check to time of use***
如果有两个基于文件的函数调用,第二个依赖第一个的结果,这个程序就是脆弱的 因为两个调用**不是原子操作** 在两个函数调用之间文件可能改变

## 3.4 函数creat
创建新文件

## 3.5 函数close
关闭一个文件会释放该进程加在该文件上的所有记录锁
当一个进程终止,内核自动关闭所有它打开的文件

## 3.6 函数lseek
每个打开文件都维护一个"当前文件偏移量",记录从文件开始处的字节数
默认为0
```cpp
off_t currpos = lseek(fd, 0, SEE_CUR);
// 用于确定打开文件的当前偏移量
```
如果文件描述符指向一个管道 FIFO socket,lseek返回-1
文件偏移量可以大于文件的当前长度,对其下一次写将加长该文件,在文件中构成一个空洞(位于文件中但没有写过的字节都被读为0)
空洞不要求在磁盘上占用存储区

## 3.7 函数read
```cpp
ssize_t read(int fd, void* buf, size_t nbytes);
// 成功则返回读到的字节数
```
实际读到的字节数少于要求的字节数的情况比如:提前读到结尾 终端设备通常一次最多一行 本身就不包含这么多

## 3.8 函数write
```cpp
ssize_t write(int fd, void* buf, size_t nbytes);
// 成功则返回已写的字节数
```

## 3.9 I/O的效率
大多数文件系统采用预读(read ahead):当检测到正进行顺序读取时,系统试图读入比要求更多的数据,假定这些数据很快用到

## 3.10 文件共享
内核使用3种数据结构表示打开文件:
1. 每个进程有一个记录项:打开文件描述符表,持有每个文件描述符对应文件表项的指针
2. 内核为所有文件维护一个文件表,每一项包括
    文件状态标志(读\写\同步\非阻塞) --> 用于指定该文件表项的**任何进程**中的所有描述符,而文件描述符局限于一个进程
    当前文件偏移量
    指向该文件v节点表项的指针
3. 每个打开文件(或设备)都有一个v节点
    v节点:包含文件类型和对此文件进程各种操作函数的指针 此外 还包含该文件的i节点(i node索引节点 --> ***虚拟文件系统***)
    这些信息在打开文件时从磁盘读入内存
    i节点:包含问年所有者 文件长度 指向文件实际数据块在磁盘上所在位置的指针

如果两个独立进程各自打开一个文件,那么这两个进程表项(假设文件描述符分别为3, 4)指向**两个文件表项**(见图),它们指向同一个V节点表项
毕竟每个进程都需要拥有自己对该文件的当前偏移量
但也可能有多个文件描述符指向同一文件表项 --> dup函数 / fork父子进程共享


## 3.11 原子操作
举例:
AB进程对同一文件追加,可能存在这种情况,A先定位(lseek),B定位,写,A再写,A就把B写的内容覆盖了
追加的write操作是先定位到文件尾端,再写,本质上是两个分开的函数调用,应该要合成原子操作
任何要求多于一个函数调用的操作都不是原子操作,因为两个调用之间,内核可能挂起进程
对于以上情况,内核提供原子操作:打开文件时设置O_APPEND标志,这样内核在每次写操作之前,都将进程的当前偏移量设置到结尾,不用每个进程调用lseek

### 3.11.2 函数pread和pwrite
pread 等价于 lseek read
但无法中断定位和读操作 并且 不更新当前文件偏移量

### 3.11.3 创建一个文件
同理 open和creat不是原子操作

## 3.12 函数dup和dup2
用于复制现有的文件描述符
目的是共享同一文件状态标志,以及当前文件偏移量

```c
    dup(fd);
    // 等价于:
    fcntl(fd, F_DUPFD, 0);

    dup2(fd, fd2);
    // 等价于:
    close(fd2); // 若fd2已打开,则先关闭
    fcntl(fd, F_DUPFD, fd2);
    // 但是dup2是原子操作
```


## 3.13 函数sync fsync fdatasync
UNIX内核中有高速缓存 大多磁盘I/O通过缓冲区进行
**延迟写**
向文件写入数据时,内核先将数据复制到缓冲区,然后排入队列,晚点再写入磁盘
当内核需要重用缓冲区来存放其他磁盘块数据时,会把所有延迟写数据块写入磁盘
为了保证磁盘上实际文件系统和缓冲区内容的一致性,提供三个sync函数

### sync
只将所有修改过的块缓冲区排入写队列,然后直接返回,不等待实际磁盘操作结束
通常 名为update的系统守护进程周期性调用(一般每隔30秒)sync,从而保证定期flush内核的块缓冲区

### fsync
只对由fd指定的一个文件起作用,等待写磁盘操作结束才返回
fsync可用于数据库这样的应用程序,确保修改过的块立即写到磁盘

### fdatasync
相比fsync只影响文件的数据部分,而sync还同步更新文件的属性


## 3.14 函数fcntl
改变已打开文件的属性
```c
int fcntl(int fd, int cmd, ...);
// cmd有11个
```
有5个功能:
复制已有的描述符 获取/设置文件描述符标志 获取/设置文件状态标志 获取/设置异步I/O所有权 获取/设置记录锁


## 3.15 函数ioctl
I/O操作的杂物箱


## 3.16 /dev/fd
该目录的目录项时名为0,1,2等的文件
打开文件/dev/fd/n等价于复制描述符n
主要由shell使用






# 第七章 进程环境

## 7.2 main函数
```c
int main(int argc,char *argv[]);
// argc是命令行参数的数目 atgv是指向各个参数的各个指针构成的数组
```
内核执行C程序，调用exec函数，在调用main前先调用一个特殊的启动例程，可执行文件将此启动例程指定为程序的起始地址（链接器设置的）
启动例程从内核取得命令行参数和环境变量值


## 7.3 进程终止
1、main返回
2、调用exit
3、调用_exit或_Exit
4、最后一个线程从其启动例程返回
5、从最后一个线程调用pthread_exit
异常终止有3种
6、调用abort
7、接到一个信号
8、最后一个线程对取消请求做出响应

## 7.6 C程序的存储空间布局


# 第八章 进程控制
***关于UNIX系统的进程控制，包括创建新进程、执行程序和进程控制终止***

## 8.2 进程标识





# 第十章 信号
## 10.1 引言
信号是软件中断，信号提供了一种处理异步事件的方法：比如用户在中断键入中断键，就会通过信号机制停止一个程序，或及早终止管道中的下一个程序。
POSIX.1对可靠信号例程做了标准化（UNIX系统的早期版本就已提供信号机制，但是信号模型并不可靠，信号可能丢失）。

## 10.2 信号概念
每个信号都有一个名字，都是以'SIG'开头。
例如：
SIGABRT（夭折信号，进程调用abort时产生）、SIGALRM（闹钟信号，alarm函数设定的定时器超时后产生）
信号都被定义为正整数常量（定义在内核的头文件，然后在用提供给用户的头文件去包含它）
不存在编号为0的信号，kill函数对信号编号0有特殊应用（又被称为空信号）

### 可以产生信号的条件
1. Ctrl + C，Delete键都可以产生中断信号（SIGINT）
2. 硬件异常产生信号：除数为0、无效的内存引用（对应SIGSEGV信号）等。通常由硬件检测到这些条件，并通知内核，然后内核根据情况产生适当的信号。
3. 进程调用kill(2)函数可以将任意信号发送给另一个进程或进程组。接收信号进程和发送信号进程的所有者必须相同 / 发送信号进程的所有者必须是超级用户
4. 用户可用kill(1)命令将信号发送给其他进程
 常用于终止一个失控的后台进程
5.当检测到某种**软件条件**已经发生，并应将其通知有关进程时也产生信号 ，例如SIGURG（在网络连接上传来带外的数据），SIGPIPE（在管道的读进程已终止后，一个进程写此管道）以及SIGALRM

信号是**异步事件**的经典实例，毕竟产生信号的事件对于进程而言是随机的，进程不能简单地测试一个变量（如error）来判断是否发生了一个信号，而是必须告诉内核：在此信号发生时，请执行以下操作。

### 对信号的处理方法
1. 忽略
    SIGKILL和SIGSTOP是例外，不可忽略，它们向内核和超级用户提供了使进程终止或停止的可靠方法，如果忽略某些由硬件异常产生的信号（非法内存引用或除数为0），则进程运行行为是未定义

2. 捕捉
    通知内核在某种信号发生时，调用一个用户函数，从而执行用户对这种事件希望进行的处理
    例如：命令解释器程序，当用户键盘产生中断信号时，该命令解释器理论上应该回到主循环，终止当前命令，如果能够捕捉到SIGCHLD信号，则表示一个子进程已经终止，那么该信号的捕捉函数就可以调用waitpid以取得该子进程的进程ID以及它的终止状态

SIGKILL和SIGSTOP是例外，不可捕捉

3. 执行系统默认动作
默认动作一般是终止该进程
默认动作如果是终止+core，则意味着在进程当前工作目录的core文件中复制了该进程的内存映像（可以使用core文件检查进程终止时的状态）。


## 10.3 函数signal
```cpp
#include<signal.h>
void (*signal(int signo, void (*func)(int)))(int);
// signo 信号名、func的值是接到此信号后要调用的函数的地址（如果其值为SIG_IGN，则向内核表示忽略此信号；如果其值为SIG_DFL，则表示执行系统默认动作）
```
如果指定函数地址，则调用对应函数，这种处理被称为**信号处理程序**/**信号捕捉函数**
signal函数原型说明该函数要求两个入参，返回值是一个函数指针，它指向的函数返回值是void类型，有一个int入参（它的意义是指向之前的信号处理程序函数）。
```cpp
typedef void Sigfunc(int);
Sigfunc *signal(int, Sigfunc*);
```




















  


# 第十五章 进程间通信


## 15.6 XSI IPC
3种IPC被称为**XSI IPC**：消息队列、信号量、共享存储，三者有相似之处
（其实现源自于UNIX系统的System V版本，最终在POSIX标准上得以规定）

### 15.6.1 标识符和键
每个内核中的IPC结构（消息队列、信号量、共享内存）都是通过**标识符**（非负整数，相比文件描述符而言，是比较大的整数）来引用
例如，要向一个消息队列发送消息或者从一个消息队列取消息，只需要知道其队列标识符。
当一个IPC结构被创建，然后又被删除时，与这种结构相关的标识符连续加1，这样的操作会1直到达到一个整型数的最大正值，之后再回到0。
标识符时IPC对象的内部名，还需要一个外部名字（称之为key）来使得多个合作进程能够再同一IPC对象上汇聚。
在通过mssget、semget、shmget创建IPC结构时，都应指定一个键（是基本系统数据类型key_t,在<sys/types.h>被定义为长整型），它由内核变换成标识符

#### 使client进程和server进程能够再同一IPC对象上汇聚
1. server指定键**IPC_PRIVATE**（使用IPC_PRIVATE创建的IPC对象, key值属性为0，和IPC对象的编号就没有了对应关系，用于有亲缘关系的进程。可用于父进程子关系，父进程通过它创建的IPC结构返回的标识符可供fork后的子进程使用）创建一个新IPC结构，将返回的标识符放在文件等地以便client进程取用
2. 在一个公用头文件中定义一个client和server都认可的键，然后server通过此键创建一个新的IPC结构（但是该键可能已经和一个IPC结构相结合）
3. client和server进程认同同一个路径名和项目ID（0 ~ 255），然后调用ftok将这两个值变换为一个键，然后使用方法2

### 15.6.2 权限结构
每个XSI IPC结构关联一个ipc_perm结构，规定了权限和所有者。

### 15.6.3 结构限制
三者都有内置限制，但大多可以通过重新配置内核来改变

### 15.6.4 优点和缺点
#### 缺点
1. IPC结构是在系统范围内起作用的，**没有引用计数**
例如：如果进程创建了一个消息队列，并往队列放了几则消息，然后终止，这个消息队列及其内容都不会删除（除非被某个进程删除），如果是管道的话，当最后一个引用管道的进程终止时，管道就会被删除。如果是FIFO（有名管道），当最后一个引用FIFO的进程终止时，虽然FIFO的名字还会保存在系统中，但是其中的数据会被删除。

2. 这些IPC结构在文件系统中没有名字
因而无法使用文件操作（ls、rm、chmod），内核因此增加了十几个全新的系统调用（msgget、semop、shmat）
因为这些IPC不存在文件描述符，所以不能使用多路转换I/O函数（select、poll），因而很难一次使用两个及以上的XSI IPC结构。


#### 优点
可靠（因为范围在一台主机）、流控制的（如果系统资源（缓冲区）短缺，活接收进程不能再接收更多消息，则发送进程休眠，当流控制条件消失时，发送进程自动唤醒）、面向记录的
而UNIX流套接字可以做到：IPC设施能自动地为每个客户进程创建一个到服务器进程的唯一连接




## 15.7 消息队列
本质上是**消息的链表**，存储在内核中，由消息队列的标识符标识
**msgget**用于创建一个新队列或打开一个现有队列，**msgsnd**用于将新消息添加到队列尾端。
每个队列都有一个msqid_ds结构与其关联，用于表示队列的当前状态

```cpp
#include<sys/msg.h>
int msgget(key_t key, int flag);    // 若成功，则返回消息队列ID，若出错，则返回-1

```








## 15.9 共享存储
需要注意多进程访问同一个存储区的同步问题
可通过信号量、记录锁、互斥量


```cpp
int shmget(key_t key,size_t size,int flag);
// 返回一个共享存储标识符
// 若成功则返回共享存储的ID
// size是共享内存段的长度 通常为系统页长的整数倍
```



共享存储区的位置，在栈空间（位于较高地址的位置）之下
高地址首先是命令行参数和环境变量，然后是栈空间、共享存储、堆区、未初始化的数据、已初始化的数据、地址最低的区域是正文
图15-32 在基于Intel的Linux系统上的存储区布局







# 第16章 网络IPC





## 16.2 套接字描述符
```c++
#include<sys/socket.h>
int socket(int domain,int type,int protocol);
// 若成功，则返回文件（套接字）描述符


```



# 第17章 高级进程间通信
## 17.1 引言
UNIX域套接字（Unix Domain Socket），用于IPC通信

## 17.2 UNIX域套接字
相比传统的网络套接字效率更高，UNIX domain socket仅复制数据，并不执行协议处理：添加或删除网络报头、计算校验和、 产生顺序号、发送确认报文等操作
UNIX域套接字提供**流**和**数据报**两种接口，它就像是**套接字和管道的混合**
是**可靠的**、不会丢失报文、也不会出错
一对相互连接的UNIX域套接字可以起到**全双工管道**的作用

```cpp
#include <sys/socket.h>
int socketpair(int domain, int type, int protocol, int sockfd[2]);  // 可用于创建一对无名的、相互连接的UNIX域套接字
```

















