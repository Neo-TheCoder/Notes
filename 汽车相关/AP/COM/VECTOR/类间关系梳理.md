# 前言
要把ara-com someip的代码，和SOME/IP协议栈结合起来看


# amsr

## amsr-socal
### `Runtime`
创建必要的binding实例。
```cpp
/*!
 * \brief The Runtime class creates necessary binding instances.
 * Runtime is derived from base class RuntimeConfigModel as it has the right to change configuration parameters.
 * \vpublic
 */
class Runtime {
 public:

// 单例模式，提供访问接口
  static Runtime& getInstance() noexcept;

  ara::core::Result<void> InitializeCommunication(JsonFilePath const& json_config_path) noexcept;

};
```


### `InitializeInternal` 
`private api`
考虑线程安全
启动reactor线程
实例化binding池、初始化所有binding，然很信号置位

```cpp
/*! \internal
 * - If the Runtime instance is not alive for multi-threaded applications
 *   - Call HandleErrorNotRunning.
 * - Otherwise, Initialize the reactor thread.
 * - Instantiating the binding pool and initialize all bindings.
 * - Flag that signalizes that runtime and bindings have been initialized.
 * - Start all dynamic actions of all bindings.
 * \endinternal
 */
void Runtime::InitializeInternal() noexcept {
  if (is_running_) {
    HandleErrorAlreadyRunning();
  }

  // Maximum number of callbacks the reactor needs to handle.
  constexpr std::uint16_t max_reactor_callback_count{1024};

  // Initialize the reactor thread. Reactor required before binding initialization because bindings may initialize
  // connections (e.g. SOME/IP).
  // The real communication via the reactor must only be started after StartBindings() is called.
  InitializeReactorAndTimerManager(max_reactor_callback_count);
  InitializeReactorThread(GetReactorThreadConfig());

  // Instantiating the binding pool and initialize all bindings.
  logger_.LogDebug([](ara::log::LogStream& s) { s << "InitializeBindings"; }, __func__, __LINE__);
  InitializeBindings();

  InitializeThreadPools();

  // Flag that signalizes that runtime and bindings have been initialized.
  is_running_ = true;

  // Start all dynamic actions of all bindings (receive / transmit paths, timers etc.)
  logger_.LogDebug([](ara::log::LogStream& s) { s << "StartBindings"; }, __func__, __LINE__);
  StartBindings();
}
```


其中`StartBindings();`的实现在src-gen








## amsr-someip






# src-gen
## `StartBindings()`
```cpp
void Runtime::StartBindings() noexcept {
  {
    // Start SOME/IP binding
    amsr::someip_binding_transformation_layer::internal::GetInstance().Start();
  }
}

```

```cpp
::amsr::someip_binding_transformation_layer::internal::AraComSomeIpBinding<>& GetInstance() noexcept {
  // Someip binding initializer/deinitializer class that holds the AraComSomeIpBinding instance
  ::amsr::someip_binding_transformation_layer::internal::SomeipBindingInitializer& initializer{
      SomeipBindingInitializer::getInstance()};   // 创建static 的 SomeipBindingInitializer 对象，并返回
  return *initializer.GetBinding();   // 
}
```

此处调用了`GetInstance()`返回`AraComSomeIpBinding`对象，返回静态变量
```cpp
SomeipBindingInitializer::SomeIpBindingType* SomeipBindingInitializer::GetBinding() noexcept {
  if (!aracom_someip_binding_.has_value()) {
    ::ara::core::Abort("SOME/IP Binding has never been initialized.");
  }
  return &(aracom_someip_binding_.value());
}
```

### `AraComSomeIpBinding类`的`Start()`
```cpp
  /*!
   * \brief       Start all dynamic actions of the SOME/IP binding.
   * \details     In this API context all events triggered by the reactor thread must be activated / registered:
   *              - Register received events
   *              - Start any message transmission
   *              - Start timers
   * \pre         Initialize() has been called.
   * \pre         SomeIpDaemon must be running and must accept connection requests
   * \context     Init
   * \threadsafe  FALSE
   * \reentrant   FALSE
   * \vprivate
   * \synchronous TRUE
   *
   * \internal
   * - Connect to SOME/IP Daemon.
   * - Start Service Discovery for all Required Service Instances.
   * \endinternal
   */
  void Start() {
    logger_.LogInfo([](::ara::log::LogStream& s) { s << "Starting SOME/IP binding."; }, __func__, __LINE__);

    // Connect to the SOME/IP daemon
    someip_daemon_client_.Connect();
    // Start the SOME/IP daemon client.
    someip_daemon_client_.Start();
    logger_.LogInfo([](::ara::log::LogStream& s) { s << "Connection to SOME/IP Daemon has been established."; },
                    __func__, __LINE__);

    client_manager_.StartServiceDiscovery();
    logger_.LogInfo([](::ara::log::LogStream& s) { s << "SOME/IP Service Discovery started."; }, __func__, __LINE__);
  }
```
注意：
`AraComSomeIpBinding类`和`AraComSomeIpBindingClientManager<SomeIpDaemonClient>`，是前者持有后者作为成员变量的关系
`AraComSomeIpBinding类`同时还持有`AraComSomeIpBindingServerManager<SomeIpDaemonClient>`
而整个someipbinding就一个对象。client_manager和server_manager也都对应实例化一个。所以，假如当前swc是service skeleton，这里的client_manager的`StartServiceDiscoveery()`也是照样调用，只不过不做啥有意义的事情。


```cpp
/*!
 * \brief Realizes a concrete Binding for the proxy communication via SOME/IP and serves as an
 * anchor between the application-side and the communication protocol of SOME/IP.
 * For each concrete binding like this, there is only one object of this type available at runtime (singleton).
 * \tparam SomeIpPosix Used SOME/IP transport layer
 */
template <typename SomeIpPosix = ::amsr::someip_daemon_client::internal::SomeIpDaemonClient<
              ::amsr::someip_daemon_client::internal::SomeIpDaemonClientDefaultTemplateConfiguration>>
class AraComSomeIpBindingClientManager : public AraComSomeIpBindingClientManagerInterface {
 public:
  // ？？？
}；
```

```cpp
/*!
 * \brief Realizes a concrete Binding for the skeleton communication via SOME/IP and serves as an
 * anchor between the application-side and the communication protocol of SOME/IP.
 * For each concrete binding like this, there is only one object of this type available at runtime (singleton).
 * \tparam SomeIpPosix Used SOME/IP transport layer
 */
template <typename SomeIpPosix = ::amsr::someip_daemon_client::internal::SomeIpDaemonClient<
              ::amsr::someip_daemon_client::internal::SomeIpDaemonClientDefaultTemplateConfiguration>>
class AraComSomeIpBindingServerManager : public AraComSomeIpBindingServerManagerInterface {
 public:
// ？？？
};
```



`AraComSomeIpBindingClientManager`的`StartServiceDiscovery`
```cpp
  /*!
   * \brief       Start Service Discovery for all registered required service instances.
   * \pre         SomeIpDaemon must be connected to the application.
   * \context     Init, App
   * \threadsafe  FALSE
   * \reentrant   FALSE
   * \vprivate
   * \synchronous TRUE
   *
   * \internal
   * - For each required service instance.
   *   - Send Request Service command to SOME/IP Daemon (this will trigger the corresponding Client SM to start).
   * \endinternal
   */
  void StartServiceDiscovery() {
    typename RequiredServiceInstanceContainer::const_iterator const it_begin{
        required_service_instance_container_.cbegin()};
    typename RequiredServiceInstanceContainer::const_iterator const it_end{required_service_instance_container_.cend()};

    static_cast<void>(std::for_each(
        it_begin, it_end,
        [this](amsr::someip_binding::internal::RequiredServiceInstanceId const& required_service_instance) {
          // Note: Having different versions is currently not yet supported. Only Service ID and Instance ID
          // are passed here.
          ::amsr::someip_daemon_client::internal::ControlMessageReturnCode const request_service_return_code{
              someip_posix_.RequestService(required_service_instance.service_id,
                                           required_service_instance.instance_id)};
          if (request_service_return_code == ::amsr::someip_daemon_client::internal::ControlMessageReturnCode::kOk) {
            logger_.LogDebug(
                [&required_service_instance](ara::log::LogStream& s) {
                  s << "SD is successfully requested for ";
                  amsr::someip_binding::internal::logging::LogBuilder::LogRequiredServiceInstanceId(
                      s, required_service_instance);
                  s << ".";
                },
                __func__, __LINE__);
          } else {
            // Error while requesting the service -> SD will not start for this service.
            logger_.LogError(
                [&required_service_instance, &request_service_return_code](ara::log::LogStream& s) {
                  s << "SD failed for ";
                  amsr::someip_binding::internal::logging::LogBuilder::LogRequiredServiceInstanceId(
                      s, required_service_instance);
                  s << ". Reason: ";
                  amsr::someip_binding::internal::logging::LogBuilder::LogControlMessageReturnCodeAsString(
                      s, request_service_return_code);
                },
                __func__, __LINE__);
          }
        }));  // ignore std::for_each return value. The returned lambda function is not required for further processing.
  }
```



























